### 一、模板类别

​	数据结构：`Bron-Kerbosch` 算法。

### 二、模板功能

#### 1.构造图

1. 数据类型

   模板参数 `uint32_t _MAXN` ，表示无向图的点数上限。

   构造参数 `uint32_t __vertexNum`​ ，表示图中的具体点数。

2. 时间复杂度

   $O(n^2)$ 。

3. 备注

   `Bron-Kerbosch` 算法处理的问题为无向图中的最大团、最大独立集、最小顶点覆盖问题。

   最大团表示，每一对点之间都存在直接边的最大点集。
   
   最大独立集表示，每一对点之间，都不存在直接边的最大点集。

   最小顶点覆盖表示，选出最少数量的顶点点集，使得原图的每条边上都有端点在点集中。
   
   显然，最大团和最大独立集是镜像问题，求某图的最大团相当于求该图补图的最大独立集。
   
   而最大独立集和最小顶点覆盖为等价问题，在同一张图里，最大独立集的补集恰为最小覆盖点集，最小覆盖点集的补集恰为最大独立集。
   
   下文中以最大团模板为例进行介绍，最大独立集模板不再复述。最小顶点覆盖没有单独模板，求出最大独立集之后的补集即为最小覆盖点集。
   
   由于本模板只处理较小的图，且用邻接矩阵存图，所以会忽略掉重边。
   
   本模板会忽略掉自环。
   
   **注意：**
   
   本数据结构一开始指定的 `__vertexNum` 参数必须是确切值。
   

#### 2.加边

1. 数据类型

   输入参数 `uint32_t __a`​ ，表示无向边的起点编号。

   输入参数 `uint32_t __b` ，表示无向边的终点编号。

2. 时间复杂度

   $O(1)$ 。

3. 备注


#### 3.计算

1. 数据类型

   返回类型 `uint32_t` ，表示最大团的大小。

2. 时间复杂度

   $O(3^{\frac n 3})$ 。

#### 4.搜索所有最大团

1. 数据类型

   返回类型 `std::vector<std::vector<uint32_t>>` ，表示所有大小等于最大团大小的团。

2. 时间复杂度

   $O(3^{\frac n 3})$ 。

### 三、模板示例

```c++
#include "GRAPH/BronKerbosch.h"
#include "IO/FastIO.h"

int main() {
    // 无向图
    OY::BronKerbosch_MaxClique<100> G(5);
    // 加边
    G.addEdge(0, 1);
    G.addEdge(1, 2);
    G.addEdge(0, 2);
    G.addEdge(3, 1);
    // 求最大团
    cout << "max clique size: " << G.calc() << '\n';
}
```

```
#输出如下
max clique size: 3

```

