### 一、模板类别

​	数据结构：带懒惰标记的位集

### 二、模板功能

#### 1.建立位集

1. 数据类型

   构造参数 `int __n` ，表示位集的大小为 `__n`。

2. 时间复杂度

   $O(1)$。

3. 备注

   在标准库中有 `std::bitset` 可以作为位集，但是 `std::bitset` 有长度无法改变、无法进行区间修改、区间查询的缺点。本数据结构实现了区间赋值、区间翻转、区间查询 `1` 的数量的功能。

   在另一文件中，已经实现了 `OY::Bitset` 这一数据结构。但是该数据结构创建的时间复杂度是线性，面对上亿长度时力不从心。本数据结构以动态开点、懒惰更新的思想进行优化，可以支持上亿长度。

   本数据结构没有实现按位左移和按位右移的功能。

#### 2.重置

1. 数据类型

   输入参数 `int __n` ，表示位集的大小为 `__n`。

2. 时间复杂度

   同上。

####  3.全部置为 1

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `1` 。

#### 4.将某一位置为 1

1. 数据类型

   输入参数 `int __i` ，表示将下标 `__i` 位置置为 `1` 。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 5.将某一区间置为 1

1. 数据类型

   输入参数 `int __left` ，表示要修改的区间的起始下标。

   输入参数 `int __right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  6.全部置为 0

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `0` 。

#### 7.将某一位置为 0

1. 数据类型

   输入参数 `int __i` ，表示将下标 `__i` 位置置为 `0` 。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 8.将某一区间置为 0

1. 数据类型

   输入参数 `int __left` ，表示要修改的区间的起始下标。

   输入参数 `int __right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  9.全部翻转

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将位集的每一位翻转。

#### 10.将某一位置翻转

1. 数据类型

   输入参数 `int __i` ，表示将下标 `__i` 翻转。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 11.将某一区间翻转

1. 数据类型

   输入参数 `int __left` ，表示要修改的区间的起始下标。

   输入参数 `int __right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 12.查询第一个 1 的位置

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 13.查询前一个 1 的位置

1. 数据类型

   输入参数 `int __i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `__i` 之前全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 14.查询后一个 1 的位置

1. 数据类型

   输入参数 `int __i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `__i` 之后全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 15.查询最后一个 1 的位置

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 16.查询 1 的总数

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 17.查询区间中 1 的总数

1. 数据类型

   输入参数 `int __left` ，表示要查询的区间的起始下标。

   输入参数 `int __right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 18.查询某下标

1. 数据类型

   输入参数 `int __i` ，表示要查询的下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 19.查询是否全部为 1

1. 数据类型

2. 时间复杂度

   $O(1)$ 。
   

#### 20.查询是否有 1

1. 数据类型

2. 时间复杂度

   $O(1)$。


#### 三、模板示例

```c++
#include "DS/LazyBitset.h"
#include "IO/FastIO.h"

int main() {
    OY::LazyBitset B(100000000);
    //将区间置为 1
    B.set(10000000, 30000000);
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;
    //将区间置为 0
    B.reset(5000000, 14000000);
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;
    //将整个位集翻转
    B.flip();
    cout << "B[10000000~20000000]=" << B.count(10000000, 20000000) << endl;

    for (int i = 13950000; i < 14050000; i += 10000)
        cout << "index " << i << ":" << B.at(i) << endl;

    //全部置为 0
    B.reset();

    B.set(160000);
    B.set(9800000);
    B.set(3570000);
    B.set(20000);
    for (int i = B.first(); i >= 0; i = B.next(i))
        cout << i << ' ';
    cout << endl;
    for (int i = B.last(); i >= 0; i = B.prev(i))
        cout << i << ' ';
    cout << endl;
}
```

```
#输出如下
B[10000000~20000000]=10000001
B[10000000~20000000]=6000000
B[10000000~20000000]=4000001
index 13950000:1
index 13960000:1
index 13970000:1
index 13980000:1
index 13990000:1
index 14000000:1
index 14010000:0
index 14020000:0
index 14030000:0
index 14040000:0
20000 160000 3570000 9800000 
9800000 3570000 160000 20000 

```

