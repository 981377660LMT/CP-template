### 一、模板类别

​	数据结构：`EdmondsKarp` 算法。

### 二、模板功能

#### 1.构造图

1. 数据类型

   模板参数 `typename _Tp` ，表示图中边权的类型。

   构造参数 `uint32_t __vertexNum`​ ，表示图中的点数。

   构造参数 `uint32_t __edgeNum` ，表示图中预备要存的边数。

2. 时间复杂度

   $O(n+m)$ 。

3. 备注

   `EdmondsKarp` 算法处理的问题为流网络的最大流问题。

   本数据结构不能处理带负权的边。
   
   本数据结构可以接受重边和自环。

   **注意：**
   
   本数据结构一开始指定的 `__vertexNum` 参数必须是确切值。
   
   一开始指定的 `__edgeNum` 参数可以是模糊值，是用来为加边预留空间的，即使一开始没有留够空间，也可以自动扩容。如果边数不确定，可以预估一个上限填进去。

#### 2.加边

1. 数据类型

   输入参数 `uint32_t __a`​ ，表示有向边的起点编号。

   输入参数 `uint32_t __b` ，表示有向边的终点编号。

   输入参数 `_Tp __cap` ，表示有向边的边容量。

2. 时间复杂度

   $O(1)$ 。


#### 3.预备

1. 数据类型

2. 时间复杂度

   $O(n+m)$ 。

3. 备注

   本方法用于在加完所有边后，进行一些预处理。

#### 4.按顺序预备

1. 数据类型

   模板参数 `typename _Compare` ，表示边的排序函数的类。默认为边的大于号函数。

   输入参数 `_Compare __comp`，表示具体的排序函数。默认为 `_Compare` 的默认实例。

2. 时间复杂度

   $O(n+m\cdot \log m)$ 。

3. 备注

   本方法用于在加完所有边后，进行一些预处理。

   本方法和普通“预备”函数的区别是，可以将邻接表里的边按一定顺序存放。使用时也可以自己传递一个匿名函数。

#### 5.求最大流

1. 数据类型

   输入参数 `uint32_t __source` ，表示源点。

   输入参数 `uint32_t __target` ，表示汇点。

   输入参数 `_Tp __infiniteCap` ，表示无穷大边权值。默认为 `_Tp` 类的最大值的一半。

2. 时间复杂度

   $O(n\cdot m^2)$ 。
   
3. 备注

   在调用本方法之前，请先预备或者按顺序预备。

### 三、模板示例

```c++
#include "GRAPH/EdmondsKarp.h"
#include "IO/FastIO.h"

int main() {
    //建图
    OY::EdmondsKarp<int> G(4, 5);
    //加五条边
    G.addEdge(3, 1, 300);
    G.addEdge(3, 2, 200);
    G.addEdge(1, 2, 200);
    G.addEdge(1, 0, 300);
    G.addEdge(0, 2, 400);
    G.prepare();
    //计算最大流
    cout << "max flow from 3 to 2: " << G.calc(3, 2) << endl;
}
```

```
#输出如下
max flow from 3 to 2: 500

```

