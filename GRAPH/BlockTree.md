### 一、模板类别

​	数据结构：圆方树。

### 二、模板功能

#### 1.构造图

1. 数据类型

   模板参数 `typename _Tp` ，表示图中边权的类型。默认为 `bool` ，表示为无权图。

   构造参数 `uint32_t __vertexNum`​ ，表示图中的点数。

   构造参数 `uint32_t __edgeNum` ，表示图中预备要存的边数。

2. 时间复杂度

   $O(n+m)$ 。

3. 备注

   圆方树可以将任意无向图转化为一棵树，然后在树上处理无向图的问题。由于图比树更复杂，所以转化为树后，可以简化很多问题。

   假设原图有 `n` 个结点， `k` 个点双连通分量。特别的，以下讨论只讨论 `n > 1` 的情况。
   
   那么新建立的圆方树有 `n + k` 个结点，其中编号为 `[0, n - 1] ` 的结点为原图中的结点，编号为 `[n, n + k - 1]` 的结点为代表原图中编号为 `[0, k - 1]`的点双连通分量的虚拟结点。我们称前者为圆点，后者为方点。

   圆方树的边和原图的边毫无关系。因为圆方树是树，所以边数恰比点数少一，边数为 `n + k - 1` 。圆方树中的边，来源于图中每个结点到自己所在的点双连通分量的代表结点所连的虚拟边。根据 `tarjan` 求点双连通分量的知识可知，所有点双连通分量里的点数之和为 `n + k - 1` ，每个点双连通分量里的结点向代表结点连边的数目之和自然也为 `n + k - 1` 。
   
   易发现，圆方树有如下几个性质：
   
   1. 树上只存在圆点和方点的连边，不存在圆点和圆点的连边，也不存在方点和方点的连边。
   2. 树上的结点，圆点和方点逐层交替出现。
   3. 圆点的度表示一个结点位于几个点双连通分量之中。如果圆点为根，当其度大于 `1` 时为割点，否则不为割点。如果圆点为叶结点，必不为割点。其余情况下，圆点必然连接超过一个方点，所以必为割点。
   4. 方点的度表示一个点双连通分量包含几个结点。
   5. 两个圆点之间的简单路径，恰为原图里这两个点间的简单路径。值得注意的是，两个圆点之间的简单路径上的方点，是点双连通分量的代表结点，所以这个点双连通分量里的每个结点都可以出现在简单路径上。
   6. 在有权的情况下，令方点到父结点圆点的距离为 `0` ，令方点到子结点圆点的距离为原图中父结点到子结点的最短路。则两圆点在在圆方树上求出的最短路距离，恰为在原图中的最短路距离。
   
   本数据结构只接受无向连通图。
   
   本数据结构不能处理带负权的边。
   
   本数据结构可以接受重边和自环。
   
   **注意：**
   
   本数据结构一开始指定的 `__vertexNum` 参数必须是确切值。
   
   一开始指定的 `__edgeNum` 参数可以是模糊值，是用来为加边预留空间的，即使一开始没有留够空间，也可以自动扩容。如果边数不确定，可以预估一个上限填进去。

#### 2.加边

1. 数据类型

   输入参数 `uint32_t __a`​ ，表示无向边的一端的结点编号。

   输入参数 `uint32_t __b` ，表示无向边的另一端的结点编号。

2. 时间复杂度

   $O(1)$ 。
   
3. 备注

   本方法仅在无权图中使用。

#### 3.加边

1. 数据类型

   输入参数 `uint32_t __a`​ ，表示无向边的一端的结点编号。

   输入参数 `uint32_t __b` ，表示无向边的另一端的结点编号。

   输入参数 `_Tp __distance` ，表示无向边的权值。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本方法仅在有权图中使用。

#### 4.运行主算法

1. 数据类型

   模板参数 `bool _IsCactus` ，表示原图是否为仙人掌图。默认为 `false` 。

   输入参数 `uint32_t __root` ，表示要以哪个结点为圆方树的根，默认为 `0` 。

   输入参数 `distance_type __inifniteDistance` ，表示无穷大距离，默认为 `distance_type` 类的最大值的一半。

2. 时间复杂度

   在无权图或者为仙人掌图的有权图中，为$O(n+m)$ 。

   在不为仙人掌图的有权图中，为$O(m\cdot\log n)$ 。

3. 备注

   本方法用于在加完所有边后，构建圆方树，并设置根为 `__root` 。

   如果 `_Tp` 类型为 `bool` 类型，表示原图为无权图，新建的圆方树也为无权树。

   如果 `_Tp` 类型不为 `bool` 类型，且原图为仙人掌图，新建的圆方树为有权树，且边权依据 `tarjan` 算法中的预处理结果确定。

   如果 `_Tp` 类型不为 `bool` 类型，且原图不为仙人掌图。则在建树前，需要运行最短路算法计算从根结点到各个结点的最短路距离，以确定新建的圆方树的边权。

   仙人掌图的概念在 `tarjan` 模板中已有介绍。

#### 5.查询仙人掌图中，同环两点的最短路

1. 数据类型

   输入参数 `uint32_t __a`，表示环上的一个结点。

   输入参数 `uint32_t __b`，表示环上的另一个结点。

   输入参数 `uint32_t __groupId`，表示所在点双连通分量的编号。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   在调用本方法前，需要先运行主算法。

   本方法仅适用于仙人掌图。

### 三、模板示例

```c++
#include "GRAPH/BlockTree.h"
#include "IO/FastIO.h"

int main() {
    // 建立圆方树
    // 图的地址在 https://oi-wiki.org/graph/images/block-forest4.svg
    // 我把 9 号换成了 0 号，这是唯一区别
    OY::BlockTree G(9, 12);
    G.addEdge(1, 2);
    G.addEdge(2, 3);
    G.addEdge(3, 1);
    G.addEdge(3, 4);
    G.addEdge(4, 5);
    G.addEdge(5, 3);
    G.addEdge(5, 6);
    G.addEdge(6, 4);
    G.addEdge(3, 7);
    G.addEdge(7, 8);
    G.addEdge(8, 3);
    G.addEdge(7, 0);
    // 运行主算法，以 1 为根建树
    G.calc<false>(1);
    // 获取树
    auto &tree = G.m_tree;
    // 输出树，可以在 http://mshang.ca/syntree/ 观察
    cout << tree << endl;

    // 预处理各点深度
    // 注意，圆方树中点数不为 9 ，而是 13 ，因为新增了四个点双连通分量的代表结点
    int depth[14];
    auto dfs = [&](auto self, int i, int d) -> void {
        depth[i] = d;
        for (auto &adj : tree.m_adj[i])
            if (int to = adj.to; to != tree.m_parent[i])
                self(self, to, d + 1);
    };
    dfs(dfs, tree.m_root, 0);

    // 查找两点间简单路径的必经点
    auto find_cut_point = [&](int a, int b) {
        std::vector<int> path;
        // 先统一深度
        while (depth[a] != depth[b]) {
            if (depth[a] > depth[b])
                path.push_back(a), a = tree.m_parent[a];
            else
                path.push_back(b), b = tree.m_parent[b];
        }
        // 向上靠拢
        while (a != b) {
            path.push_back(a);
            path.push_back(b);
            a = tree.m_parent[a];
            b = tree.m_parent[b];
        }
        // 路径中有圆点有方点，我们挑出圆点
        std::vector<int> res;
        for (int a : path)
            if (a < 9) res.push_back(a);
        return res;
    };
    cout << "find cut point of path(6 -> 0):";
    for (auto a : find_cut_point(6, 0)) cout << ' ' << a;
}
```

```
#输出如下
[1[9[3[10[4][5][6]][11[7[12[0]]][8]]][2]]]
find cut point of path(6 -> 0): 0 6 7

```

