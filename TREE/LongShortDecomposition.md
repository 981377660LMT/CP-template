### 一、模板类别

​	数据结构：长短链（树链剖分）。

### 二、模板功能

#### 1.预处理

1. 数据类型

   模板参数 `typename _Tree` ，表示树的类型。

   模板参数 `typename _Tp` ，表示要进行区间最值查询的元素类型。

   模板参数 `typename _Maximum` ，表示最值函数的类。

   模板参数 `typename _Solver` ，表示借以进行区间查询的数据结构，默认为 `STTable` 。

   构造参数 `_Tree &__tree`​ ，表示树。

   构造参数 `_Mapping __map` ，表示从结点编号到其权值的映射。

   构造参数 `_Maximum __maxi` ，表示具体的最值函数，默认为 `_Tp` 类的取最大值函数。

   构造参数 `_Tp __defaultValue` ，表示默认元素值。默认为 `_Tp` 类的默认值。

2. 时间复杂度

   $O(n\cdot \log n)$ 。
   
3. 备注

   树链剖分指的是，将整个树分割成若干条自上而下的链，且该链在树的遍历序列里连续。当要对树上的某个路径进行处理时，可以将路径分割成若干条链，也就是树的遍历序列上的若干个区间，而在一维序列上进行区间操作，难度就降低很多。

   显然，一个子树对应的序列元素也是连续的。

   `m_height` 属性表示以每个结点为根的子树的高度，叶结点高度为 `1`。

   `m_depth` 属性表示每个结点距离根结点的距离。

   `m_heavySon` 属性表示每个结点的**重子结点** 。如果没有孩子，那么值为 `-1` 。

   `m_belongTop` 属性表示每个结点所在的链的最高处的结点。

   `m_fa` 属性表示每个结点的各代祖先结点，`m_fa[i][j]` 表示结点 `j` 的 `1<<i` 辈父结点。

   `m_val` 属性用来保存每个结点的权值。

   `m_sub` 属性表示每个节点上诉若干代的区间最值，`m_sub[i][j]` 表示从结点 `j` 到结点 `j` 的 `1<<i` 辈父结点，这条路上的最值。
   
   **注意：**本数据结构只擅长维护静态的数据，和高速的查询。如果树上的点的权值是动态变化的，变化后需要及时维护，那么还是需要重链剖分。

#### 2.获取某结点的祖先

1. 数据类型

   输入参数 `uint32_t __a` ，表示结点编号。

   输入参数 `uint32_t __n` ，表示要查询 `__n` 级祖先。
   
2. 时间复杂度

   $O(1)$ 。
   
3. 备注

   本方法不会对参数进行检查，所以请自行确保参数合法。（`__n` 不要超过 `__a` 的深度）。
#### 3.查询 LCA

1. 数据类型

   输入参数 `uint32_t __a` ，表示第一个结点。

   输入参数 `uint32_t __b` ，表示第二个结点。

   返回类型 `uint32_t` ，表示最近公共祖先结点的编号。

2. 时间复杂度

   $O(\sqrt n)$ 。

3. 备注

   尽管可以通过二分祖先的方法，在对数时间内求 `LCA` ，但是实际速度非常慢，不如爬链。所以本方法的实现仍然采用理论复杂度高、实践较快的爬链写法。

#### 4.查询某点权值

1. 数据类型

   输入参数 `uint32_t __a` ，表示结点编号。

2. 时间复杂度

   $O(1)$ 。

#### 5.查询某点到其祖先的路径最值

1. 数据类型

   输入参数 `uint32_t __a` ，表示结点编号。

   输入参数 `uint32_t __n` ，表示要查询其 `__n` 辈祖先。

2. 时间复杂度

   $O(1)$ 。

#### 6.查询两点路径最值

1. 数据类型

   输入参数 `uint32_t __a` ，表示第一个结点的编号。

   输入参数 `uint32_t __b` ，表示第二个结点的编号。

2. 时间复杂度

   $O(\sqrt n)$ 。

3. 备注

   本方法先调用本数据结构的 `lca` 方法，找到 `lca` ，然后 $O(1)$ 计算路径最值。
   
   尽管本方法的时间复杂度很差，但是实际运行中，其他的求 `lca` 的算法也并不能快多少，所以本方法可以视为是最优。

#### 7.给定LCA，查询两点路径最值

1. 数据类型

   输入参数 `uint32_t __a` ，表示第一个结点的编号。

   输入参数 `uint32_t __b` ，表示第二个结点的编号。

   输入参数 `uint32_t __p` ，表示它们的最近公共祖先的编号。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本方法给试图用更优时间复杂度找到 `lca` ，然后 $O(1)$ 计算路径最值的人提供了接口。

   经测试，不管是用大常数的倍增求法，小常数的重链剖分，`RMQ` 求 `LCA` 还是用 `tarjan` 离线求 `LCA` ，速度都等同于甚至慢于本数据结构的 `lca` 。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "TREE/LongShortDecomposition.h"

int main() {
    //一个无权树
    OY::Tree<10> T(5);
    //加边
    T.addEdge(2, 0);
    T.addEdge(1, 3);
    T.addEdge(4, 0);
    T.addEdge(0, 3);
    T.prepare();
    //定根
    T.setRoot(3);
    //给出每个点的权值
    int w[5] = {10, 15, 12, 11, 13};

    //长短链预处理
    OY::LongShortDecomposition lsd(
        T, [&](int i) { return w[i]; }, std::max<int>);

    //查询 lca
    cout << "lca of 0 and 1 : " << lsd.lca(0, 1) << endl;

    //查询祖先
    cout << "2-level ancestor of 4 : " << lsd.getAncestor(4, 2) << '\n';

    //查询到某个祖先的路径最值
    cout << "max value from 4 to 2-level ancestor of 4 : " << lsd.queryUp(4, 2) << '\n';

    //查询两结点间的路径最值
    cout << "max value from 4 to 1 : " << lsd.query(4, 1) << '\n';
}
```

```
#输出如下
lca of 0 and 1 : 3
2-level ancestor of 4 : 3
max value from 4 to 2-level ancestor of 4 : 13
max value from 4 to 1 : 15

```

