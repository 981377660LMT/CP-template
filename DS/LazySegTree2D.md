### 一、模板类别

​	数据结构：二维线段树（可带懒惰标记）。

​	练习题目：

1. [P3372 【模板】线段树 1](https://www.luogu.com.cn/problem/P3372)
2. [P3373 【模板】线段树 2](https://www.luogu.com.cn/problem/P3373)
3. [P5494 【模板】线段树分裂](https://www.luogu.com.cn/problem/P5494)
4. [P3369 【模板】普通平衡树](https://www.luogu.com.cn/problem/P3369)

### 二、模板功能

​		显然， `SegTree2D` 并非 `SegTree` 在二维空间的延申，因为 `SegTree2D` 并未支持区间修改功能； `ZkwTree2D` 也非 `ZkwTree` 在二维空间的延申，因为 `ZkwTree2D` 也不支持区间修改功能。上述两个”二维线段树“，本质上是树套树，属于网格结构，难以实现通用的区间修改功能。只有树形结构的数据结构，结点上下级明确，才能建立通用的区间修改功能。

​		有鉴于此，特设计本数据结构，以支持二维区间修改功能。本数据结构完全对位 `SegTree` 在二维的延申，所以一切设定都可以照搬。

#### 1.建立二维线段树

1. 数据类型

   类型设定 `index_type = uint32_t` ，表示树中结点在内存池上的下标。

   模板参数 `typename Node` ，表示结点类型。

   模板参数 `typename RangeMapping` ，表示从区域映射到区域聚合值的映射函数所属的类。

   模板参数 `bool Complete` ，表示是否在构造时将整个区域初始化。

   模板参数 `typename SizeType` ，表示表示区域大小时，所采用的数的类型。在区间长度为 `1e9` 级别时，采用 `uint32_t` 为佳；区间长度更长时，采用 `uint64_t` 。当然采用有符号数也无大碍。

   模板参数 `SizeType MAX_NODE` ，表示最大结点数，默认为 `1<<22` 。

   构造参数 `SizeType row` ，表示二维线段树的行范围为 `[0, row)`。默认值为 `0` 。

   构造参数 `SizeType column` ，表示二维线段树的列范围为 `[0, column)`。默认值为 `0` 。

   构造参数 `InitMapping init_mapping` ，表示在初始化时，从区域到区域聚合值的映射函数。默认为 `LazySeg2D::NoInit` 。接收类型可以为普通函数，函数指针，仿函数，匿名函数，泛型函数等。

2. 时间复杂度

   当 `Complete` 参数为 `true` 时，为 $O(m\cdot n)$ ，其中 `m` 和 `n` 分别表示行数和列数；否则为 $O(1)$ 。

3. 备注

   基础二维线段树处理的问题为单点修改，单点/区域和的查询。

   带懒惰标记的二维线段树处理的问题为单点/区间修改，单点/区域和的查询。

   目前的二维线段树的大量细节都放到了模板参数 `Node` 中，只需要设计好 `Node` 即可让线段树工作。

   对于基础二维线段树来说，结点须满足以下要求：

   1. 声明 `value_type` 为值类型；
   2. 声明 `modify_type` 为修改类型；
   3. 定义静态函数 `op` ，接受两个 `value_type` 参数，返回它们的聚合值；
   4. 实现成员函数 `set` ，接受一个 `value_type` 参数，将此值赋给本结点；
   5. 实现成员函数 `get` ，返回本结点的值。

   至此，基础二维线段树所需的结点功能已经足够。此外，还可以添加如下功能：

   1. 定义静态函数 `map` ，接受一个修改值和一个结点指针，对该结点进行相应修改。如果没有定义本函数，则会把修改值和结点的旧值通过 `op` 函数聚合之后，赋给结点；
   2. 定义成员函数 `pushup` ，接受两个孩子结点的指针，聚合到当前结点。如果没有定义本函数，则会把两孩子结点的值通过 `op` 函数聚合之后，赋给当前结点。

   对于带懒惰标记的线段树来说，结点须满足以下要求：

   1. 声明 `value_type` 为值类型；
   2. 声明 `modify_type` 为修改类型；
   3. 定义静态函数 `op` ，接受两个 `value_type` 参数，返回它们的聚合值；
   4. 定义静态函数 `map` ，接受一个修改值、一个结点指针、一个表示当前结点区域行宽的数字、一个表示当前结点区域列宽的数字，对该结点的值进行相应修改；
   5. 定义静态函数 `com` ，接受一个修改值和一个结点指针，对该结点的懒惰增量进行相应修改；
   6. 实现成员函数 `set` ，接受一个 `value_type` 参数，将此值赋给本结点；
   7. 实现成员函数 `get` ，返回本结点的值；
   8. 实现成员函数 `get_lazy` ，返回本结点的懒惰增量；
   9. 实现成员函数 `clear_lazy` ，将本结点的懒惰增量清零；

   至此，带懒惰标记的线段树所需的结点功能已经足够。此外，还可以添加如下功能：

   1. 定义静态常量 `init_clear_lazy` ，返回布尔值，表示在初始化时是否需要对所有结点的懒惰增量清零。由于全局变量、静态变量区的 `int` 等类型本身就为零，如果这和懒惰增量的清零状态一致的话，就不需要再强制清零；但是如果有特殊的需求，比如进行乘法修改的增量清零后须为 `1` ，则须声明本常量并返回 `true` ;
   2. 定义成员函数 `pushup` ，接受两个孩子结点的指针，聚合到当前结点。如果没有定义本函数，则会把两孩子结点的值通过 `op` 函数聚合之后，赋给当前结点；
   3. 定义成员函数 `has_lazy` ，返回布尔值，表示本结点是否含有懒惰增量。如果定义本函数，在下传懒惰增量的时候会先进行判断，如果没有增量就不操作。如果没定义，则无论何时都进行下传操作。

   一般的，我们称 `op` 函数执行的是聚合操作， `map` 函数执行的是增值操作， `com` 函数执行的是囤积操作。

   基础二维线段树要求区间操作函数的运算符满足**结合律**和**交换律**。此处与一维线段树的区别就是，因为无法控制区间操作是先上下聚合再左右聚合，所以必须满足交换律。

   带懒惰标记的线段树要求聚合函数、增值函数和囤积函数的运算符都满足**结合律**，其中，聚合函数须满足**交换律**。

   **注意：**

   在上方介绍了两个不同的 `map` 函数，尽管这两个都是增值函数，但是出现在不同的场景里。前者仅仅出现在基础二维线段树中，用于对区域大小为 `1*1` 的结点进行增值，由于区域大小恒定，所以不需要再传递区间长度参数，而且本函数属于可有可无的函数；后者出现在带懒惰标记的线段树中，对各种区域大小的结点进行增值，所以需要传递区域行列宽度参数，此函数为带懒惰标记的线段树的实现关键。

   **注意：**

   模板参数中的 `RangeMapping` l类型，用于生成仿函数，入参为区域的首行下标、末行下标、首列下标、末列下标，返回值须为一个 `value_type` 对象，表示这个区域的初始聚合值。默认情况下， 为 `LazySeg2D::NoInit` 类，表示不进行初始化，比如要建立一颗空的二维求和线段树，由于全局变量值本身就是零，所以无需进行初始化。

   **注意：**

   正是由于 `LazySegTree2D` 不需要在一开始就初始化全部的结点，但有时 `LazySegTree2D` 需要一开始就全局初始化，所以产生了 `Complete` 参数和 `RangeMapping` 参数。假想有个情境下，初始时，值与下标呈一次函数关系，但是区域长宽达到 `1e9` 。此时 `LazySegTree2D` 就游刃有余。

   显然， `InitMapping` 函数和 `RangeMapping` 函数互斥，当开局就全部初始化时，可以传递 `InitMapping` ，但是肯定不需要 `RangeMapping` 参数，因为区域聚合值都可以通过子结点 `pushup` 得到；如果开局不全部初始化，可以设置 `RangeMapping` 参数，但是不需要传递 `InitMapping` 参数。


#### 2.重置(resize)

1. 数据类型

   输入参数 `SizeType row` ，表示二维线段树的行范围为 `[0, row)`。

   输入参数 `SizeType column` ，表示二维线段树的列范围为 `[0, column)`。

   输入参数 `InitMapping mapping` ，表示初始化时，从下标到值的映射函数。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   使用映射函数进行初始化，可以将区域初状态直接赋到二维线段树里。

    `mapping` 要求传入一个行号，一个列号，返回一个 `value_type` 类型的值。
   
   **注意：**
   
   在调用时，**不会**按照下标递增依次调用！


#### 3.单点赋值(modify)

1. 数据类型

   输入参数 `SizeType i​` ，表示单点赋值的行号。

   输入参数 `SizeType i` ，表示单点赋值的列号。

   输入参数 `const value_type &val​` ，表示赋的值。

2. 时间复杂度

   $O(\log (m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 4.单点增值(add)

1. 数据类型

   输入参数 `SizeType i` ，表示单点增值的行下标。

   输入参数 `SizeType j` ，表示单点增值的列下标。

   输入参数 `const modify_type &modify​` ，表示增量大小。

2. 时间复杂度

   $O(\log (m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 5.区域增值(add)

1. 数据类型

   输入参数 `SizeType row1` ，表示区域增值的起始行下标。

   输入参数 `SizeType row2` ，表示区域增值的结束行下标。（闭区间）

   输入参数 `SizeType column1` ，表示区域增值的起始列下标。

   输入参数 `SizeType column2` ，表示区域增值的结束列下标。（闭区间）

   输入参数 `const modify &modify​` ，表示增量大小。

2. 时间复杂度

   $O(\log (m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 6.单点查询(query)

1. 数据类型

   输入参数 `SizeType row` ，表示单点查询的行下标。

   输入参数 `SizeType column` ，表示单点查询的列下标。。

2. 时间复杂度

   $O(\log(m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）


#### 7.区域查询(query)

1. 数据类型

   输入参数 `SizeType row1` ，表示区域查询的起始行下标。

   输入参数 `SizeType row2` ，表示区域查询的结束行下标。（闭区间）

   输入参数 `SizeType column1​` ，表示区域查询的起始列下标。

   输入参数 `SizeType column2` ，表示区域查询的结束列下标。（闭区间）

2. 时间复杂度

   $O(\log(m\cdot n))$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 8.查询全部(query_all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。


### 三、模板示例

```c++
#include "DS/LazySegTree2D.h"
#include "IO/FastIO.h"

int main() {
    // Node 编写与一维线段树一样
    // 在此只展示最可能用到的二维可区域加的求和树

    // 注意，初始化的顺序是难以预测的
    int id = 0;
    OY::SegLazySumTree2D<false, uint32_t, 1000> S(4, 5, [&](int i, int j) {
        return id++;
    });
    cout << S << endl;

    S.add(0, 1, 0, 4, 100);
    S.add(2, 3, 0, 4, 1000);
    S.add(0, 3, 0, 1, 10000);
    S.add(0, 3, 2, 4, 100000);
    cout << S << endl;
}
```

```
#输出如下
11 5 9 12 8 4 6 15 7 7
[[0, 1, 4, 12, 14], [2, 3, 5, 13, 15], [6, 7, 10, 16, 18], [8, 9, 11, 17, 19]]
[[10100, 10101, 100104, 100112, 100114], [10102, 10103, 100105, 100113, 100115], [11006, 11007, 101010, 101016, 101018], [11008, 11009, 101011, 101017, 101019]]

```

