#include "DS/LazySegTree2D.h"
#include "IO/FastIO.h"

int main() {
    // Node 编写与一维线段树一样
    // 在此只展示最可能用到的二维可区域加的求和树

    // 注意，初始化的顺序是难以预测的
    int id = 0;
    OY::SegLazySumTree2D<false, uint32_t, 1000> S(4, 5, [&](int i, int j) {
        return id++;
    });
    cout << S << endl;

    S.add(0, 1, 0, 4, 100);
    S.add(2, 3, 0, 4, 1000);
    S.add(0, 3, 0, 1, 10000);
    S.add(0, 3, 2, 4, 100000);
    cout << S << endl;
}
/*
#输出如下
11 5 9 12 8 4 6 15 7 7
[[0, 1, 4, 12, 14], [2, 3, 5, 13, 15], [6, 7, 10, 16, 18], [8, 9, 11, 17, 19]]
[[10100, 10101, 100104, 100112, 100114], [10102, 10103, 100105, 100113, 100115], [11006, 11007, 101010, 101016, 101018], [11008, 11009, 101011, 101017, 101019]]
*/