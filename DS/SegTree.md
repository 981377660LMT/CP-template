### 一、模板类别

​	数据结构：支持动态开点的线段树

### 二、模板功能

#### 1.建立线段树

1. 数据类型

   模板参数 `typename _Tp` ，表示元素类型。

   模板参数 `typename _Operation`  ，表示区间操作函数的类，默认为 `std::plus<_Tp>` ，也就是加法。

   构造参数 `int __n` ，表示线段树的覆盖范围为 `[0, n)`。

   构造参数 `_Operation __op` ，表示具体的区间操作函数。默认为 `_Operation` 类的默认实例。本参数接收类型有：普通函数，函数指针，仿函数，匿名函数，泛型函数。

   构造参数 `_Tp __defaultValue` ，表示元素默认值，默认值为 `_Tp` 类的默认实例。

   构造参数 `_Tp __initValue` ，表示树中元素初始值，默认值为 `_Tp` 类的默认实例。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   线段树处理的问题为单点修改，单点/区间的查询。

   线段树要求区间操作函数的运算符满足**结合律**。

   线段树常常重载加法，维护区间和；或者重载最大值函数，维护区间最值。

   不同于树状数组，线段树对任意区间的查询，都是通过自下而上的累积而来，而非通过差分求得。所以线段树只需要重载一个区间操作函数即可。
   
   构造时，需满足 `__op(__initValue, __initValue) == __initValue` 。
   
   **注意：**本数据结构名为 `SegTree` ，和 `ZkwTree` 一样都是线段树。区别在于：
   
   1. 大多数人熟悉、使用 `SegTree` ，而 `ZkwTree` 较少有人使用；
   2. `SegTree` 可以处理维护较大范围的区间（甚至可以达到 $10^9$ ），因为 `SegTree` 可以动态开点，即树不一定是满二叉树，初始时可以是空的，在需要的时候再去初始化从根到叶子的一条链；而 `ZkwTree` 只能处理相对较小范围的区间（$10^6$ 以内），因为 `ZkwTree` 必须初始化整颗二叉树；
   3. 在处理较小范围区间的问题时， `SegTree` 的时间空间常数都偏大，效率偏低；而 `ZkwTree` 具有优秀的时空效率；

#### 2.建立线段树

1. 数据类型

   构造参数 `_Iterator __first` ，表示区间维护的区间头。

   构造参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

   其它同上。

2. 时间复杂度

   $O(n)$。

3. 备注

   同上。

   使用迭代器进行初始化，可以将区间初状态直接赋到线段树里。
   
   本构造函数不需要提供 `__initValue` ，初始值都通过迭代器提供。
   
   如果通过本方法构造线段树，请确认区间范围不是特别大（$10^6$ 以内）。本方法将一次性开出树中所有结点。


#### 3.重置

1. 数据类型

   输入参数 `int __n` ，表示线段树要处理的区间大小。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   调用本函数会将线段树大小改变，并将之前的合并信息重置。

#### 4.重置

1. 数据类型

   输入参数 `_Iterator __first` ，表示区间维护的区间头。

   输入参数 `_Iterator __last` ，表示区间维护的区间尾。（开区间）

2. 时间复杂度

   $O(n)$。

3. 备注

   同上。

   使用迭代器进行重置，可以将区间初状态直接赋到线段树里。
   
   本方法不需要提供 `__initValue` ，初始值都通过迭代器提供。
   
   如果通过本方法重置线段树，请确认区间范围不是特别大（$10^6$ 以内）。本方法将一次性开出树中所有结点。

#### 5.单点赋值

1. 数据类型

   输入参数 `int __i​` ，表示单点赋值的下标。

   输入参数 `_Tp __val​` ，表示赋的值。

2. 时间复杂度

   $O(\log n)$ 。

#### 6.单点增值

1. 数据类型

   输入参数 `int __i​` ，表示单点增值的下标。

   输入参数 `_Tp __inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log n)$ 。

#### 7.单点查询

1. 数据类型

   输入参数 `int __i` ，表示查询的下标。

2. 时间复杂度

   $O(\log n)$ 。


#### 8.区间查询

1. 数据类型

   输入参数 `int __left​` ，表示区间查询的开头下标。

   输入参数 `int __right​`，表示区间查询的结尾下标。(闭区间)

2. 时间复杂度

   $O(\log n)$ 。
   

#### 9.查询全部

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 10.查询第 $k$ 个元素

1. 数据类型

   输入参数 `_Tp __k​` ，表示要查询的元素从小到大的顺次。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   仅当线段树的元素类型 `_Tp` 为数字，且区间操作函数为加法的时候，本方法才有意义。

   顺次 `k​` 表示第 `k+1` 小，顺次 `0` 表示查询最小的元素。

### 三、模板示例

```c++
#include "DS/SegTree.h"
#include "IO/FastIO.h"

int main() {
    //本线段树 SegTree 功能与 ZkwTree 是基本一致的
    //这里展示一下 SegTree 维护超大范围区间的特点

    OY::SegTree tree_sum(1000000000,std::plus<int>{});
    cout << "sum(0~999999999)     =" << tree_sum.queryAll() << endl;

    tree_sum.update(100,10000);
    tree_sum.update(200,20000);

    cout << "sum(0~999999999)     =" << tree_sum.queryAll() << endl;
}
```

```
#输出如下
sum(0~999999999)     =0
sum(0~999999999)     =30000


```

