{
	"leetcode solution":{
		"description": "leetcode template",
		"body": [
			"#include\"IO/LeetcodeIO.h\"",
			"using namespace std;",
			"",
			"",
			"int main() {",
			"    REGISTER_CONSTRUCTOR_SOLUTION;",
			"    REGISTER_MEMBERFUNCTION_SOLUTION($1);",
			"    while (true) {",
			"        executor.constructSolution();",
			"        executor.executeSolution();",
			"    }",
			"}",
		],
		"prefix": "LEETCODE"
	},
	"leetcode class":{
		"description": "leetcode template",
		"body": [
			"#include\"IO/LeetcodeIO.h\"",
			"using namespace std;",
			"",
			"",
			"int main() {",
			"    REGISTER_CONSTRUCTOR_CLASS($1);",
			"    REGISTER_MEMBERFUNCTION_CLASS($1);",
			"",
			"    while (true) {",
			"        executor.constructClass();",
			"        while (executor) {",
			"            executor.executeClass();",
			"        }",
			"    }",
			"}",
		],
		"prefix": "LEETCODE"
	},
    "O3":{
        "prefix": "o3",
        "body": [
			"#pragma GCC optimize(3,\"Ofast\",\"inline\")",
        ],
        "description": "o3"
    },
	"oj":{
        "prefix": "oj",
        "body": [
			"#include <algorithm>",
			"#include <bit>",
			"#include <bitset>",
			"#include <cassert>",
			"#include <climits>",
			"#include <cstring>",
			"#include <iostream>",
			"#include <list>",
			"#include <map>",
			"#include <memory>",
			"#include <queue>",
			"#include <random>",
			"#include <set>",
			"#include <sstream>",
			"#include <stack>",
			"#include <unordered_set>",
			"#if defined(_WIN32)",
			"#include <windows.h>",
			"// split to make windows.h before psapi.h",
			"#include <psapi.h>",
			"#else",
			"#include \"sys/time.h\"",
			"#endif",
			"",
			"int main() {",
			"#ifdef OY_LOCAL",
			"#if defined(_WIN32)",
			"    struct TIME_AND_MEMORY {static auto GetMicroSecond() {static FILETIME ft;GetSystemTimeAsFileTime(&ft);return ft.dwLowDateTime;};static auto GetMemory() {PROCESS_MEMORY_COUNTERS pmc;GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));return pmc.WorkingSetSize;}uint32_t t0, t1;TIME_AND_MEMORY() : t0(GetMicroSecond()) {}~TIME_AND_MEMORY() {t1 = GetMicroSecond();cout << \"\\ntime cost = \"<<(t1-t0)/10000.0<<\" ms\\nmemory cost = \"<<(GetMemory()>>20)<<\" MB\\n \";}}tam;",
			"#else",
			"    struct TIME_AND_MEMORY {static auto GetMicroSecond() {static timeval ft;gettimeofday(&ft, nullptr);return ft.tv_sec * 1000000 + ft.tv_usec;};static auto GetMemory() {char _mem_buff[512] = {0};int used, now_use;fgets(_mem_buff, sizeof(_mem_buff), fopen(\"/proc/self/statm\", \"r\"));sscanf(_mem_buff, \"%d %d\", &used, &now_use);return now_use;}uint64_t t0, t1;TIME_AND_MEMORY() : t0(GetMicroSecond()) {}~TIME_AND_MEMORY() {t1 = GetMicroSecond();cout << \"\\ntime cost = \"<<(t1-t0)/1000.0<<\" ms\\nmemory cost = \"<<(GetMemory()/250)<<\" MB\\n \";}}tam;",
			"#endif",
			"#endif",
			"",
			"}",
        ],
        "description": "oj template"
    },
    "io synch":{
        "prefix": "IOS",
        "body": [
            "using std::cin,std::cout,std::endl;int _IO=[]{std::ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);",
			"#ifdef OY_LOCAL",
			"    freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);",
			"#endif",
			"return 0;}();",
        ],
        "description": "io synch"
    },
    "fast io":{
        "prefix": "IO",
        "body": [
			"namespace OY {",
			"#define cin OY::inputHelper<1 << 10, 20>::getInstance()",
			"#define getchar() ({char c=cin.getChar_Checked();cin.next();c;})",
			"#define cout OY::outputHelper<1 << 20>::getInstance()",
			"#define putchar cout.putChar",
			"#define endl '\\n'",
			"#define putlog(...) OY::printLog(\", \", __VA_ARGS__)",
			"    template <uint64_t _BufferSize = 1 << 10, uint64_t _BlockSize = 20>",
			"    class inputHelper {",
			"        FILE *m_filePtr;",
			"        char m_buf[_BufferSize], *m_end, *m_cursor;",
			"        bool m_ok;",
			"        void flush() {",
			"            uint64_t a = m_end - m_cursor;",
			"            if (a >= _BlockSize) return;",
			"            memmove(m_buf, m_cursor, a);",
			"            uint64_t b = fread(m_buf + a, 1, _BufferSize - a, m_filePtr);",
			"            m_cursor = m_buf;",
			"            if (a + b < _BufferSize) {",
			"                m_end = m_buf + a + b;",
			"                *m_end = EOF;",
			"            }",
			"        }",
			"",
			"    public:",
			"        explicit inputHelper(const char *inputFileName) : m_ok(true) {",
			"            if (!*inputFileName)",
			"                m_filePtr = stdin;",
			"            else",
			"                m_filePtr = fopen(inputFileName, \"rt\");",
			"            m_end = m_cursor = m_buf + _BufferSize;",
			"        }",
			"        ~inputHelper() { fclose(m_filePtr); }",
			"        static inputHelper<_BufferSize, _BlockSize> &getInstance() {",
			"#ifdef OY_LOCAL",
			"            static inputHelper<_BufferSize, _BlockSize> s_obj(\"in.txt\");",
			"#else",
			"            static inputHelper<_BufferSize, _BlockSize> s_obj(\"\");",
			"#endif",
			"            return s_obj;",
			"        }",
			"        static constexpr bool isBlank(char c) { return c == ' ' || c == '\\t' || c == '\\n' || c == '\\r'; }",
			"        static constexpr bool isEndline(char c) { return c == '\\n' || c == EOF; }",
			"        const char &getChar_Checked() {",
			"            if (m_cursor < m_end) return *m_cursor;",
			"            uint64_t b = fread(m_buf, 1, _BufferSize, m_filePtr);",
			"            m_cursor = m_buf;",
			"            if (b < _BufferSize) {",
			"                m_end = m_buf + b;",
			"                *m_end = EOF;",
			"            }",
			"            return *m_cursor;",
			"        }",
			"        const char &getChar_Unchecked() const { return *m_cursor; }",
			"        void next() { ++m_cursor; }",
			"        void setState(bool _ok) { m_ok = _ok; }",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp> & std::is_integral_v<_Tp>> * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (getChar_Unchecked() == '-') {",
			"                next();",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    ret = -(getChar_Unchecked() - '0');",
			"                    while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 - (getChar_Unchecked() - '0');",
			"                } else",
			"                    m_ok = false;",
			"            } else {",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    ret = getChar_Unchecked() - '0';",
			"                    while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"                } else",
			"                    m_ok = false;",
			"            }",
			"            return *this;",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp> & std::is_integral_v<_Tp>> * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (isdigit(getChar_Unchecked())) {",
			"                ret = getChar_Unchecked() - '0';",
			"                while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"            } else",
			"                m_ok = false;",
			"            return *this;",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_floating_point_v<_Tp>> * = nullptr>",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(_Tp &ret) {",
			"            bool neg = false, integer = false, decimal = false;",
			"            while (isBlank(getChar_Checked())) next();",
			"            flush();",
			"            if (getChar_Unchecked() == '-') {",
			"                neg = true;",
			"                next();",
			"            }",
			"            if (!isdigit(getChar_Unchecked()) && getChar_Unchecked() != '.') {",
			"                m_ok = false;",
			"                return *this;",
			"            }",
			"            if (isdigit(getChar_Unchecked())) {",
			"                integer = true;",
			"                ret = getChar_Unchecked() - '0';",
			"                while (next(), isdigit(getChar_Unchecked())) ret = ret * 10 + (getChar_Unchecked() - '0');",
			"            }",
			"            if (getChar_Unchecked() == '.') {",
			"                next();",
			"                if (isdigit(getChar_Unchecked())) {",
			"                    if (!integer) ret = 0;",
			"                    decimal = true;",
			"                    _Tp unit = 0.1;",
			"                    ret += unit * (getChar_Unchecked() - '0');",
			"                    while (next(), isdigit(getChar_Unchecked())) {",
			"                        unit *= 0.1;",
			"                        ret += unit * (getChar_Unchecked() - '0');",
			"                    }",
			"                }",
			"            }",
			"            if (!integer && !decimal)",
			"                m_ok = false;",
			"            else if (neg)",
			"                ret = -ret;",
			"            return *this;",
			"        }",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(char &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            ret = getChar_Checked();",
			"            next();",
			"            return *this;",
			"        }",
			"        inputHelper<_BufferSize, _BlockSize> &operator>>(std::string &ret) {",
			"            while (isBlank(getChar_Checked())) next();",
			"            if (getChar_Checked() != EOF) {",
			"                ret.clear();",
			"                do {",
			"                    ret += getChar_Checked();",
			"                    next();",
			"                } while (!isBlank(getChar_Checked()) && getChar_Unchecked() != EOF);",
			"            } else",
			"                m_ok = false;",
			"            return *this;",
			"        }",
			"        explicit operator bool() { return m_ok; }",
			"    };",
			"    template <uint64_t _BufferSize = 1 << 20>",
			"    class outputHelper {",
			"        FILE *m_filePtr = nullptr;",
			"        char m_buf[_BufferSize], *m_end, *m_cursor;",
			"        char m_tempBuf[50], *m_tempBufCursor, *m_tempBufDot;",
			"        uint64_t m_floatReserve, m_floatRatio;",
			"",
			"    public:",
			"        outputHelper(const char *outputFileName, int prec = 6) : m_end(m_buf + _BufferSize) {",
			"            if (!*outputFileName)",
			"                m_filePtr = stdout;",
			"            else",
			"                m_filePtr = fopen(outputFileName, \"wt\");",
			"            m_cursor = m_buf;",
			"            m_tempBufCursor = m_tempBuf;",
			"            precision(prec);",
			"        }",
			"        static outputHelper<_BufferSize> &getInstance() {",
			"#ifdef OY_LOCAL",
			"            static outputHelper<_BufferSize> s_obj(\"out.txt\");",
			"#else",
			"            static outputHelper<_BufferSize> s_obj(\"\");",
			"#endif",
			"            return s_obj;",
			"        }",
			"        ~outputHelper() {",
			"            flush();",
			"            fclose(m_filePtr);",
			"        }",
			"        void precision(int prec) {",
			"            m_floatReserve = prec;",
			"            m_floatRatio = pow(10, prec);",
			"            m_tempBufDot = m_tempBuf + prec;",
			"        }",
			"        outputHelper<_BufferSize> &flush() {",
			"            fwrite(m_buf, 1, m_cursor - m_buf, m_filePtr);",
			"            fflush(m_filePtr);",
			"            m_cursor = m_buf;",
			"            return *this;",
			"        }",
			"        void putChar(const char &c) {",
			"            if (m_cursor == m_end) flush();",
			"            *m_cursor++ = c;",
			"        }",
			"        void putS(const char *c) {",
			"            while (*c) putChar(*c++);",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp> & std::is_integral_v<_Tp>> * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            _Tp _ret = _Tp(ret);",
			"            if (_ret >= 0) {",
			"                do {",
			"                    *m_tempBufCursor++ = '0' + _ret % 10;",
			"                    _ret /= 10;",
			"                } while (_ret);",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBuf);",
			"            } else {",
			"                putChar('-');",
			"                do {",
			"                    *m_tempBufCursor++ = '0' - _ret % 10;",
			"                    _ret /= 10;",
			"                } while (_ret);",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBuf);",
			"            }",
			"            return *this;",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp> & std::is_integral_v<_Tp>> * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            _Tp _ret = _Tp(ret);",
			"            do {",
			"                *m_tempBufCursor++ = '0' + _ret % 10;",
			"                _ret /= 10;",
			"            } while (_ret);",
			"            do putChar(*--m_tempBufCursor);",
			"            while (m_tempBufCursor > m_tempBuf);",
			"            return *this;",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_floating_point_v<_Tp>> * = nullptr>",
			"        outputHelper<_BufferSize> &operator<<(const _Tp &ret) {",
			"            if (ret < 0) {",
			"                putChar('-');",
			"                return *this << -ret;",
			"            }",
			"            _Tp _ret = ret * m_floatRatio;",
			"            uint64_t integer = _ret;",
			"            if (_ret - integer >= 0.4999999999) integer++;",
			"            do {",
			"                *m_tempBufCursor++ = '0' + integer % 10;",
			"                integer /= 10;",
			"            } while (integer);",
			"            if (m_tempBufCursor > m_tempBufDot) {",
			"                do putChar(*--m_tempBufCursor);",
			"                while (m_tempBufCursor > m_tempBufDot);",
			"                putChar('.');",
			"            } else {",
			"                putS(\"0.\");",
			"                for (int i = m_tempBufDot - m_tempBufCursor; i--;) putChar('0');",
			"            }",
			"            do putChar(*--m_tempBufCursor);",
			"            while (m_tempBufCursor > m_tempBuf);",
			"            return *this;",
			"        }",
			"        outputHelper<_BufferSize> &operator<<(const char &ret) {",
			"            putChar(ret);",
			"            return *this;",
			"        }",
			"        outputHelper<_BufferSize> &operator<<(const std::string &ret) {",
			"            putS(ret.data());",
			"            return *this;",
			"        }",
			"    };",
			"    template <uint64_t _BufferSize, uint64_t _BlockSize>",
			"    inputHelper<_BufferSize, _BlockSize> &getline(inputHelper<_BufferSize, _BlockSize> &ih, std::string &ret) {",
			"        ret.clear();",
			"        if (ih.getChar_Checked() == EOF)",
			"            ih.setState(false);",
			"        else {",
			"            while (!inputHelper<_BufferSize, _BlockSize>::isEndline(ih.getChar_Checked())) {",
			"                ret += ih.getChar_Unchecked();",
			"                ih.next();",
			"            }",
			"            ih.next();",
			"        }",
			"        return ih;",
			"    }",
			"    template <typename D, typename T, typename... S>",
			"    void printLog(D delim, const T &x, S... rest) {",
			"        cout << x;",
			"        if constexpr (sizeof...(rest) > 0) {",
			"            cout << delim;",
			"            printLog(delim, rest...);",
			"        }",
			"    }",
			"}",
			"using OY::getline;",
        ],
        "description": "fast io"
    },
	"time and memory:windows":{
		"prefix": "TIME",
		"body": [
			"//#include <windows.h>",
			"//#include <psapi.h>",
			"auto GetMicroSecond=[](){static FILETIME ft;GetSystemTimeAsFileTime(&ft);return ft.dwLowDateTime;};auto t1=GetMicroSecond();",
			"auto t2=GetMicroSecond();cout<<\"\\ntime cost=\"<<(t2-t1)/10000.0<<\"ms\\n\";PROCESS_MEMORY_COUNTERS pmc;GetProcessMemoryInfo(GetCurrentProcess(), &pmc, sizeof(pmc));cout<<\"memory cost=\"<<(pmc.WorkingSetSize>>20)<<\"MB\\n\";",
		],
		"description": "time and memory"
	},
	"time and memory:linux":{
		"prefix": "TIME",
		"body": [
			"//#include \"sys/time.h\"",
			"auto GetMicroSecond=[](){static timeval ft;gettimeofday(&ft,nullptr);return ft.tv_sec*1000000+ft.tv_usec;};auto t1=GetMicroSecond();",
			"auto t2=GetMicroSecond();cout<<\"\\ntime cost=\"<<(t2-t1)/1000.0<<\"ms\\n\";{char _mem_buff[512]={0};int used,now_use;fgets(_mem_buff,sizeof(_mem_buff),fopen(\"/proc/self/statm\",\"r\"));sscanf(_mem_buff,\"%d %d\",&used,&now_use);cout<<used/250.0<<\" MB used, \"<<now_use/250.0<<\" MB is now using\\n\";}"
		],
		"description": "time and memory"
	},
	"compare and debug":{
		"prefix": "CAD",
		"body": [
			"namespace compare_debug{",
			"    #ifdef OY_LOCAL",
			"    struct compare_debug_struct{",
			"        ~compare_debug_struct(){",
			"            cin.reset();",
			"            OY::OutHelper mycout(\"out0.txt\");",
			"            $1",
			"        }",
			"    }_compare_debug_struct;",
			"    #endif",
			"}using namespace compare_debug;"
		],
		"description": "compare and debug"
	},

	"accumulator":{
		"prefix": "ACC",
		"body": [
			"namespace OY {",
			"    enum ACCUMULATE_TYPE {",
			"        ACCUMULATE_PREFIX = 1,",
			"        ACCUMULATE_SUFFIX = 2",
			"    };",
			"    template <typename _Tp = int64_t, typename _Operation = std::plus<_Tp>, int _Mask = ACCUMULATE_PREFIX | ACCUMULATE_SUFFIX>",
			"    class Accumulator {",
			"        std::vector<_Tp> m_val;",
			"        std::vector<_Tp> m_prefix;",
			"        std::vector<_Tp> m_suffix;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        void _update(int i, int j) {",
			"            if constexpr (_Mask & ACCUMULATE_PREFIX != 0) {",
			"                m_prefix.resize(i);",
			"                m_prefix.reserve(m_val.size());",
			"                for (; i < m_val.size(); i++) m_prefix.push_back(i ? m_op(m_prefix.back(), m_val[i]) : m_val[i]);",
			"            }",
			"            if constexpr (_Mask & ACCUMULATE_SUFFIX != 0) {",
			"                m_suffix.resize(m_val.size());",
			"                if (j == m_val.size() - 1)",
			"                    std::partial_sum(m_val.rbegin(), m_val.rend(), m_suffix.rbegin(), m_op);",
			"                else",
			"                    for (; j >= 0; j--) m_suffix[j] = m_op(m_suffix[j + 1], m_val[j]);",
			"            }",
			"        }",
			"",
			"    public:",
			"        Accumulator(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        Accumulator(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_val.assign(__n, m_defaultValue);",
			"            _update(0, m_val.size() - 1);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_val.assign(__first, __last);",
			"            _update(0, m_val.size() - 1);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            m_val[__i] = __val;",
			"            _update(__i, __i);",
			"        }",
			"        _Tp queryPrefix(int __i) const {",
			"            static_assert(_Mask & ACCUMULATE_PREFIX != 0);",
			"            return m_prefix[__i];",
			"        }",
			"        _Tp querySuffix(int __i) const {",
			"            static_assert(_Mask & ACCUMULATE_SUFFIX != 0);",
			"            return m_suffix[__i];",
			"        }",
			"        _Tp query(int __i) const { return m_val[__i]; }",
			"        _Tp query(int __left, int __right) const { return std::accumulate(m_val.begin() + __left + 1, m_val.begin() + __right + 1, m_val[__left], m_op); }",
			"        _Tp queryAll() const {",
			"            if constexpr (_Mask & ACCUMULATE_PREFIX != 0)",
			"                return m_prefix.back();",
			"            else if constexpr (_Mask & ACCUMULATE_SUFFIX != 0)",
			"                return m_suffix.front();",
			"            else",
			"                return query(0, m_val.size() - 1);",
			"        }",
			"    };",
			"    template <typename _Tp = int64_t, int _Mask = 3>",
			"    Accumulator(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, const _Tp &(*)(const _Tp &, const _Tp &), _Mask>;",
			"    template <typename _Tp = int64_t, int _Mask = 3>",
			"    Accumulator(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, _Tp (*)(_Tp, _Tp), _Mask>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, int _Mask = 3>",
			"    Accumulator(int = 0, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, _Operation, _Mask>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, int _Mask = 3>",
			"    Accumulator(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, const _Tp &(*)(const _Tp &, const _Tp &), _Mask>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, int _Mask = 3>",
			"    Accumulator(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, _Tp (*)(_Tp, _Tp), _Mask>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>, int _Mask = 3>",
			"    Accumulator(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> Accumulator<_Tp, _Operation, _Mask>;",
			"}",
		],
		"description": "accumulator"
	},
	"avl tree":{
        "prefix": "AVL",
        "body": [
			"namespace OY {",
			"    struct AVLSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct AVLMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct AVLMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _AVLNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _AVLNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = AVLMultisetTag>",
			"    class AVL {",
			"        struct node : _AVLNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            int subtree_height;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int subtree_height(node *p) { return p ? p->subtree_height : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            p->subtree_height = 1 + std::max(subtree_height(p->lchild), subtree_height(p->rchild));",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return update(q);",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return update(q);",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return update(r);",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return update(r);",
			"        }",
			"        static node *balance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (int lh = subtree_height(cur->lchild), rh = subtree_height(cur->rchild); lh > rh + 1) {",
			"                if (subtree_height(cur->lchild->lchild) > rh)",
			"                    return rrotate(cur);",
			"                else",
			"                    return lrrotate(cur);",
			"            } else if (rh > lh + 1) {",
			"                if (subtree_height(cur->rchild->rchild) > lh)",
			"                    return lrotate(cur);",
			"                else",
			"                    return rlrotate(cur);",
			"            } else",
			"                return update(cur);",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else {",
			"                cur->lchild = deleteMin(cur->lchild, res);",
			"                return balance(cur);",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        AVL(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        ~AVL() { clear(); }",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __args..., 1, 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return balance(cur);",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return balance(cur);",
			"                };",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key))",
			"                    cur->lchild = self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    cur->rchild = self(self, cur->rchild);",
			"                else {",
			"                    delete cur;",
			"                    if (!cur->rchild)",
			"                        return cur->lchild;",
			"                    else {",
			"                        node *res;",
			"                        cur->rchild = deleteMin(cur->rchild, res);",
			"                        res->lchild = cur->lchild;",
			"                        res->rchild = cur->rchild;",
			"                        cur = res;",
			"                    }",
			"                }",
			"                return balance(cur);",
			"            };",
			"            int old_weight = size();",
			"            m_root = dfs(dfs, m_root);",
			"            return old_weight != size();",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace AVLContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = AVL<_Tp, bool, _Compare, AVLSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = AVL<_Tp, bool, _Compare, AVLMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = AVL<_Tp, _Fp, _Compare, AVLMapTag>;",
			"    }",
			"}",
        ],
        "description": "avl tree"
    },
	"binary indexed tree":{
        "prefix": "BIT",
        "body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    class BIT {",
			"        std::vector<_Tp> m_sum;",
			"        _Tp m_defaultValue;",
			"        _Plus m_plus;",
			"        _Minus m_minus;",
			"        int m_length;",
			"",
			"    public:",
			"        BIT(int __n = 0, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) { resize(__n); }",
			"        template <typename _Iterator>",
			"        BIT(_Iterator __first, _Iterator __last, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) { reset(__first, __last); }",
			"        void resize(int __n) {",
			"            m_length = __n > 1 ? 1 << (32 - std::__countl_zero(__n - 1)) : 1;",
			"            m_sum.assign(m_length, m_defaultValue);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = (__last - __first) > 1 ? 1 << (32 - std::__countl_zero((__last - __first) - 1)) : 1;",
			"            m_sum.resize(m_length);",
			"            std::copy(__first, __last, m_sum.begin());",
			"            std::fill(m_sum.begin() + (__last - __first), m_sum.end(), m_defaultValue);",
			"            for (int i = 0; i < m_length; i++)",
			"                if (int j = i + (1 << std::__countr_zero(i + 1)); j < m_length) m_sum[j] = m_plus(m_sum[j], m_sum[i]);",
			"        }",
			"        void add(int i, _Tp __inc) {",
			"            while (i < m_length) {",
			"                m_sum[i] = m_plus(m_sum[i], __inc);",
			"                i += 1 << std::__countr_zero(i + 1);",
			"            }",
			"        }",
			"        _Tp presum(int i) const {",
			"            _Tp ret = m_defaultValue;",
			"            while (i >= 0) {",
			"                ret = m_plus(ret, m_sum[i]);",
			"                i -= 1 << std::__countr_zero(i + 1);",
			"            }",
			"            return ret;",
			"        }",
			"        _Tp query(int i) const { return m_minus(presum(i), presum(i - 1)); }",
			"        _Tp query(int __left, int __right) const { return m_minus(presum(__right), presum(__left - 1)); }",
			"        _Tp queryAll() const { return presum(m_length - 1); }",
			"        int kth(_Tp __k) const {",
			"            int cursor = -1;",
			"            for (int d = m_length / 2; d; d >>= 1)",
			"                if (m_sum[cursor + d] <= __k) __k -= m_sum[cursor += d];",
			"            return cursor + 1;",
			"        }",
			"    };",
			"    template <typename _Tp = int, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT(int, _Plus = _Plus(), _Minus = _Minus(), _Tp = _Tp()) -> BIT<_Tp, _Plus, _Minus>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT(_Iterator, _Iterator, _Plus = _Plus(), _Minus = _Minus(), _Tp = _Tp()) -> BIT<_Tp, _Plus, _Minus>;",
			"",
			"    template <typename _Tp = int64_t>",
			"    class BIT_ex {",
			"        struct _TpArray {",
			"            _Tp val[2];",
			"            _TpArray(_Tp __val = _Tp(0)) {",
			"                val[0] = __val;",
			"                val[1] = 0;",
			"            }",
			"            _TpArray(_Tp __val0, _Tp __val1) {",
			"                val[0] = __val0;",
			"                val[1] = __val1;",
			"            }",
			"            _TpArray &operator+=(const _TpArray &other) {",
			"                val[0] += other.val[0];",
			"                val[1] += other.val[1];",
			"                return *this;",
			"            }",
			"        };",
			"        std::vector<_TpArray> m_sum;",
			"        int m_length;",
			"        void _add(int i, _Tp __inc) {",
			"            _TpArray inc(__inc, __inc * i);",
			"            while (i < m_length) {",
			"                m_sum[i] += inc;",
			"                i += 1 << std::__countr_zero(i + 1);",
			"            }",
			"        }",
			"",
			"    public:",
			"        BIT_ex(int __n) { resize(__n); }",
			"        template <typename _Iterator>",
			"        BIT_ex(_Iterator __first, _Iterator __last) { reset(__first, __last); }",
			"        void resize(int __n) {",
			"            m_length = __n > 1 ? 1 << (32 - std::__countl_zero(__n - 1)) : 1;",
			"            m_sum.assign(m_length, _Tp(0));",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = (__last - __first) > 1 ? 1 << (32 - std::__countl_zero((__last - __first) - 1)) : 1;",
			"            m_sum.resize(m_length);",
			"            std::adjacent_difference(__first, __last, m_sum.begin());",
			"            std::fill(m_sum.begin() + (__last - __first), m_sum.end(), _Tp(0));",
			"            for (int i = 0; i < m_length; i++) m_sum[i].val[1] = m_sum[i].val[0] * i;",
			"            for (int i = 0; i < m_length; i++)",
			"                if (int j = i + (1 << std::__countr_zero(i + 1)); j < m_length) m_sum[j] += m_sum[i];",
			"        }",
			"        void add(int i, _Tp __inc) {",
			"            _add(i, __inc);",
			"            _add(i + 1, -__inc);",
			"        }",
			"        void add(int __left, int __right, _Tp __inc) {",
			"            _add(__left, __inc);",
			"            _add(__right + 1, -__inc);",
			"        }",
			"        _Tp presum(int i) {",
			"            _TpArray ret;",
			"            for (int j = i; j >= 0; j -= 1 << std::__countr_zero(j + 1)) ret += m_sum[j];",
			"            return ret.val[0] * (i + 1) - ret.val[1];",
			"        }",
			"        _Tp query(int i) {",
			"            _Tp ret(0);",
			"            for (int j = i; j >= 0; j -= 1 << std::__countr_zero(j + 1)) ret += m_sum[j].val[0];",
			"            return ret;",
			"        }",
			"        _Tp query(int __left, int __right) { return presum(__right) - presum(__left - 1); }",
			"        _Tp queryAll() { return presum(m_length - 1); }",
			"        int kth(_Tp __k) {",
			"            int cursor = -1;",
			"            _TpArray cur;",
			"            for (int d = m_length / 2; d; d >>= 1)",
			"                if ((cur.val[0] + m_sum[cursor + d].val[0]) * (cursor + d + 1) - (cur.val[1] + m_sum[cursor + d].val[1]) <= __k) cur += m_sum[cursor += d];",
			"            return cursor + 1;",
			"        }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    BIT_ex(int) -> BIT_ex<_Tp>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    BIT_ex(_Iterator, _Iterator) -> BIT_ex<_Tp>;",
			"}",
        ],
        "description": "binary indexed tree"
    },
	"binary indexed tree 2d":{
		"prefix": "BIT2D",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    class BIT2d {",
			"        std::vector<std::vector<_Tp>> m_sum;",
			"        _Tp m_defaultValue;",
			"        _Plus m_plus;",
			"        _Minus m_minus;",
			"        int m_row;",
			"        int m_column;",
			"",
			"    public:",
			"        BIT2d(int __row, int __column, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) {",
			"            resize(__row, __column);",
			"        }",
			"        template <typename Ref>",
			"        BIT2d(Ref __ref, int __row, int __column, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) {",
			"            reset(__ref, __row, __column);",
			"        }",
			"        void resize(int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_sum.assign(m_row, std::vector<_Tp>(m_column, m_defaultValue));",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_sum.resize(m_row);",
			"            for (int i = 0; i < m_row; i++) {",
			"                if constexpr (std::is_invocable_v<Ref, int>)",
			"                    m_sum[i].assign(__ref(i), __ref(i) + m_column);",
			"                else {",
			"                    m_sum[i].clear();",
			"                    m_sum[i].reserve(m_column);",
			"                    for (int j = 0; j < m_column; j++) m_sum[i].push_back(__ref(i, j));",
			"                }",
			"            }",
			"            for (int j = 0; j < m_column; j++)",
			"                if (int k = j + (1 << std::__countr_zero(j + 1)); k < m_column)",
			"                    for (int i = 0; i < m_row; i++) m_sum[i][k] = m_plus(m_sum[i][k], m_sum[i][j]);",
			"            for (int i = 0; i < m_row; i++)",
			"                if (int k = i + (1 << std::__countr_zero(i + 1)); k < m_row)",
			"                    for (int j = 0; j < m_column; j++) m_sum[k][j] = m_plus(m_sum[k][j], m_sum[i][j]);",
			"        }",
			"        void add(int i, int j, _Tp __inc) {",
			"            for (int r = i; r < m_row; r += 1 << std::__countr_zero(r + 1))",
			"                for (int c = j; c < m_column; c += 1 << std::__countr_zero(c + 1))",
			"                    m_sum[r][c] = m_plus(m_sum[r][c], __inc);",
			"        }",
			"        _Tp presum(int i, int j) const {",
			"            _Tp ret = m_defaultValue;",
			"            for (int r = i; r >= 0; r -= 1 << std::__countr_zero(r + 1))",
			"                for (int c = j; c >= 0; c -= 1 << std::__countr_zero(c + 1))",
			"                    ret = m_plus(ret, m_sum[r][c]);",
			"            return ret;",
			"        }",
			"        _Tp query(int i, int j) const { return m_minus(m_plus(presum(i, j), presum(i - 1, j - 1)), m_plus(presum(i, j - 1), presum(i - 1, j))); }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const { return m_minus(m_plus(presum(__row2, __column2), presum(__row1 - 1, __column1 - 1)), m_plus(presum(__row1 - 1, __column2), presum(__row2, __column1 - 1))); }",
			"        _Tp queryAll() const { return presum(m_row - 1, m_column - 1); }",
			"    };",
			"    template <typename _Tp = int, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT2d(int, int, _Plus = _Plus(), _Minus = _Minus(), _Tp = _Tp()) -> BIT2d<_Tp, _Plus, _Minus>;",
			"    template <typename Ref, typename _Tp = typename std::iterator_traits<typename decltype(std::mem_fn(&Ref::operator()))::result_type>::value_type, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT2d(Ref, int, int, _Plus = _Plus(), _Minus = _Minus(), std::enable_if_t<std::is_invocable_v<Ref, int>, _Tp> = _Tp()) -> BIT2d<_Tp, _Plus, _Minus>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    BIT2d(Ref, int, int, _Plus = _Plus(), _Minus = _Minus(), std::enable_if_t<std::is_invocable_v<Ref, int, int>, _Tp> = _Tp()) -> BIT2d<_Tp, _Plus, _Minus>;",
			"",
			"    template <typename _Tp = int64_t>",
			"    class BIT2d_ex {",
			"        struct _TpArray {",
			"            _Tp val[4];",
			"            _TpArray() { val[0] = val[1] = val[2] = val[3] = 0; }",
			"            _TpArray(_Tp __val0, _Tp __val1, _Tp __val2, _Tp __val3) {",
			"                val[0] = __val0;",
			"                val[1] = __val1;",
			"                val[2] = __val2;",
			"                val[3] = __val3;",
			"            }",
			"            _TpArray &operator+=(const _TpArray &other) {",
			"                val[0] += other.val[0];",
			"                val[1] += other.val[1];",
			"                val[2] += other.val[2];",
			"                val[3] += other.val[3];",
			"                return *this;",
			"            }",
			"        };",
			"        std::vector<std::vector<_TpArray>> m_sum;",
			"        int m_row;",
			"        int m_column;",
			"        void _add(int i, int j, _Tp __inc) {",
			"            _TpArray inc(__inc, __inc * i, __inc * j, __inc * i * j);",
			"            for (int r = i; r < m_row; r += 1 << std::__countr_zero(r + 1))",
			"                for (int c = j; c < m_column; c += 1 << std::__countr_zero(c + 1))",
			"                    m_sum[r][c] += inc;",
			"        }",
			"",
			"    public:",
			"        BIT2d_ex(int __row, int __column) { resize(__row, __column); }",
			"        template <typename Ref>",
			"        BIT2d_ex(Ref __ref, int __row, int __column) { reset(__ref, __row, __column); }",
			"        void resize(int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_sum.assign(m_row, std::vector<_TpArray>(m_column));",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_sum.resize(m_row);",
			"            for (int i = 0; i < m_row; i++) {",
			"                m_sum[i].clear();",
			"                m_sum[i].reserve(m_column);",
			"                for (int j = 0; j < m_column; j++) {",
			"                    _Tp value;",
			"                    if (i && j)",
			"                        value = __ref(i, j) + __ref(i - 1, j - 1) - __ref(i, j - 1) - __ref(i - 1, j);",
			"                    else if (i)",
			"                        value = __ref(i, j) - __ref(i - 1, j);",
			"                    else if (j)",
			"                        value = __ref(i, j) - __ref(i, j - 1);",
			"                    else",
			"                        value = __ref(i, j);",
			"                    m_sum[i].emplace_back(value, value * i, value * j, value * i * j);",
			"                }",
			"            }",
			"            for (int j = 0; j < m_column; j++)",
			"                if (int k = j + (1 << std::__countr_zero(j + 1)); k < m_column)",
			"                    for (int i = 0; i < m_row; i++) m_sum[i][k] += m_sum[i][j];",
			"            for (int i = 0; i < m_row; i++)",
			"                if (int k = i + (1 << std::__countr_zero(i + 1)); k < m_row)",
			"                    for (int j = 0; j < m_column; j++) m_sum[k][j] += m_sum[i][j];",
			"        }",
			"        void add(int i, int j, _Tp __inc) {",
			"            _add(i, j, __inc);",
			"            _add(i, j + 1, -__inc);",
			"            _add(i + 1, j, -__inc);",
			"            _add(i + 1, j + 1, __inc);",
			"        }",
			"        void add(int __row1, int __row2, int __column1, int __column2, _Tp __inc) {",
			"            _add(__row1, __column1, __inc);",
			"            _add(__row1, __column2 + 1, -__inc);",
			"            _add(__row2 + 1, __column1, -__inc);",
			"            _add(__row2 + 1, __column2 + 1, __inc);",
			"        }",
			"        _Tp presum(int i, int j) const {",
			"            _TpArray ret;",
			"            for (int r = i; r >= 0; r -= 1 << std::__countr_zero(r + 1))",
			"                for (int c = j; c >= 0; c -= 1 << std::__countr_zero(c + 1))",
			"                    ret += m_sum[r][c];",
			"            return ret.val[0] * (i + 1) * (j + 1) - ret.val[1] * (j + 1) - ret.val[2] * (i + 1) + ret.val[3];",
			"        }",
			"        _Tp query(int i, int j) const {",
			"            _Tp ret = 0;",
			"            for (int r = i; r >= 0; r -= 1 << std::__countr_zero(r + 1))",
			"                for (int c = j; c >= 0; c -= 1 << std::__countr_zero(c + 1))",
			"                    ret += m_sum[r][c].val[0];",
			"            return ret;",
			"        }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const { return presum(__row2, __column2) + presum(__row1 - 1, __column1 - 1) - presum(__row2, __column1 - 1) - presum(__row1 - 1, __column2); }",
			"        _Tp queryAll() const { return presum(m_row - 1, m_column - 1); }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    BIT2d_ex(int, int) -> BIT2d_ex<_Tp>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>>",
			"    BIT2d_ex(Ref, int, int) -> BIT2d_ex<_Tp>;",
			"}",
		],
		"description": "binary indexed tree 2d"
	},
	"Bitset":{
		"prefix": "BITSET",
		"body": [
			"namespace OY {",
			"    enum _BITBLOCK_STATE {",
			"        BITSET_DEFAULT = 0,",
			"        BITSET_FLIPPED = 1,",
			"        BITSET_ZERO = 2,",
			"        BITSET_ONE = 3",
			"    };",
			"    template <int _Depth = 6>",
			"    struct _BitBlock {",
			"        mutable uint64_t m_mask[1 << _Depth];",
			"        mutable _BITBLOCK_STATE m_state;",
			"        int m_sum;",
			"        void set_inside(int i, int l, int r) {",
			"            uint64_t old = m_mask[i];",
			"            m_mask[i] |= r < 63 ? (1ull << r + 1) - (1ull << l) : -(1ull << l);",
			"            m_sum += std::__popcount(m_mask[i] ^ old);",
			"        }",
			"        void reset_inside(int i, int l, int r) {",
			"            uint64_t old = m_mask[i];",
			"            m_mask[i] &= r < 63 ? ~((1ull << r + 1) - (1ull << l)) : -(1ull << l);",
			"            m_sum -= std::__popcount(m_mask[i] ^ old);",
			"        }",
			"        void flip_inside(int i, int l, int r) {",
			"            uint64_t old = m_mask[i];",
			"            m_mask[i] = (m_mask[i] & (r < 63 ? (1ull << l) - (1ull << r + 1) - 1 : (1ull << l) - 1)) ^ (~m_mask[i] & (r < 63 ? (1ull << r + 1) - (1ull << l) : -(1ull << l)));",
			"            m_sum += std::__popcount(m_mask[i]) - std::__popcount(old);",
			"        }",
			"        int count_inside(int i, int l, int r) const { return std::__popcount(m_mask[i] & (r < 63 ? (1ull << r + 1) - (1ull << l) : -(1ull << l))); }",
			"        void push_down() const {",
			"            if (m_state == BITSET_DEFAULT) return;",
			"            if (m_state == BITSET_FLIPPED) {",
			"                m_state = BITSET_DEFAULT;",
			"                for (auto &a : m_mask) a = ~a;",
			"            } else if (m_state == BITSET_ZERO) {",
			"                m_state = BITSET_DEFAULT;",
			"                memset(m_mask, 0, sizeof(m_mask));",
			"            } else {",
			"                m_state = BITSET_DEFAULT;",
			"                memset(m_mask, -1, sizeof(m_mask));",
			"            }",
			"        }",
			"        void update_sum() {",
			"            m_sum = 0;",
			"            for (auto &a : m_mask) m_sum += std::__popcount(a);",
			"        }",
			"        _BitBlock() : m_mask{0}, m_state(BITSET_DEFAULT), m_sum(0) {}",
			"        int set() {",
			"            m_state = BITSET_ONE;",
			"            int old = m_sum;",
			"            m_sum = 1 << _Depth + 6;",
			"            return m_sum - old;",
			"        }",
			"        int set(int __i) {",
			"            if (m_state == BITSET_ONE) return 0;",
			"            if (m_state == BITSET_DEFAULT) {",
			"                if (m_mask[__i >> 6] >> (__i & 63) & 1) return 0;",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                if (!(m_mask[__i >> 6] >> (__i & 63) & 1)) return 0;",
			"            } else {",
			"                m_state = BITSET_DEFAULT;",
			"                memset(m_mask, 0, sizeof(m_mask));",
			"            }",
			"            m_mask[__i >> 6] ^= 1ll << (__i & 63);",
			"            m_sum++;",
			"            return 1;",
			"        }",
			"        int set(int __left, int __right) {",
			"            if (m_state == BITSET_ONE) return 0;",
			"            int old = m_sum;",
			"            push_down();",
			"            if (int l = __left >> 6, r = __right >> 6; l == r)",
			"                set_inside(l, __left & 63, __right & 63);",
			"            else {",
			"                set_inside(l, __left & 63, 63);",
			"                for (int i = l + 1; i < r; i++) {",
			"                    uint64_t old = m_mask[i];",
			"                    m_mask[i] = -1ull;",
			"                    m_sum += std::__popcount(m_mask[i] ^ old);",
			"                }",
			"                set_inside(r, 0, __right & 63);",
			"            }",
			"            return m_sum - old;",
			"        }",
			"        int reset() {",
			"            m_state = BITSET_ZERO;",
			"            int old = m_sum;",
			"            m_sum = 0;",
			"            return -old;",
			"        }",
			"        int reset(int __i) {",
			"            if (m_state == BITSET_ZERO) return 0;",
			"            if (m_state == BITSET_DEFAULT) {",
			"                if (!(m_mask[__i >> 6] >> (__i & 63) & 1)) return 0;",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                if (m_mask[__i >> 6] >> (__i & 63) & 1) return 0;",
			"            } else {",
			"                m_state = BITSET_DEFAULT;",
			"                memset(m_mask, -1, sizeof(m_mask));",
			"            }",
			"            m_mask[__i >> 6] ^= 1ll << (__i & 63);",
			"            m_sum--;",
			"            return -1;",
			"        }",
			"        int reset(int __left, int __right) {",
			"            if (m_state == BITSET_ZERO) return 0;",
			"            int old = m_sum;",
			"            push_down();",
			"            if (int l = __left >> 6, r = __right >> 6; l == r)",
			"                reset_inside(l, __left & 63, __right & 63);",
			"            else {",
			"                reset_inside(l, __left & 63, 63);",
			"                for (int i = l + 1; i < r; i++) {",
			"                    m_sum -= std::__popcount(m_mask[i]);",
			"                    m_mask[i] = 0;",
			"                }",
			"                reset_inside(r, 0, __right & 63);",
			"            }",
			"            return m_sum - old;",
			"        }",
			"        int flip() {",
			"            if (m_state == BITSET_DEFAULT)",
			"                m_state = BITSET_FLIPPED;",
			"            else if (m_state == BITSET_FLIPPED)",
			"                m_state = BITSET_DEFAULT;",
			"            else if (m_state == BITSET_ONE)",
			"                m_state = BITSET_ZERO;",
			"            else",
			"                m_state = BITSET_ONE;",
			"            m_sum = (1 << _Depth + 6) - m_sum;",
			"            return m_sum * 2 - (1 << _Depth + 6);",
			"        }",
			"        int flip(int __i) {",
			"            bool add;",
			"            if (m_state == BITSET_FLIPPED) {",
			"                m_mask[__i >> 6] ^= 1ll << (__i & 63);",
			"                add = !(m_mask[__i >> 6] >> (__i & 63) & 1);",
			"            } else {",
			"                if (m_state != BITSET_DEFAULT) push_down();",
			"                m_mask[__i >> 6] ^= 1ll << (__i & 63);",
			"                add = m_mask[__i >> 6] >> (__i & 63) & 1;",
			"            }",
			"            if (add) {",
			"                m_sum++;",
			"                return 1;",
			"            } else {",
			"                m_sum--;",
			"                return -1;",
			"            }",
			"        }",
			"        int flip(int __left, int __right) {",
			"            int old = m_sum;",
			"            push_down();",
			"            if (int l = __left >> 6, r = __right >> 6; l == r)",
			"                flip_inside(l, __left & 63, __right & 63);",
			"            else {",
			"                flip_inside(l, __left & 63, 63);",
			"                for (int i = l + 1; i < r; i++) {",
			"                    m_sum += 64 - std::__popcount(m_mask[i]) * 2;",
			"                    m_mask[i] = ~m_mask[i];",
			"                }",
			"                flip_inside(r, 0, __right & 63);",
			"            }",
			"            return m_sum - old;",
			"        }",
			"        int first() const {",
			"            if (!m_sum) return -1;",
			"            if (m_state == BITSET_DEFAULT) {",
			"                int i = 0;",
			"                while (!m_mask[i]) i++;",
			"                return (i << 6) + std::__countr_zero(m_mask[i]);",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                int i = 0;",
			"                while (!~m_mask[i]) i++;",
			"                return (i << 6) + std::__countr_zero(~m_mask[i]);",
			"            } else",
			"                return 0;",
			"        }",
			"        int prev(int __i) const {",
			"            if (m_state == BITSET_DEFAULT) {",
			"                int i = __i >> _Depth;",
			"                if (auto a = m_mask[i] & (1ull << (__i & 63)) - 1) return (i << 6) + 63 - std::__countl_zero(a);",
			"                while (~--i && !m_mask[i])",
			"                    ;",
			"                return ~i ? (i << 6) + 63 - std::__countl_zero(m_mask[i]) : -1;",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                int i = __i >> _Depth;",
			"                if (auto a = ~m_mask[i] & (1ull << (__i & 63)) - 1) return (i << 6) + 63 - std::__countl_zero(a);",
			"                while (~--i && !~m_mask[i])",
			"                    ;",
			"                return ~i ? (i << 6) + 63 - std::__countl_zero(~m_mask[i]) : -1;",
			"            } else if (m_state == BITSET_ONE)",
			"                return __i - 1;",
			"            else",
			"                return -1;",
			"        }",
			"        int next(int __i) const {",
			"            if (m_state == BITSET_DEFAULT) {",
			"                int i = __i >> _Depth;",
			"                if ((__i & 63) < 63) {",
			"                    if (auto a = m_mask[i] & -1ull << (__i & 63) + 1) return (i << 6) + std::__countr_zero(a);",
			"                }",
			"                while (++i < 1 << _Depth && !m_mask[i])",
			"                    ;",
			"                return i < 1 << _Depth ? (i << 6) + std::__countr_zero(m_mask[i]) : -1;",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                int i = __i >> _Depth;",
			"                if ((__i & 63) < 63)",
			"                    if (auto a = ~m_mask[i] & -1ull << (__i & 63) + 1) return (i << 6) + std::__countr_zero(a);",
			"                while (++i < 1 << _Depth && !~m_mask[i])",
			"                    ;",
			"                return i < 1 << _Depth ? (i << 6) + std::__countr_zero(~m_mask[i]) : -1;",
			"            } else if (m_state == BITSET_ONE)",
			"                return __i < 1 << _Depth + 6 ? __i + 1 : -1;",
			"            else",
			"                return -1;",
			"        }",
			"        int last() const {",
			"            if (!m_sum) return -1;",
			"            if (m_state == BITSET_DEFAULT) {",
			"                int i = (1 << _Depth) - 1;",
			"                while (!m_mask[i]) i--;",
			"                return (i << 6) + 63 - std::__countl_zero(m_mask[i]);",
			"            } else if (m_state == BITSET_FLIPPED) {",
			"                int i = (1 << _Depth) - 1;",
			"                while (!~m_mask[i]) i--;",
			"                return (i << 6) + 63 - std::__countl_zero(~m_mask[i]);",
			"            } else",
			"                return (1 << _Depth + 6) - 1;",
			"        }",
			"        int count() const { return m_sum; }",
			"        int count(int __left, int __right) const {",
			"            if (m_state == BITSET_ZERO)",
			"                return 0;",
			"            else if (m_state == BITSET_ONE)",
			"                return __right - __left + 1;",
			"            else {",
			"                int l = __left >> 6, r = __right >> 6, sum = 0;",
			"                if (l == r)",
			"                    sum = count_inside(l, __left & 63, __right & 63);",
			"                else {",
			"                    sum = count_inside(l, __left & 63, 63);",
			"                    for (int i = l + 1; i < r; i++) sum += std::__popcount(m_mask[i]);",
			"                    sum += count_inside(r, 0, __right & 63);",
			"                }",
			"                return m_state == BITSET_DEFAULT ? sum : __right - __left + 1 - sum;",
			"            }",
			"        }",
			"        bool at(int __i) const {",
			"            if (m_state == BITSET_DEFAULT)",
			"                return m_mask[__i >> 6] >> (__i & 63) & 1;",
			"            else if (m_state == BITSET_FLIPPED)",
			"                return !(m_mask[__i >> 6] >> (__i & 63) & 1);",
			"            else",
			"                return m_state == BITSET_ONE;",
			"        }",
			"        bool operator[](int __i) const { return at(__i); }",
			"        bool all() const { return m_sum == 1 << _Depth + 6; }",
			"        bool any() const { return m_sum; }",
			"        _BitBlock<_Depth> &operator&=(const _BitBlock<_Depth> &other) {",
			"            push_down();",
			"            other.push_down();",
			"            for (int i = 0; i < 1 << _Depth; i++) m_mask[i] &= other.m_mask[i];",
			"            update_sum();",
			"            return *this;",
			"        }",
			"        _BitBlock<_Depth> &operator|=(const _BitBlock<_Depth> &other) {",
			"            push_down();",
			"            other.push_down();",
			"            for (int i = 0; i < 1 << _Depth; i++) m_mask[i] |= other.m_mask[i];",
			"            update_sum();",
			"            return *this;",
			"        }",
			"        _BitBlock<_Depth> &operator^=(const _BitBlock<_Depth> &other) {",
			"            push_down();",
			"            other.push_down();",
			"            for (int i = 0; i < 1 << _Depth; i++) m_mask[i] ^= other.m_mask[i];",
			"            update_sum();",
			"            return *this;",
			"        }",
			"        friend _BitBlock<_Depth> operator&(const _BitBlock<_Depth> &a, const _BitBlock<_Depth> &b) {",
			"            _BitBlock<_Depth> res(a);",
			"            a &= b;",
			"            return a;",
			"        }",
			"        friend _BitBlock<_Depth> operator|(const _BitBlock<_Depth> &a, const _BitBlock<_Depth> &b) {",
			"            _BitBlock<_Depth> res(a);",
			"            a |= b;",
			"            return a;",
			"        }",
			"        friend _BitBlock<_Depth> operator^(const _BitBlock<_Depth> &a, const _BitBlock<_Depth> &b) {",
			"            _BitBlock<_Depth> res(a);",
			"            a ^= b;",
			"            return a;",
			"        }",
			"    };",
			"    template <int _Depth = 6>",
			"    class Bitset {",
			"        std::vector<_BitBlock<_Depth>> m_sub;",
			"        int m_length;",
			"        int m_sum;",
			"        void updateSum() {",
			"            m_sum = 0;",
			"            for (auto &sub : m_sub) m_sum += sub.m_sum;",
			"        }",
			"",
			"    public:",
			"        Bitset(int __n = 0) { resize(__n); }",
			"        void resize(int __n) {",
			"            if (!(m_length = __n)) return;",
			"            m_sub.clear();",
			"            m_sub.resize((__n - 1 >> _Depth + 6) + 1);",
			"            m_sum = 0;",
			"        }",
			"        void set() {",
			"            for (int i = 0; i < m_sub.size() - 1; i++) m_sub[i].set();",
			"            m_sub.back().set(0, m_length - 1 & (1 << _Depth + 6) - 1);",
			"            m_sum = m_length;",
			"        }",
			"        void set(int __i) { m_sum += m_sub[__i >> _Depth + 6].set(__i & (1 << _Depth + 6) - 1); }",
			"        void set(int __left, int __right) {",
			"            int l = __left >> _Depth + 6, r = __right >> _Depth + 6;",
			"            if (l == r)",
			"                m_sum += m_sub[l].set(__left & (1 << _Depth + 6) - 1, __right & (1 << _Depth + 6) - 1);",
			"            else {",
			"                m_sum += m_sub[l].set(__left & (1 << _Depth + 6) - 1, (1 << _Depth + 6) - 1);",
			"                for (int i = l + 1; i < r; i++) m_sum += m_sub[i].set();",
			"                m_sum += m_sub[r].set(0, __right & (1 << _Depth + 6) - 1);",
			"            }",
			"        }",
			"        void reset() {",
			"            for (auto &sub : m_sub) sub.reset();",
			"            m_sum = 0;",
			"        }",
			"        void reset(int __i) { m_sum += m_sub[__i >> _Depth + 6].reset(__i & (1 << _Depth + 6) - 1); }",
			"        void reset(int __left, int __right) {",
			"            int l = __left >> _Depth + 6, r = __right >> _Depth + 6;",
			"            if (l == r)",
			"                m_sum += m_sub[l].reset(__left & (1 << _Depth + 6) - 1, __right & (1 << _Depth + 6) - 1);",
			"            else {",
			"                m_sum += m_sub[l].reset(__left & (1 << _Depth + 6) - 1, (1 << _Depth + 6) - 1);",
			"                for (int i = l + 1; i < r; i++) m_sum += m_sub[i].reset();",
			"                m_sum += m_sub[r].reset(0, __right & (1 << _Depth + 6) - 1);",
			"            }",
			"        }",
			"        void flip() {",
			"            for (int i = 0; i < m_sub.size() - 1; i++) m_sub[i].flip();",
			"            m_sub.back().flip(0, (m_length - 1) & (1 << _Depth + 6) - 1);",
			"            m_sum = m_length - m_sum;",
			"        }",
			"        void flip(int __i) { m_sum += m_sub[__i >> _Depth + 6].flip(__i & (1 << _Depth + 6) - 1); }",
			"        void flip(int __left, int __right) {",
			"            int l = __left >> _Depth + 6, r = __right >> _Depth + 6;",
			"            if (l == r)",
			"                m_sum += m_sub[l].flip(__left & (1 << _Depth + 6) - 1, __right & (1 << _Depth + 6) - 1);",
			"            else {",
			"                m_sum += m_sub[l].flip(__left & (1 << _Depth + 6) - 1, (1 << _Depth + 6) - 1);",
			"                for (int i = l + 1; i < r; i++) m_sum += m_sub[i].flip();",
			"                m_sum += m_sub[r].flip(0, __right & (1 << _Depth + 6) - 1);",
			"            }",
			"        }",
			"        int first() const {",
			"            if (!m_sum) return -1;",
			"            int i = 0;",
			"            while (!m_sub[i].any()) i++;",
			"            return (i << _Depth + 6) + m_sub[i].first();",
			"        }",
			"        int prev(int __i) const {",
			"            int i = __i >> _Depth + 6;",
			"            if (int j = m_sub[i].prev(__i & (1 << _Depth + 6) - 1); ~j) return (i << _Depth + 6) + j;",
			"            while (~--i && !m_sub[i].any())",
			"                ;",
			"            return ~i ? (i << _Depth + 6) + m_sub[i].last() : -1;",
			"        }",
			"        int next(int __i) const {",
			"            int i = __i >> _Depth + 6;",
			"            if (int j = m_sub[i].next(__i & (1 << _Depth + 6) - 1); ~j) return (i << _Depth + 6) + j;",
			"            while (++i < m_sub.size() && !m_sub[i].any())",
			"                ;",
			"            return i < m_sub.size() ? (i << _Depth + 6) + m_sub[i].first() : -1;",
			"        }",
			"        int last() const {",
			"            if (!m_sum) return -1;",
			"            int i = m_sub.size() - 1;",
			"            while (!m_sub[i].any()) i--;",
			"            return (i << _Depth + 6) + m_sub[i].last();",
			"        }",
			"        int count() const { return m_sum; }",
			"        int count(int __left, int __right) const {",
			"            int l = __left >> _Depth + 6, r = __right >> _Depth + 6;",
			"            if (l == r)",
			"                return m_sub[l].count(__left & (1 << _Depth + 6) - 1, __right & (1 << _Depth + 6) - 1);",
			"            else {",
			"                int sum = m_sub[l].count(__left & (1 << _Depth + 6) - 1, (1 << _Depth + 6) - 1);",
			"                for (int i = l + 1; i < r; i++) sum += m_sub[i].count();",
			"                return sum + m_sub[r].count(0, __right & (1 << _Depth + 6) - 1);",
			"            }",
			"        }",
			"        bool at(int __i) const { return m_sub[__i >> _Depth + 6].at(__i & (1 << _Depth + 6) - 1); }",
			"        bool operator[](int __i) const { return at(__i); }",
			"        bool all() const { return count() == m_length; }",
			"        bool any() const { return count(); }",
			"        Bitset<_Depth> &operator&=(const Bitset<_Depth> &other) {",
			"            assert(m_length == other.m_length);",
			"            for (int i = 0; i < m_sub.size(); i++) m_sub[i] &= other.m_sub[i];",
			"            updateSum();",
			"            return *this;",
			"        };",
			"        Bitset<_Depth> &operator|=(const Bitset<_Depth> &other) {",
			"            assert(m_length == other.m_length);",
			"            for (int i = 0; i < m_sub.size(); i++) m_sub[i] |= other.m_sub[i];",
			"            updateSum();",
			"            return *this;",
			"        };",
			"        Bitset<_Depth> &operator^=(const Bitset<_Depth> &other) {",
			"            assert(m_length == other.m_length);",
			"            for (int i = 0; i < m_sub.size(); i++) m_sub[i] ^= other.m_sub[i];",
			"            updateSum();",
			"            return *this;",
			"        };",
			"        friend Bitset<_Depth> operator&(const Bitset<_Depth> &a, const Bitset<_Depth> &b) {",
			"            Bitset<_Depth> res(a);",
			"            res &= b;",
			"            return res;",
			"        }",
			"        friend Bitset<_Depth> operator|(const Bitset<_Depth> &a, const Bitset<_Depth> &b) {",
			"            Bitset<_Depth> res(a);",
			"            res |= b;",
			"            return res;",
			"        }",
			"        friend Bitset<_Depth> operator^(const Bitset<_Depth> &a, const Bitset<_Depth> &b) {",
			"            Bitset<_Depth> res(a);",
			"            res ^= b;",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Bitset"
	},
	"B tree":{
		"prefix": "BT",
		"body": [
			"",
			"namespace OY {",
			"    struct BTreeSetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    struct BTreeMultisetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = true;",
			"    };",
			"    struct BTreeMapTag {",
			"        static constexpr bool is_map = true;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _BTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _BTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = int, typename _Compare = std::less<_Tp>, typename _Tag = BTreeMultisetTag, int _K = 3>",
			"    class BTree {",
			"        using node = _BTreeNode<_Tp, _Fp, _Tag::is_map>;",
			"        struct block : MemoryPool<block> {",
			"            node keys[_K * 2 - 1];",
			"            int keyNum;",
			"            node min;",
			"            node max;",
			"            int weight;",
			"            block *child[_K * 2];",
			"            block() { child[0] = nullptr; }",
			"            void push_front(node key, block *p) {",
			"                std::copy_backward(keys, keys + keyNum, keys + keyNum + 1);",
			"                if (child[0]) std::copy_backward(child, child + keyNum + 1, child + keyNum + 2);",
			"                keys[0] = key;",
			"                child[0] = p;",
			"                keyNum++;",
			"            }",
			"            void push_back(node key, block *p) {",
			"                keys[keyNum] = key;",
			"                child[keyNum + 1] = p;",
			"                keyNum++;",
			"            }",
			"            void pop_front() {",
			"                std::copy(keys + 1, keys + keyNum, keys);",
			"                bool is_leaf = !child[0];",
			"                std::copy(child + 1, child + keyNum + 1, child);",
			"                if (is_leaf) child[0] = nullptr;",
			"                keyNum--;",
			"            }",
			"            void pop_back() { keyNum--; }",
			"            void updateMinMax() {",
			"                if (!child[0]) {",
			"                    min = keys[0];",
			"                    max = keys[keyNum - 1];",
			"                } else {",
			"                    min = child[0]->min;",
			"                    max = child[keyNum]->max;",
			"                }",
			"            }",
			"        };",
			"        _Compare m_comp;",
			"        block *m_root;",
			"        static void getLeftLast(block *parent, int pos) {",
			"            block *left = parent->child[pos - 1];",
			"            block *right = parent->child[pos];",
			"            bool is_leaf = !right->child[0];",
			"            right->push_front(parent->keys[pos - 1], is_leaf ? nullptr : left->child[left->keyNum]);",
			"            parent->keys[pos - 1] = left->keys[left->keyNum - 1];",
			"            left->pop_back();",
			"            int w = is_leaf ? 1 : right->child[0]->weight + 1;",
			"            left->max = is_leaf ? left->keys[left->keyNum - 1] : left->child[left->keyNum]->max;",
			"            right->min = is_leaf ? right->keys[0] : right->child[0]->min;",
			"            left->weight -= w;",
			"            right->weight += w;",
			"        }",
			"        static void getRightFirst(block *parent, int pos) {",
			"            block *left = parent->child[pos];",
			"            block *right = parent->child[pos + 1];",
			"            bool is_leaf = !right->child[0];",
			"            left->push_back(parent->keys[pos], right->child[0]);",
			"            parent->keys[pos] = right->keys[0];",
			"            right->pop_front();",
			"            int w = is_leaf ? 1 : left->child[left->keyNum]->weight + 1;",
			"            left->max = is_leaf ? left->keys[left->keyNum - 1] : left->child[left->keyNum]->max;",
			"            right->min = is_leaf ? right->keys[0] : right->child[0]->min;",
			"            left->weight += w;",
			"            right->weight -= w;",
			"        }",
			"        static void mergeAt(block *parent, int pos) {",
			"            block *left = parent->child[pos];",
			"            block *right = parent->child[pos + 1];",
			"            left->keys[left->keyNum] = parent->keys[pos];",
			"            std::copy(right->keys, right->keys + right->keyNum, left->keys + left->keyNum + 1);",
			"            std::copy(right->child, right->child + right->keyNum + 1, left->child + left->keyNum + 1);",
			"            left->keyNum = _K * 2 - 1;",
			"            left->max = right->max;",
			"            left->weight += right->weight + 1;",
			"            delete right;",
			"            std::copy(parent->keys + pos + 1, parent->keys + parent->keyNum, parent->keys + pos);",
			"            std::copy(parent->child + pos + 2, parent->child + parent->keyNum + 1, parent->child + pos + 1);",
			"            parent->keyNum--;",
			"        }",
			"        static void splitAt(block *parent, int pos) {",
			"            block *left = parent->child[pos];",
			"            block *right = new block;",
			"            left->keyNum = right->keyNum = _K - 1;",
			"            std::copy(left->keys + _K, left->keys + (_K * 2 - 1), right->keys);",
			"            if (left->child[0]) {",
			"                int w = _K - 1;",
			"                for (int i = 0; i < _K; i++) {",
			"                    right->child[i] = left->child[_K + i];",
			"                    w += right->child[i]->weight;",
			"                }",
			"                right->min = right->child[0]->min;",
			"                right->max = left->max;",
			"                right->weight = w;",
			"                left->max = left->child[_K - 1]->max;",
			"                left->weight -= w + 1;",
			"            } else {",
			"                right->min = right->keys[0];",
			"                right->max = left->max;",
			"                right->weight = _K - 1;",
			"                left->max = left->keys[_K - 2];",
			"                left->weight -= _K;",
			"            }",
			"            parent->child[pos + 1] = right;",
			"            parent->keys[pos] = left->keys[_K - 1];",
			"            parent->keyNum++;",
			"        }",
			"        const node *key_lower_bound(const node *first, const node *last, _Tp __val) const {",
			"            int len = last - first;",
			"            while (len) {",
			"                int half = len / 2;",
			"                const node *mid = first + half;",
			"                if (m_comp(mid->key, __val)) {",
			"                    first = mid + 1;",
			"                    len -= half + 1;",
			"                } else",
			"                    len = half;",
			"            }",
			"            return first;",
			"        }",
			"        const node *key_upper_bound(const node *first, const node *last, _Tp __val) const {",
			"            int len = last - first;",
			"            while (len) {",
			"                int half = len / 2;",
			"                const node *mid = first + half;",
			"                if (m_comp(__val, mid->key))",
			"                    len = half;",
			"                else {",
			"                    first = mid + 1;",
			"                    len -= half + 1;",
			"                }",
			"            }",
			"            return first;",
			"        }",
			"        block *_insert(block *cur, const node &item, bool &res) {",
			"            int pos = key_upper_bound(cur->keys, cur->keys + cur->keyNum, item.key) - cur->keys;",
			"            if constexpr (!_Tag::multi_key)",
			"                if (pos && !m_comp(cur->keys[pos - 1].key, item.key)) return cur;",
			"            if (!cur->child[0]) {",
			"                std::copy_backward(cur->keys + pos, cur->keys + cur->keyNum, cur->keys + cur->keyNum + 1);",
			"                cur->keys[pos] = item;",
			"                cur->keyNum++;",
			"                res = true;",
			"            } else {",
			"                if (cur->child[pos]->keyNum == _K * 2 - 1) {",
			"                    std::copy_backward(cur->keys + pos, cur->keys + cur->keyNum, cur->keys + cur->keyNum + 1);",
			"                    std::copy_backward(cur->child + pos + 1, cur->child + cur->keyNum + 1, cur->child + cur->keyNum + 2);",
			"                    splitAt(cur, pos);",
			"                    if (m_comp(cur->keys[pos].key, item.key)) pos++;",
			"                }",
			"                _insert(cur->child[pos], item, res);",
			"            }",
			"            if (res) {",
			"                cur->weight++;",
			"                if (m_comp(item.key, cur->min.key)) cur->min = item;",
			"                if (m_comp(cur->max.key, item.key)) cur->max = item;",
			"            }",
			"            return cur;",
			"        }",
			"        block *_erase(block *cur, _Tp key, bool &res) {",
			"            int pos = key_lower_bound(cur->keys, cur->keys + cur->keyNum, key) - cur->keys;",
			"            if (pos == cur->keyNum || m_comp(key, cur->keys[pos].key)) {",
			"                if (!cur->child[0]) return cur;",
			"                if (cur->child[pos]->keyNum == _K - 1) {",
			"                    if (pos && cur->child[pos - 1]->keyNum >= _K)",
			"                        getLeftLast(cur, pos);",
			"                    else if (pos < cur->keyNum && cur->child[pos + 1]->keyNum >= _K)",
			"                        getRightFirst(cur, pos);",
			"                    else {",
			"                        if (pos) pos--;",
			"                        mergeAt(cur, pos);",
			"                        if (!cur->keyNum) {",
			"                            m_root = _erase(cur->child[0], key, res);",
			"                            delete cur;",
			"                            return m_root;",
			"                        }",
			"                    }",
			"                }",
			"                cur->child[pos] = _erase(cur->child[pos], key, res);",
			"                if (res) {",
			"                    cur->weight--;",
			"                    cur->min = cur->child[0]->min;",
			"                    cur->max = cur->child[cur->keyNum]->max;",
			"                }",
			"                return cur;",
			"            } else {",
			"                res = true;",
			"                if (!--cur->weight) {",
			"                    delete cur;",
			"                    return nullptr;",
			"                }",
			"                if (!cur->child[0]) {",
			"                    std::copy(cur->keys + pos + 1, cur->keys + cur->keyNum, cur->keys + pos);",
			"                    cur->keyNum--;",
			"                    cur->updateMinMax();",
			"                } else if (cur->child[pos]->keyNum >= _K) {",
			"                    node leftMax = cur->child[pos]->max;",
			"                    cur->keys[pos] = leftMax;",
			"                    cur->child[pos] = _erase(cur->child[pos], leftMax.key, res);",
			"                } else if (cur->child[pos + 1]->keyNum >= _K) {",
			"                    node rightMin = cur->child[pos + 1]->min;",
			"                    cur->keys[pos] = rightMin;",
			"                    cur->child[pos + 1] = _erase(cur->child[pos + 1], rightMin.key, res);",
			"                } else {",
			"                    mergeAt(cur, pos);",
			"                    if (!cur->keyNum) {",
			"                        m_root = _erase(cur->child[0], key, res);",
			"                        delete cur;",
			"                        return m_root;",
			"                    }",
			"                    cur->child[pos] = _erase(cur->child[pos], key, res);",
			"                }",
			"                return cur;",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { block::_reserve(__count); }",
			"        BTree(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            node item = node{__key, __args...};",
			"            bool res = false;",
			"            if (!m_root) {",
			"                m_root = new block;",
			"                m_root->min = m_root->max = m_root->keys[0] = item;",
			"                m_root->keyNum = m_root->weight = 1;",
			"            } else {",
			"                if (m_root->keyNum == _K * 2 - 1) {",
			"                    block *p = new block;",
			"                    p->keyNum = 0;",
			"                    p->child[0] = m_root;",
			"                    p->weight = m_root->weight;",
			"                    splitAt(p, 0);",
			"                    m_root = _insert(p, item, res);",
			"                } else",
			"                    m_root = _insert(m_root, item, res);",
			"            }",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key); p)",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            bool res = false;",
			"            if (m_root) m_root = _erase(m_root, __key, res);",
			"            return res;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            block *cur = m_root;",
			"            int ord = 0;",
			"            while (cur) {",
			"                int pos = key_lower_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys;",
			"                ord += pos;",
			"                if (!cur->child[0]) break;",
			"                for (int i = 0; i < pos; i++) ord += cur->child[i]->weight;",
			"                cur = cur->child[pos];",
			"            }",
			"            return ord;",
			"        }",
			"        const node *kth(int k) const {",
			"            block *cur = m_root;",
			"            for (int i; cur->child[0]; cur = cur->child[i])",
			"                for (i = 0; k >= cur->child[i]->weight; i++) {",
			"                    k -= cur->child[i]->weight;",
			"                    if (!k--) return cur->keys + i;",
			"                }",
			"            return cur->keys + k;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            block *cur = m_root;",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            for (int i;; cur = cur->child[i]) {",
			"                if (i = key_lower_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys; i < cur->keyNum && !m_comp(__key, cur->keys[i].key)) return cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            block *cur = m_root;",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            for (int i;; cur = cur->child[i]) {",
			"                if (i = key_lower_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys) res = cur->keys + i - 1;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            block *cur = m_root;",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            for (int i; cur; cur = i ? cur->child[i - 1] : nullptr) {",
			"                if (i = key_lower_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys; i < cur->keyNum) res = cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            block *cur = m_root;",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            for (int i; cur; cur = cur->child[i]) {",
			"                if (i = key_upper_bound(cur->keys, cur->keys + cur->keyNum, __key) - cur->keys; i < cur->keyNum) res = cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return m_root ? m_root->weight : 0; }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if constexpr (!_Tag::multi_key)",
			"                return it2 != it1;",
			"            else {",
			"                if (!it2)",
			"                    return size() - rank(__key);",
			"                else",
			"                    return rank(it2->key) - rank(__key);",
			"            }",
			"        }",
			"    };",
			"    namespace BTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>, int _K = 28>",
			"        using Set = BTree<_Tp, bool, _Compare, BTreeSetTag, _K>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>, int _K = 28>",
			"        using Multiset = BTree<_Tp, bool, _Compare, BTreeMultisetTag, _K>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>, int _K = 28>",
			"        using Map = BTree<_Tp, _Fp, _Compare, BTreeMapTag, _K>;",
			"    }",
			"}",
		],
		"description": "B tree"
	},
    "cat tree":{
        "prefix": "CAT",
        "body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation>",
			"    class CatTree {",
			"        std::vector<std::vector<_Tp>> m_sub;",
			"        _Operation m_op;",
			"        int m_length;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"",
			"    public:",
			"        CatTree(int __n = 0, _Operation __op = std::max<_Tp>, _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        CatTree(_Iterator __first, _Iterator __last, _Operation __op = std::max<_Tp>, _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            int d = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.resize(d);",
			"            for (int i = 0; i < d; i++) {",
			"                m_sub[i].resize(m_length * 2);",
			"                for (int j = 0, k = j + (1 << i); j < m_length; j += 1 << i, k = std::min(j + (1 << i), m_length)) {",
			"                    for (int l = j; l < k; l++) m_sub[i][l * 2] = l == j ? m_defaultValue : m_op(m_sub[i][(l - 1) * 2], m_defaultValue);",
			"                    for (int l = k - 1; l >= j; l--) m_sub[i][l * 2 + 1] = l == k - 1 ? m_defaultValue : m_op(m_sub[i][(l + 1) * 2 + 1], m_defaultValue);",
			"                }",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            int d = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.resize(d);",
			"            for (int i = 0; i < d; i++) {",
			"                m_sub[i].resize(m_length * 2);",
			"                for (int j = 0, k = j + (1 << i); j < m_length; j += 1 << i, k = std::min(j + (1 << i), m_length)) {",
			"                    for (int l = j; l < k; l++) m_sub[i][l * 2] = l == j ? *(__first + l) : m_op(m_sub[i][(l - 1) * 2], *(__first + l));",
			"                    for (int l = k - 1; l >= j; l--) m_sub[i][l * 2 + 1] = l == k - 1 ? *(__first + l) : m_op(m_sub[i][(l + 1) * 2 + 1], *(__first + l));",
			"                }",
			"            }",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            m_sub[0][__i * 2] = __val;",
			"            for (int i = 1; i < m_sub.size(); i++) {",
			"                int j = __i - (__i & (1 << i) - 1), k = std::min(j + (1 << i), m_length);",
			"                for (int l = j; l < k; l++) m_sub[i][l * 2] = l == j ? query(l) : m_op(m_sub[i][(l - 1) * 2], query(l));",
			"                for (int l = k - 1; l >= j; l--) m_sub[i][l * 2 + 1] = l == k - 1 ? query(l) : m_op(m_sub[i][(l + 1) * 2 + 1], query(l));",
			"            }",
			"        }",
			"        _Tp query(int __i) const { return m_sub[0][__i * 2]; }",
			"        _Tp query(int __left, int __right) const {",
			"            if (__left == __right) return m_sub[0][__left * 2];",
			"            int d = 31 - std::__countl_zero(__right ^ __left);",
			"            return m_op(m_sub[d][__left * 2 + 1], m_sub[d][__right * 2]);",
			"        }",
			"        _Tp queryAll() const { return query(0, m_length - 1); }",
			"    };",
			"    template <typename _Tp = int>",
			"    CatTree(int = 0, const _Tp &(*)(const _Tp &, const _Tp &) = std::max<_Tp>) -> CatTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int>",
			"    CatTree(int, _Tp (*)(_Tp, _Tp)) -> CatTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    CatTree(int, _Operation) -> CatTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    CatTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &) = std::max<_Tp>) -> CatTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    CatTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp)) -> CatTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Operation, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    CatTree(_Iterator, _Iterator, _Operation) -> CatTree<_Tp, _Operation>;",
			"}",
        ],
        "description": "cat tree"
    },
	"discretizer":{
		"prefix": "DIS",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = int>",
			"    class Discretizer : public std::vector<_Tp> {",
			"        using std::vector<_Tp>::vector, std::vector<_Tp>::begin, std::vector<_Tp>::end, std::vector<_Tp>::insert, std::vector<_Tp>::push_back, std::vector<_Tp>::resize;",
			"",
			"    public:",
			"        Discretizer &operator<<(const _Tp &__item) {",
			"            push_back(__item);",
			"            return *this;",
			"        }",
			"        Discretizer &operator<<(const std::vector<_Tp> &__items) {",
			"            insert(end(),__items.begin(),__items.end());",
			"            return *this;",
			"        }",
			"        Discretizer &operator<<(const std::vector<std::vector<_Tp>> &__items) {",
			"            for(auto&each:__items)*this<<each;",
			"            return *this;",
			"        }",
			"        void prepare() {",
			"            std::sort(begin(), end());",
			"            resize(std::unique(begin(), end()) - begin());",
			"        }",
			"        int rank(const _Tp &__item) {",
			"            return lower_bound(__item);",
			"        }",
			"        int lower_bound(const _Tp &__item) {",
			"            return std::lower_bound(begin(), end(), __item) - begin();",
			"        }",
			"        int upper_bound(const _Tp &__item) {",
			"            return std::upper_bound(begin(), end(), __item) - begin();",
			"        }",
			"    };",
			"}",
		],
		"description": "discretizer"
	},
    "divide tree":{
        "prefix": "DIV",
        "body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"    class DivideTree {",
			"        std::vector<std::vector<int>> m_left;",
			"        std::vector<_Tp> m_sorted;",
			"        _Compare m_comp;",
			"        int m_length, m_depth;",
			"",
			"    public:",
			"        DivideTree(_Compare __comp = _Compare()) : m_comp(__comp) {}",
			"        template <typename _Iterator>",
			"        DivideTree(_Iterator __first, _Iterator __last, _Compare __comp = _Compare()) : m_comp(__comp) {",
			"            reset(__first, __last);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sorted.resize(1 << m_depth);",
			"            m_left.resize(m_depth);",
			"            std::vector<int> leftSame(1 << m_depth, 1);",
			"            std::vector<_Tp> cur(1 << m_depth), nxt(1 << m_depth);",
			"            std::partial_sort_copy(__first, __last, m_sorted.begin(), m_sorted.begin() + m_length, m_comp);",
			"            std::fill(m_sorted.begin() + m_length, m_sorted.end(), m_sorted[m_length - 1]);",
			"            for (int i = 1; i < 1 << m_depth; i++)",
			"                if (!m_comp(m_sorted[i - 1], m_sorted[i])) leftSame[i] = leftSame[i - 1] + 1;",
			"            std::copy(__first, __last, cur.begin());",
			"            std::fill(cur.begin() + (__last - __first), cur.end(), m_sorted.back());",
			"            for (int i = 0; i < m_depth; i++) {",
			"                m_left[i].clear();",
			"                m_left[i].reserve(1 << m_depth);",
			"                for (int j = 0, k = 1 << (m_depth - i - 1); j < 1 << m_depth; j += k * 2) {",
			"                    _Tp mid = m_sorted[j + k - 1];",
			"                    int same = std::min(k, leftSame[j + k - 1]);",
			"                    int toLeft = 0;",
			"                    for (auto now = cur.begin() + j, end = cur.begin() + j + k * 2, l = nxt.begin() + j, r = nxt.begin() + j + k; now < end; ++now)",
			"                        if (m_comp(*now, mid) || (!m_comp(mid, *now) && same-- > 0)) {",
			"                            *l++ = *now;",
			"                            m_left[i].push_back(++toLeft);",
			"                        } else {",
			"                            *r++ = *now;",
			"                            m_left[i].push_back(toLeft);",
			"                        }",
			"                }",
			"                std::swap(cur, nxt);",
			"            }",
			"        }",
			"        _Tp query(int __left, int __right, int __k) const {",
			"            for (int i = 0, j = 1 << (m_depth - 1), k = 0; i < m_depth; i++, j >>= 1) {",
			"                int toLeft = m_left[i][__right] - (__left == k ? 0 : m_left[i][__left - 1]);",
			"                if (__k < toLeft) {",
			"                    __left = k + (__left == k ? 0 : m_left[i][__left - 1]);",
			"                    __right = k + m_left[i][__right] - 1;",
			"                } else {",
			"                    __left = __left == k ? j + k : __left + j - m_left[i][__left - 1];",
			"                    __right += j - m_left[i][__right];",
			"                    __k -= toLeft;",
			"                    k += j;",
			"                }",
			"            }",
			"            return m_sorted[__left];",
			"        }",
			"    };",
			"    template <typename _Compare = std::less<int>, typename _Tp = std::decay_t<typename decltype(std::function(std::declval<_Compare>()))::first_argument_type>>",
			"    DivideTree(_Compare = _Compare()) -> DivideTree<_Tp, _Compare>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Compare = std::less<_Tp>>",
			"    DivideTree(_Iterator, _Iterator, _Compare = _Compare()) -> DivideTree<_Tp, _Compare>;",
			"}",
        ],
        "description": "divide tree"
    },
	"fhq treap":{
		"prefix": "FHQ",
		"body": [
			"namespace OY {",
			"    struct FHQTreapSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct FHQTreapMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct FHQTreapMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _FHQTreapNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _FHQTreapNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = FHQTreapMultisetTag>",
			"    class FHQTreap {",
			"        struct node : _FHQTreapNode<_Tp, _Fp, _Tag::is_map> {",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static inline std::mt19937 s_rand;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        void split_less(node *p, const _Tp &key, node *&l, node *&r) {",
			"            if (!p)",
			"                l = r = nullptr;",
			"            else if (m_comp(p->key, key)) {",
			"                split_less(p->rchild, key, l, r);",
			"                p->rchild = l;",
			"                l = update(p);",
			"            } else {",
			"                split_less(p->lchild, key, l, r);",
			"                p->lchild = r;",
			"                r = update(p);",
			"            }",
			"        }",
			"        void split_less_equal(node *p, const _Tp &key, node *&l, node *&r) {",
			"            if (!p)",
			"                l = r = nullptr;",
			"            else if (m_comp(key, p->key)) {",
			"                split_less_equal(p->lchild, key, l, r);",
			"                p->lchild = r;",
			"                r = update(p);",
			"            } else {",
			"                split_less_equal(p->rchild, key, l, r);",
			"                p->rchild = l;",
			"                l = update(p);",
			"            }",
			"        }",
			"        void split_by_key(node *p, const _Tp &key, node *&l, node *&mid, node *&r) {",
			"            if (!p)",
			"                l = mid = r = nullptr;",
			"            else if (m_comp(p->key, key)) {",
			"                split_by_key(p->rchild, key, l, mid, r);",
			"                p->rchild = l;",
			"                l = update(p);",
			"            } else if (m_comp(key, p->key)) {",
			"                split_by_key(p->lchild, key, l, mid, r);",
			"                p->lchild = r;",
			"                r = update(p);",
			"            } else {",
			"                node *l_mid, *r_mid;",
			"                split_less(p->lchild, key, l, l_mid);",
			"                split_less_equal(p->rchild, key, r_mid, r);",
			"                p->lchild = l_mid;",
			"                p->rchild = r_mid;",
			"                mid = update(p);",
			"            }",
			"        }",
			"        void split_by_rank(node *p, int k, node *&l, node *&r) {",
			"            if (!k) {",
			"                l = nullptr;",
			"                r = p;",
			"            } else if (subtree_weight(p->lchild) > k) {",
			"                split_by_rank(p->lchild, k, l, r);",
			"                p->lchild = r;",
			"                r = update(p);",
			"            } else if (k -= subtree_weight(p->lchild); !k) {",
			"                l = p->lchild;",
			"                p->lchild = nullptr;",
			"                r = update(p);",
			"            } else {",
			"                split_by_rank(p->rchild, k - 1, l, r);",
			"                p->rchild = l;",
			"                l = update(p);",
			"            }",
			"        }",
			"        static node *merge(node *l, node *r) {",
			"            if (!l) return r;",
			"            if (!r) return l;",
			"            if (l->priority > r->priority) {",
			"                l->rchild = merge(l->rchild, r);",
			"                return update(l);",
			"            } else {",
			"                r->lchild = merge(l, r->lchild);",
			"                return update(r);",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        FHQTreap(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            node *l, *r;",
			"            split_less_equal(m_root, __key, l, r);",
			"            m_root = merge(merge(l, new node{__key, __args..., s_rand(), 1, nullptr, nullptr}), r);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(m_root, __key, l, mid, r);",
			"            if (!mid)",
			"                m_root = merge(l, r);",
			"            else {",
			"                delete mid;",
			"                m_root = mid->subtree_weight > 1 ? merge(merge(l, mid->lchild), merge(mid->rchild, r)) : merge(l, r);",
			"            }",
			"            return mid;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) {",
			"            node *l, *r;",
			"            split_less(m_root, __key, l, r);",
			"            int ord = subtree_weight(l);",
			"            m_root = merge(l, r);",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) {",
			"            node *l, *r;",
			"            split_by_rank(m_root, __k, l, r);",
			"            node *res = r;",
			"            while (res->lchild) res = res->lchild;",
			"            m_root = merge(l, r);",
			"            return res;",
			"        }",
			"        const node *find(_Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(m_root, __key, l, mid, r);",
			"            node *res = mid;",
			"            m_root = merge(merge(l, mid), r);",
			"            return res;",
			"        }",
			"        const node *lower_bound(_Tp __key) {",
			"            node *l, *r;",
			"            split_less(m_root, __key, l, r);",
			"            node *res = r;",
			"            while (res->lchild) res = res->lchild;",
			"            m_root = merge(l, r);",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) {",
			"            node *l, *r;",
			"            split_less_equal(m_root, __key, l, r);",
			"            node *res = r;",
			"            while (res->lchild) res = res->lchild;",
			"            m_root = merge(l, r);",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) {",
			"            node *l, *r;",
			"            split_less(m_root, __key, l, r);",
			"            node *res = l;",
			"            while (res->rchild) res = res->rchild;",
			"            m_root = merge(l, r);",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(m_root, __key, l, mid, r);",
			"            int res = subtree_weight(mid);",
			"            m_root = merge(merge(l, mid), r);",
			"            return res;",
			"        }",
			"    };",
			"    namespace FHQTreapContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = FHQTreap<_Tp, bool, _Compare, FHQTreapSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = FHQTreap<_Tp, bool, _Compare, FHQTreapMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = FHQTreap<_Tp, _Fp, _Compare, FHQTreapMapTag>;",
			"    }",
			"}",
		],
		"description": "fhq treap"
	},
	"fhq treap array":{
		"prefix": "FHQ",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    class FHQTreapArray {",
			"        struct node : MemoryPool<node> {",
			"            _Tp key;",
			"            bool reversed;",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            void reverse() { reversed = reversed ? false : true; }",
			"            void push_down() {",
			"                reverse();",
			"                std::swap(lchild, rchild);",
			"                if (lchild) lchild->reverse();",
			"                if (rchild) rchild->reverse();",
			"            }",
			"        };",
			"        node *m_root;",
			"        static inline std::mt19937 s_rand;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static void split_l_r(node *p, int k, node *child[2]) {",
			"            if (!p) return;",
			"            if (p->reversed) p->push_down();",
			"            if (!k) { //全部归大边",
			"                child[0] = nullptr;",
			"                child[1] = p;",
			"            } else if (k == p->subtree_weight) {",
			"                child[0] = p;",
			"                child[1] = nullptr;",
			"            } else if (subtree_weight(p->lchild) > k) { //小边够分，小边分大小",
			"                split_l_r(p->lchild, k, child);",
			"                p->lchild = child[1];",
			"                child[1] = update(p);",
			"            } else if (k -= subtree_weight(p->lchild); k) { //小边正好够",
			"                split_l_r(p->rchild, k - 1, child);         //小边不够，分大边",
			"                p->rchild = child[0];",
			"                child[0] = update(p);",
			"            } else {",
			"                child[0] = p->lchild;",
			"                p->lchild = nullptr;",
			"                child[1] = update(p);",
			"            }",
			"        }",
			"        static void split_l_m_r(node *p, int left, int right, node *child[3]) {",
			"            split_l_r(p, right + 1, child + 1);",
			"            split_l_r(child[1], left, child);",
			"        }",
			"        static node *merge(node *l, node *r) {",
			"            if (!l) return r;",
			"            if (!r) return l;",
			"            if (l->priority > r->priority) {",
			"                if (l->reversed) l->push_down();",
			"                l->rchild = merge(l->rchild, r);",
			"                return update(l);",
			"            } else {",
			"                if (r->reversed) r->push_down();",
			"                r->lchild = merge(l, r->lchild);",
			"                return update(r);",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        node *make_tree(_Iterator first, _Iterator last) {",
			"            auto _make_tree = [](auto self, _Iterator first, _Iterator last) -> node * {",
			"                if (first == last) return nullptr;",
			"                if (first + 1 == last) return new node{{}, *first, false, s_rand(), 1, nullptr, nullptr};",
			"                _Iterator mid = first + (last - first) / 2;",
			"                node *p = new node{{}, *mid, false, 0, 1, self(self, first, mid), self(self, mid + 1, last)};",
			"                return update(p);",
			"            };",
			"            node *root = _make_tree(_make_tree, first, last);",
			"            static std::vector<uint_fast32_t> s_prior;",
			"            static std::vector<node *> s_queue;",
			"            s_prior.resize(root->subtree_weight);",
			"            s_queue.clear();",
			"            s_queue.reserve(root->subtree_weight);",
			"            for (uint_fast32_t &a : s_prior) a = s_rand();",
			"            std::sort(s_prior.rbegin(), s_prior.rend());",
			"            s_queue.reserve(root->subtree_weight);",
			"            s_queue.push_back(root);",
			"            for (int i = 0; i < s_queue.size(); i++) {",
			"                node *p = s_queue[i];",
			"                p->priority = s_prior[i];",
			"                if (p->lchild) s_queue.push_back(p->lchild);",
			"                if (p->rchild) s_queue.push_back(p->rchild);",
			"            }",
			"            return root;",
			"        }",
			"        void _clear(node *cur) {",
			"            if (cur->lchild) _clear(cur->lchild);",
			"            if (cur->rchild) _clear(cur->rchild);",
			"            delete cur;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        FHQTreapArray() : m_root(nullptr) {}",
			"        template <typename _Iterator>",
			"        FHQTreapArray(_Iterator __first, _Iterator __last) : m_root(make_tree(__first, __last)) {}",
			"        void clear() {",
			"            m_root = nullptr;",
			"        }",
			"        void insert(int __pos, _Tp __key) {",
			"            node *child[2];",
			"            split_l_r(m_root, __pos, child);",
			"            m_root = merge(merge(child[0], new node{{}, __key, false, s_rand(), 1, nullptr, nullptr}), child[1]);",
			"        }",
			"        void update(int __pos, _Tp __key) { at(__pos)->key = __key; }",
			"        void erase(int __pos) {",
			"            node *child[3] = {0};",
			"            split_l_m_r(m_root, __pos, __pos, child);",
			"            delete child[1];",
			"            m_root = merge(child[0], child[2]);",
			"        }",
			"        void erase(int __left, int __right) {",
			"            node *child[3] = {0};",
			"            split_l_m_r(m_root, __left, __right, child);",
			"            if (child[1]) _clear(child[1]);",
			"            m_root = merge(child[0], child[2]);",
			"        }",
			"        template <typename _Iterator>",
			"        void assign(_Iterator __first, _Iterator __last) {",
			"            clear();",
			"            m_root = make_tree(__first, __last);",
			"        }",
			"        void reverse(int __left, int __right) {",
			"            node *child[3] = {0};",
			"            split_l_m_r(m_root, __left, __right, child);",
			"            child[1]->reverse();",
			"            m_root = merge(merge(child[0], child[1]), child[2]);",
			"        }",
			"        void push_front(_Tp __key) { m_root = merge(new node{{}, __key, false, s_rand(), 1, nullptr, nullptr}, m_root); }",
			"        void push_back(_Tp __key) { m_root = merge(m_root, new node{{}, __key, false, s_rand(), 1, nullptr, nullptr}); }",
			"        void pop_front() {",
			"            node *child[2];",
			"            split_l_r(m_root, 1, child);",
			"            delete child[0];",
			"            m_root = child[1];",
			"        }",
			"        void pop_back() {",
			"            node *child[2];",
			"            split_l_r(m_root, m_root->subtree_weight - 1, child);",
			"            delete child[1];",
			"            m_root = child[0];",
			"        }",
			"        node *at(int __pos) const {",
			"            node *cur = m_root;",
			"            while (true) {",
			"                if (cur->reversed) cur->push_down();",
			"                if (subtree_weight(cur->lchild) > __pos)",
			"                    cur = cur->lchild;",
			"                else if (__pos -= subtree_weight(cur->lchild); !__pos--)",
			"                    break;",
			"                else",
			"                    cur = cur->rchild;",
			"            };",
			"            return cur;",
			"        }",
			"        _Tp &operator[](int __index) const { return at(__index)->key; }",
			"        node *front(int __pos) const { return at(0); }",
			"        node *back() const { return at(size() - 1); }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        FHQTreapArray<_Tp> subArray(int __left, int __right) {",
			"            node *child[3] = {0};",
			"            split_l_m_r(m_root, __left, __right, child);",
			"            m_root = merge(child[0], child[2]);",
			"            FHQTreapArray<_Tp> sub;",
			"            sub.m_root = child[1];",
			"            return sub;",
			"        }",
			"        void join(FHQTreapArray<_Tp> &__other) {",
			"            m_root = merge(m_root, __other.m_root);",
			"            __other.m_root = nullptr;",
			"        }",
			"        std::vector<_Tp> to_vector() const {",
			"            std::vector<_Tp> v;",
			"            v.reserve(size());",
			"            auto dfs = [&](auto self, node *cur) -> void {",
			"                if (cur->reversed) cur->push_down();",
			"                if (cur->lchild) self(self, cur->lchild);",
			"                v.push_back(cur->key);",
			"                if (cur->rchild) self(self, cur->rchild);",
			"            };",
			"            if (m_root) dfs(dfs, m_root);",
			"            return v;",
			"        }",
			"    };",
			"    template <typename _Tp = int>",
			"    FHQTreapArray() -> FHQTreapArray<_Tp>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    FHQTreapArray(_Iterator, _Iterator) -> FHQTreapArray<_Tp>;",
			"}",
		],
		"description": "fhq treap array"
	},
	"kd tree":{
		"prefix": "KD",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, int _K>",
			"    struct KDTreeRectRange {",
			"        _Tp min[_K];",
			"        _Tp max[_K];",
			"        template <typename treenode>",
			"        bool intersect(const treenode &rect) const {",
			"            for (int i = 0; i < _K; i++)",
			"                if (rect.max[i] < min[i] || rect.min[i] > max[i]) return false;",
			"            return true;",
			"        }",
			"        template <typename treenode>",
			"        bool contain_rect(const treenode &rect) const {",
			"            for (int i = 0; i < _K; i++)",
			"                if (rect.min[i] < min[i] || rect.max[i] > max[i]) return false;",
			"            return true;",
			"        }",
			"        template <typename node>",
			"        bool contain_point(const node &point) const {",
			"            for (int i = 0; i < _K; i++)",
			"                if (point.pos[i] < min[i] || point.pos[i] > max[i]) return false;",
			"            return true;",
			"        }",
			"    };",
			"    template <typename _Tp, int _K, typename _TpDistance>",
			"    struct KDTreeCircleRange {",
			"        _Tp pos[_K];",
			"        _TpDistance radius_square;",
			"        template <typename treenode>",
			"        bool intersect(const treenode &rect) const {",
			"            bool out = false;",
			"            for (int i = 0; i < _K; i++)",
			"                if (pos[i] < rect.min[i] || pos[i] > rect.max[i]) {",
			"                    out = true;",
			"                    break;",
			"                }",
			"            if (!out) return true;",
			"            _TpDistance dis = 0;",
			"            for (int i = 0; i < _K; i++) {",
			"                _TpDistance p = 0;",
			"                if (pos[i] < rect.min[i])",
			"                    p = rect.min[i] - pos[i];",
			"                else if (pos[i] > rect.max[i])",
			"                    p = rect.max[i] - pos[i];",
			"                dis += p * p;",
			"            }",
			"            return dis <= radius_square;",
			"        }",
			"        template <typename treenode>",
			"        bool contain_rect(const treenode &rect) const {",
			"            _TpDistance dis = 0;",
			"            for (int i = 0; i < _K; i++) {",
			"                _TpDistance p = std::max(std::abs(rect.min[i] - pos[i]), std::abs(rect.max[i] - pos[i]));",
			"                dis += p * p;",
			"            }",
			"            return dis <= radius_square;",
			"        }",
			"        template <typename node>",
			"        bool contain_point(const node &point) const {",
			"            _TpDistance dis = 0;",
			"            for (int i = 0; i < _K; i++) {",
			"                _TpDistance p = point.pos[i] - pos[i];",
			"                dis += p * p;",
			"            }",
			"            return dis <= radius_square;",
			"        }",
			"    };",
			"    template <typename _Tp, typename _Fp, typename _Operation = std::plus<_Fp>, int _K = 2, int _N = 31>",
			"    class KDTree {",
			"    public:",
			"        struct node : MemoryPool<node> {",
			"            _Tp pos[_K];",
			"            _Fp value;",
			"            node() {}",
			"            node(const std::initializer_list<_Tp> &_pos, _Fp _value = _Fp()) : value(_value) { std::copy(_pos.begin(), _pos.end(), pos); }",
			"        };",
			"        struct treenode : MemoryPool<treenode> {",
			"            _Tp min[_K];",
			"            _Tp max[_K];",
			"            int size;",
			"            _Tp thresh;",
			"            _Fp value;",
			"            std::vector<node *> points;",
			"            treenode *lchild;",
			"            treenode *rchild;",
			"            treenode(_Fp _defaultValue = _Fp()) : size(0), value(_defaultValue), lchild(nullptr), rchild(nullptr) {}",
			"            treenode(node *point) : size(1), points({point}), lchild(nullptr), rchild(nullptr) {",
			"                for (int i = 0; i < _K; i++) min[i] = max[i] = point->pos[i];",
			"                value = point->value;",
			"            }",
			"            bool contain_point(const std::initializer_list<_Tp> &pos) const {",
			"                for (int i = 0; i < _K; i++)",
			"                    if (_Tp x = *(pos.begin() + i); x < min[i] || x > max[i]) return false;",
			"                return true;",
			"            }",
			"        };",
			"        treenode *m_root;",
			"",
			"    private:",
			"        _Operation m_op;",
			"        _Fp m_defaultValue;",
			"        std::vector<node *> m_buffer;",
			"        static constexpr int ratio = 4, bias = 4;",
			"        static treenode *updateRange(treenode *p, node *q) {",
			"            for (int i = 0; i < _K; i++) {",
			"                _Tp pos = q->pos[i];",
			"                if (pos < p->min[i])",
			"                    p->min[i] = pos;",
			"                else if (pos > p->max[i])",
			"                    p->max[i] = pos;",
			"            }",
			"            return p;",
			"        }",
			"        static treenode *updateRange(treenode *p, const std::initializer_list<_Tp> &pos) {",
			"            for (int i = 0; i < _K; i++) {",
			"                _Tp _pos = *(pos.begin() + i);",
			"                if (_pos < p->min[i])",
			"                    p->min[i] = _pos;",
			"                else if (_pos > p->max[i])",
			"                    p->max[i] = _pos;",
			"            }",
			"            return p;",
			"        }",
			"        treenode *updateByChild(treenode *p) {",
			"            std::copy(p->lchild->min, p->lchild->min + _K, p->min);",
			"            std::copy(p->lchild->max, p->lchild->max + _K, p->max);",
			"            for (int i = 0; i < _K; i++)",
			"                if (p->rchild->min[i] < p->min[i]) p->min[i] = p->rchild->min[i];",
			"            for (int i = 0; i < _K; i++)",
			"                if (p->rchild->max[i] > p->max[i]) p->max[i] = p->rchild->max[i];",
			"            p->size = p->lchild->size + p->rchild->size;",
			"            p->value = m_op(p->lchild->value, p->rchild->value);",
			"            return p;",
			"        }",
			"        treenode *updateBySelf(treenode *p) {",
			"            p->size = p->points.size();",
			"            p->value = p->points[0]->value;",
			"            for (int i = 1; i < p->points.size(); i++) p->value = m_op(p->value, p->points[i]->value);",
			"            return p;",
			"        }",
			"        treenode *update(treenode *p, const std::initializer_list<_Tp> &pos) {",
			"            for (int i = 0; i < _K; i++) {",
			"                _Tp _pos = *(pos.begin() + i);",
			"                if (_pos < p->min[i])",
			"                    p->min[i] = _pos;",
			"                else if (_pos > p->max[i])",
			"                    p->max[i] = _pos;",
			"            }",
			"            if (p->lchild) {",
			"                p->size = p->lchild->size + p->rchild->size;",
			"                p->value = m_op(p->lchild->value, p->rchild->value);",
			"            } else {",
			"                p->size = p->points.size();",
			"                p->value = p->points[0]->value;",
			"                for (int i = 1; i < p->points.size(); i++) p->value = m_op(p->value, p->points[i]->value);",
			"            }",
			"            return p;",
			"        }",
			"        treenode *update(treenode *p) {",
			"            if (p->lchild) {",
			"                p->size = p->lchild->size + p->rchild->size;",
			"                p->value = m_op(p->lchild->value, p->rchild->value);",
			"            } else {",
			"                p->size = p->points.size();",
			"                p->value = p->points[0]->value;",
			"                for (int i = 1; i < p->points.size(); i++) p->value = m_op(p->value, p->points[i]->value);",
			"            }",
			"            return p;",
			"        }",
			"        treenode *balance(treenode *cur, int i) {",
			"            if (cur->lchild) {",
			"                if (cur->lchild->size + cur->rchild->size <= _N || cur->lchild->size > cur->rchild->size * ratio + bias || cur->rchild->size > cur->lchild->size * ratio + bias) return rebuild(cur, i);",
			"            } else if (cur->points.size() > _N)",
			"                return rebuild(cur, i);",
			"            return cur;",
			"        }",
			"        void traverse(treenode *p) {",
			"            if (!p->lchild && !p->rchild) {",
			"                for (node *q : p->points) m_buffer.push_back(q);",
			"            } else {",
			"                if (p->lchild) traverse(p->lchild);",
			"                if (p->rchild) traverse(p->rchild);",
			"            }",
			"            delete p;",
			"        }",
			"        treenode *make_tree(node **first, node **last, int i) {",
			"            if (first == last) return nullptr;",
			"            if (last - first <= _N) {",
			"                treenode *p = new treenode(*first++);",
			"                while (first < last) {",
			"                    p->points.push_back(*first);",
			"                    p = updateRange(p, *first++);",
			"                }",
			"                return updateBySelf(p);",
			"            } else {",
			"                treenode *p = new treenode(m_defaultValue);",
			"                node **mid = first + (last - first) / 2;",
			"                std::nth_element(first, mid, last, [&](const node *x, const node *y) { return x->pos[i] < y->pos[i]; });",
			"                p->thresh = (*mid)->pos[i];",
			"                p->lchild = make_tree(first, mid, i + 1 < _K ? i + 1 : 0);",
			"                p->rchild = make_tree(mid, last, i + 1 < _K ? i + 1 : 0);",
			"                return updateByChild(p);",
			"            }",
			"        }",
			"        treenode *rebuild(treenode *cur, int i) {",
			"            if (cur) traverse(cur);",
			"            cur = make_tree(m_buffer.data(), m_buffer.data() + m_buffer.size(), i);",
			"            m_buffer.clear();",
			"            return cur;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __treeCount, int __nodeCount) {",
			"            MemoryPool<treenode>::_reserve(__treeCount);",
			"            MemoryPool<node>::_reserve(__nodeCount);",
			"        }",
			"        KDTree(_Operation __op = _Operation(), _Fp __defaultValue = _Fp()) : m_root(nullptr), m_op(__op), m_defaultValue(__defaultValue) {}",
			"        ~KDTree() { clear(); }",
			"        void clear() {",
			"            m_root = nullptr;",
			"        }",
			"        void prepared_insert(const std::initializer_list<_Tp> &__pos, _Fp __value = _Fp(1)) { m_buffer.push_back(new node(__pos, __value)); }",
			"        void prepared_build() {",
			"            m_root = make_tree(m_buffer.data(), m_buffer.data() + m_buffer.size(), 0);",
			"            m_buffer.clear();",
			"        }",
			"        void insert(const std::initializer_list<_Tp> &__pos, _Fp __value = _Fp(1)) {",
			"            auto dfs = [&](auto self, treenode *cur, int i) -> treenode * {",
			"                if (!cur)",
			"                    return new treenode(new node(__pos, __value));",
			"                else if (!cur->lchild)",
			"                    cur->points.push_back(new node(__pos, __value));",
			"                else if (*(__pos.begin() + i) < cur->thresh)",
			"                    cur->lchild = self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                else",
			"                    cur->rchild = self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                return balance(update(cur, __pos), i);",
			"            };",
			"            m_root = dfs(dfs, m_root, 0);",
			"        }",
			"        bool erase(const std::initializer_list<_Tp> &__pos) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, treenode *cur, int i) -> treenode * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (!cur->lchild) {",
			"                    auto it = std::find_if(cur->points.begin(), cur->points.end(), [&](const node *p) {",
			"                        for (int i = 0; i < _K; i++)",
			"                            if (p->pos[i] != *(__pos.begin() + i)) return false;",
			"                        return true;",
			"                    });",
			"                    if (it != cur->points.end()) {",
			"                        res = true;",
			"                        cur->points.erase(it);",
			"                    }",
			"                } else {",
			"                    if (*(__pos.begin() + i) <= cur->thresh) cur->lchild = self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                    if (!res && *(__pos.begin() + i) >= cur->thresh) cur->rchild = self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                }",
			"                return res ? balance(update(cur), i) : cur;",
			"            };",
			"            m_root = dfs(dfs, m_root, 0);",
			"            return res;",
			"        }",
			"        const node *find(const std::initializer_list<_Tp> &__pos) const {",
			"            node *res = nullptr;",
			"            auto dfs = [&](auto self, treenode *cur, int i) {",
			"                if (!cur)",
			"                    return;",
			"                else if (!cur->lchild) {",
			"                    auto it = std::find_if(cur->points.begin(), cur->points.end(), [&](const node *p) {",
			"                        for (int i = 0; i < _K; i++)",
			"                            if (p->pos[i] != *(__pos.begin() + i)) return false;",
			"                        return true;",
			"                    });",
			"                    if (it != cur->points.end()) res = *it;",
			"                } else {",
			"                    if (*(__pos.begin() + i) <= cur->thresh) self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                    if (!res && *(__pos.begin() + i) >= cur->thresh) self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0);",
			"            return res;",
			"        }",
			"        template <typename _Range>",
			"        _Fp queryNumber(const _Range &__range) const {",
			"            _Fp res = m_defaultValue;",
			"            auto dfs = [&](auto self, treenode *cur) {",
			"                if (!__range.intersect(*cur)) return;",
			"                if (__range.contain_rect(*cur))",
			"                    res = m_op(res, cur->value);",
			"                else if (cur->lchild) {",
			"                    if (cur->lchild) self(self, cur->lchild);",
			"                    if (cur->rchild) self(self, cur->rchild);",
			"                } else",
			"                    for (node *point : cur->points)",
			"                        if (__range.contain_point(*point)) res = m_op(res, point->value);",
			"            };",
			"            if (m_root) dfs(dfs, m_root);",
			"            return res;",
			"        }",
			"        _Fp queryNumber_rect(const KDTreeRectRange<_Tp, _K> &__range) const {",
			"            return queryNumber(__range);",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _Fp queryNumber_circle(const KDTreeCircleRange<_Tp, _K, _TpDistance> &__range) const {",
			"            return queryNumber(__range);",
			"        }",
			"        template <typename _TpDistance, bool _DropZero, typename _DistanceConvert>",
			"        _TpDistance queryClosest(const std::initializer_list<_Tp> &__pos, _DistanceConvert __conv) const {",
			"            _TpDistance dis = std::numeric_limits<_TpDistance>::max();",
			"            auto dfs = [&](auto self, treenode *cur, int i) {",
			"                if (!cur->contain_point(__pos)) {",
			"                    _TpDistance d = 0;",
			"                    for (int i = 0; i < _K; i++) {",
			"                        _TpDistance di = 0;",
			"                        if (_Tp pos = *(__pos.begin() + i); pos < cur->min[i])",
			"                            di = cur->min[i] - pos;",
			"                        else if (pos > cur->max[i])",
			"                            di = pos - cur->max[i];",
			"                        d += __conv(di);",
			"                    }",
			"                    if (dis <= d) return;",
			"                }",
			"                if (cur->lchild) {",
			"                    if (*(__pos.begin() + i) < cur->thresh) {",
			"                        self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                        self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                    } else {",
			"                        self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                        self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                    }",
			"                } else {",
			"                    for (auto p : cur->points) {",
			"                        _TpDistance d = 0;",
			"                        for (int i = 0; i < _K; i++) {",
			"                            _TpDistance di;",
			"                            if (_Tp pos = *(__pos.begin() + i); pos < p->pos[i])",
			"                                di = p->pos[i] - pos;",
			"                            else",
			"                                di = pos - p->pos[i];",
			"                            d += __conv(di);",
			"                        }",
			"                        if constexpr (_DropZero) {",
			"                            if (d && d < dis) dis = d;",
			"                        } else {",
			"                            if (d < dis) dis = d;",
			"                        }",
			"                    }",
			"                }",
			"            };",
			"            if (m_root) dfs(dfs, m_root, 0);",
			"            return dis;",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _TpDistance queryClosest_Euclidean(const std::initializer_list<_Tp> &__pos) const {",
			"            return queryClosest<_TpDistance, true>(__pos, [](auto x) { return x * x; });",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _TpDistance queryClosest_Manhattan(const std::initializer_list<_Tp> &__pos) const {",
			"            return queryClosest<_TpDistance, true>(__pos, [](auto x) { return x; });",
			"        }",
			"        template <typename _TpDistance, typename _DistanceConvert>",
			"        _TpDistance queryFurthest(const std::initializer_list<_Tp> &__pos, _DistanceConvert __conv) const {",
			"            _TpDistance dis = 0;",
			"            auto dfs = [&](auto self, treenode *cur, int i) {",
			"                _TpDistance d = 0;",
			"                for (int i = 0; i < _K; i++) {",
			"                    _Tp pos = *(__pos.begin() + i);",
			"                    _TpDistance di = std::max(std::abs(pos - cur->min[i]), std::abs(pos - cur->max[i]));",
			"                    d += __conv(di);",
			"                }",
			"                if (dis >= d) return;",
			"                if (cur->lchild) {",
			"                    if (*(__pos.begin() + i) < cur->thresh) {",
			"                        self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                        self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                    } else {",
			"                        self(self, cur->lchild, i + 1 < _K ? i + 1 : 0);",
			"                        self(self, cur->rchild, i + 1 < _K ? i + 1 : 0);",
			"                    }",
			"                } else {",
			"                    for (auto p : cur->points) {",
			"                        _TpDistance d = 0;",
			"                        for (int i = 0; i < _K; i++) {",
			"                            _TpDistance di;",
			"                            if (_Tp pos = *(__pos.begin() + i); pos < p->pos[i])",
			"                                di = p->pos[i] - pos;",
			"                            else",
			"                                di = pos - p->pos[i];",
			"                            d += __conv(di);",
			"                        }",
			"                        if (d > dis) dis = d;",
			"                    }",
			"                }",
			"            };",
			"            if (m_root) dfs(dfs, m_root, 0);",
			"            return dis;",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _TpDistance queryFurthest_Euclidean(const std::initializer_list<_Tp> &__pos) const {",
			"            return queryFurthest<_TpDistance>(__pos, [](auto x) { return x * x; });",
			"        }",
			"        template <typename _TpDistance = _Tp>",
			"        _TpDistance queryFurthest_Manhattan(const std::initializer_list<_Tp> &__pos) const {",
			"            return queryFurthest<_TpDistance>(__pos, [](auto x) { return x; });",
			"        }",
			"    };",
			"}",
		],
		"description": "kd tree"
	},
	"lazy seg tree":{
		"prefix": "LAZY",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct LazySegAdd {",
			"        _Tp operator()(const _Fp &__x, const _Tp &__y, int __size) const { return __x * __size + __y; }",
			"    };",
			"    template <typename _Tp = int64_t, typename _Fp = _Tp, typename _Operation = std::plus<_Tp>, typename _Mapping = OY::LazySegAdd<_Tp, _Fp>, typename _Composition = std::plus<_Fp>>",
			"    class LazySegTree {",
			"        struct _Tp_FpNode : MemoryPool<_Tp_FpNode> {",
			"            _Tp val;",
			"            _Fp inc;",
			"            _Tp_FpNode *lchild;",
			"            _Tp_FpNode *rchild;",
			"            _Tp_FpNode(_Tp _val, _Fp _inc, _Tp_FpNode *_lchild, _Tp_FpNode *_rchild) : val(_val), inc(_inc), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        _Tp_FpNode *m_root;",
			"        int m_length;",
			"        _Operation m_op;",
			"        _Mapping m_map;",
			"        _Composition m_com;",
			"        _Tp m_defaultValue;",
			"        _Fp m_defaultIncrement;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue && m_com(m_defaultIncrement, m_defaultIncrement) == m_defaultIncrement);",
			"            // if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>) assert(m_map(m_defaultIncrement, m_defaultValue, 1) == m_defaultValue);",
			"            // else assert(m_map(m_defaultIncrement, m_defaultValue) == m_defaultValue);",
			"        }",
			"        void _apply(_Tp_FpNode *cur, _Fp inc, int left, int right) {",
			"            if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>)",
			"                cur->val = m_map(inc, cur->val, right - left + 1);",
			"            else",
			"                cur->val = m_map(inc, cur->val);",
			"            if (right > left) cur->inc = m_com(inc, cur->inc);",
			"        }",
			"        _Tp_FpNode *_update(_Tp_FpNode *cur) {",
			"            cur->val = m_op(cur->lchild->val, cur->rchild->val);",
			"            return cur;",
			"        }",
			"        void _pushDown(_Tp_FpNode *cur, int left, int right) {",
			"            if (!cur->lchild) {",
			"                cur->lchild = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"                cur->rchild = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"            }",
			"            _apply(cur->lchild, cur->inc, left, (left + right) / 2);",
			"            _apply(cur->rchild, cur->inc, (left + right) / 2 + 1, right);",
			"            cur->inc = m_defaultIncrement;",
			"        }",
			"        void _clear(_Tp_FpNode *p) { }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_Tp_FpNode>::_reserve(__count); }",
			"        LazySegTree(int __n = 0, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_root(nullptr), m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        LazySegTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_root(nullptr), m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        ~LazySegTree() {",
			"            if (m_root) _clear(m_root);",
			"        }",
			"        void resize(int __n) {",
			"            if (m_root) _clear(m_root);",
			"            if (m_length = __n)",
			"                m_root = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"            else",
			"                m_root = nullptr;",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            if (m_root) _clear(m_root);",
			"            m_length = __last - __first;",
			"            auto dfs = [&](auto self, _Iterator first, _Iterator last) -> _Tp_FpNode * {",
			"                if (first + 1 == last)",
			"                    return new _Tp_FpNode(*first, m_defaultIncrement, nullptr, nullptr);",
			"                else",
			"                    return _update(new _Tp_FpNode(m_defaultValue, m_defaultIncrement, self(self, first, first + (last - first + 1) / 2), self(self, first + (last - first + 1) / 2, last)));",
			"            };",
			"            m_root = dfs(dfs, __first, __last);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) -> void {",
			"                if (left == right)",
			"                    cur->val = __val;",
			"                else {",
			"                    _pushDown(cur, left, right);",
			"                    if (__i <= (left + right) / 2)",
			"                        self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void add(int __i, _Fp __inc) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) -> void {",
			"                if (left == right)",
			"                    _apply(cur, __inc, left, right);",
			"                else {",
			"                    _pushDown(cur, left, right);",
			"                    if (__i <= (left + right) / 2)",
			"                        self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void add(int __left, int __right, _Fp __inc) {",
			"            if (__left == __right) {",
			"                add(__left, __inc);",
			"                return;",
			"            }",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) -> void {",
			"                if (__left <= left && __right >= right)",
			"                    _apply(cur, __inc, left, right);",
			"                else {",
			"                    _pushDown(cur, left, right);",
			"                    int mid = (left + right) / 2;",
			"                    if (__left <= mid) self(self, cur->lchild, left, mid);",
			"                    if (__right > mid) self(self, cur->rchild, mid + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp query(int __i) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) {",
			"                if (left == right)",
			"                    return cur->val;",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        return cur->lchild ? _pushDown(cur, left, right), self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                    else",
			"                        return cur->rchild ? _pushDown(cur, left, right), self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp query(int __left, int __right) {",
			"            if (__left == __right) return query(__left);",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right) -> _Tp {",
			"                if (__left <= left && __right >= right)",
			"                    return cur->val;",
			"                else {",
			"                    if (int mid = (left + right) / 2; __left > mid)",
			"                        return cur->rchild ? _pushDown(cur, left, right), self(self, cur->rchild, mid + 1, right) : m_defaultValue;",
			"                    else if (__right <= mid)",
			"                        return cur->lchild ? _pushDown(cur, left, right), self(self, cur->lchild, left, mid) : m_defaultValue;",
			"                    else",
			"                        return cur->lchild ? _pushDown(cur, left, right), m_op(self(self, cur->lchild, left, mid), self(self, cur->rchild, mid + 1, right)) : m_defaultValue;",
			"                }",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp queryAll() const {",
			"            return m_root->val;",
			"        }",
			"        int kth(_Tp __k) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right, int k) {",
			"                if (left == right) return left;",
			"                _pushDown(cur, left, right);",
			"                if (cur->lchild->val > k)",
			"                    return self(self, cur->lchild, left, (left + right) / 2, k);",
			"                else",
			"                    return self(self, cur->rchild, (left + right) / 2 + 1, right, k - cur->lchild->val);",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1, __k);",
			"        }",
			"    };",
			"    template <typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    LazySegTree(int = 0, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Fp = _Fp()) -> LazySegTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"    template <typename _Iterator, typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    LazySegTree(_Iterator, _Iterator, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Fp = _Fp()) -> LazySegTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"}",
		],
		"description": "lazy seg tree",
	},
	"lazy zkw tree":{
		"prefix": "LAZY",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct LazyZkwAdd {",
			"        _Tp operator()(const _Fp &__x, const _Tp &__y, int __size) const { return __x * __size + __y; }",
			"    };",
			"    template <typename _Tp = int64_t, typename _Fp = _Tp, typename _Operation = std::plus<_Tp>, typename _Mapping = OY::LazyZkwAdd<_Tp, _Fp>, typename _Composition = std::plus<_Fp>>",
			"    class LazyZkwTree {",
			"        struct _Tp_FpNode {",
			"            _Tp val;",
			"            _Fp inc;",
			"        };",
			"        std::vector<_Tp_FpNode> m_sub;",
			"        int m_length;",
			"        int m_depth;",
			"        _Operation m_op;",
			"        _Mapping m_map;",
			"        _Composition m_com;",
			"        _Tp m_defaultValue;",
			"        _Fp m_defaultIncrement;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue && m_com(m_defaultIncrement, m_defaultIncrement) == m_defaultIncrement);",
			"            // if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>) assert(m_map(m_defaultIncrement, m_defaultValue, 1) == m_defaultValue);",
			"            // else assert(m_map(m_defaultIncrement, m_defaultValue) == m_defaultValue);",
			"        }",
			"        int _size(int i) {",
			"            return 1 << (std::__countl_zero(i) + m_depth - 31);",
			"        }",
			"        void _apply(int i, _Fp inc) {",
			"            if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>)",
			"                m_sub[i].val = m_map(inc, m_sub[i].val, _size(i));",
			"            else",
			"                m_sub[i].val = m_map(inc, m_sub[i].val);",
			"            if (i < 1 << m_depth) m_sub[i].inc = m_com(inc, m_sub[i].inc);",
			"        }",
			"        void _update(int i) {",
			"            m_sub[i].val = m_op(m_sub[i * 2].val, m_sub[i * 2 + 1].val);",
			"        }",
			"        void _pushDown(int i) {",
			"            _apply(i * 2, m_sub[i].inc);",
			"            _apply(i * 2 + 1, m_sub[i].inc);",
			"            m_sub[i].inc = m_defaultIncrement;",
			"        }",
			"",
			"    public:",
			"        LazyZkwTree(int __n = 0, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        LazyZkwTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.resize(1 << (m_depth + 1));",
			"            std::fill(m_sub.begin() + (1 << m_depth), m_sub.end(), _Tp_FpNode{m_defaultValue, m_defaultIncrement});",
			"            for (int i = 1 << m_depth; --i;) {",
			"                _update(i);",
			"                m_sub[i].inc = m_defaultIncrement;",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.resize(1 << (m_depth + 1));",
			"            for (int i = 0; i < m_length; i++) m_sub[(1 << m_depth) + i] = {_Tp(__first[i]), m_defaultIncrement};",
			"            std::fill(m_sub.begin() + (1 << m_depth) + m_length, m_sub.end(), _Tp_FpNode{m_defaultValue, m_defaultIncrement});",
			"            for (int i = 1 << m_depth; --i;) _update(i);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            __i += 1 << m_depth;",
			"            for (int d = m_depth; d; d--) _pushDown(__i >> d);",
			"            m_sub[__i].val = __val;",
			"            while (__i >>= 1) _update(__i);",
			"        }",
			"        void add(int __i, _Fp __inc) {",
			"            __i += 1 << m_depth;",
			"            for (int d = m_depth; d; d--) _pushDown(__i >> d);",
			"            _apply(__i, __inc);",
			"            while (__i /= 2) _update(__i);",
			"        }",
			"        void add(int __left, int __right, _Fp __inc) {",
			"            if (__left == __right) {",
			"                add(__left, __inc);",
			"                return;",
			"            }",
			"            __left += 1 << m_depth;",
			"            __right += 1 << m_depth;",
			"            int j = 31 - std::__countl_zero(__left ^ __right);",
			"            for (int d = m_depth; d > j; d--) _pushDown(__left >> d);",
			"            for (int d = j; d; d--) _pushDown(__left >> d), _pushDown(__right >> d);",
			"            _apply(__left, __inc);",
			"            _apply(__right, __inc);",
			"            while (__left / 2 < __right / 2) {",
			"                if (__left % 2 == 0) _apply(__left + 1, __inc);",
			"                _update(__left /= 2);",
			"                if (__right % 2) _apply(__right - 1, __inc);",
			"                _update(__right /= 2);",
			"            }",
			"            while (__left /= 2) _update(__left);",
			"        }",
			"        _Tp query(int __i) {",
			"            __i += 1 << m_depth;",
			"            for (int d = m_depth; d; d--) _pushDown(__i >> d);",
			"            return m_sub[__i].val;",
			"        }",
			"        _Tp query(int __left, int __right) {",
			"            if (__left == __right) return query(__left);",
			"            __left += 1 << m_depth;",
			"            __right += 1 << m_depth;",
			"            int j = 31 - std::__countl_zero(__left ^ __right);",
			"            for (int d = m_depth; d > j; d--) _pushDown(__left >> d);",
			"            for (int d = j; d; d--) _pushDown(__left >> d), _pushDown(__right >> d);",
			"            _Tp res = m_sub[__left].val;",
			"            for (int i = 0; i < j; i++)",
			"                if (!(__left >> i & 1)) res = m_op(res, m_sub[__left >> i ^ 1].val);",
			"            for (int i = j - 1; i >= 0; i--)",
			"                if (__right >> i & 1) res = m_op(res, m_sub[__right >> i ^ 1].val);",
			"            return m_op(res, m_sub[__right].val);",
			"        }",
			"        _Tp queryAll() const {",
			"            return m_sub[1].val;",
			"        }",
			"        int kth(_Tp __k) {",
			"            int i = 1;",
			"            while (i < 1 << m_depth) {",
			"                _pushDown(i);",
			"                if (m_sub[i *= 2].val <= __k) __k -= m_sub[i++].val;",
			"            }",
			"            return i - (1 << m_depth);",
			"        }",
			"    };",
			"    template <typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    LazyZkwTree(int = 0, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Tp = _Tp(), _Fp = _Fp()) -> LazyZkwTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"    template <typename _Iterator, typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    LazyZkwTree(_Iterator, _Iterator, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Tp = _Tp(), _Fp = _Fp()) -> LazyZkwTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"}",
		],
		"description": "lazy zkw tree",
	},
	"llrb":{
		"prefix": "LLRB",
		"body": [
			"namespace OY {",
			"    struct LLRBSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct LLRBMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct LLRBMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, typename _Tag>",
			"    struct _LLRBNode;",
			"    template <typename _Tp, typename _Fp>",
			"    struct _LLRBNode<_Tp, _Fp, LLRBSetTag> { _Tp key; };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _LLRBNode<_Tp, _Fp, LLRBMultisetTag> {",
			"        _Tp key;",
			"        int _node_weight;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _LLRBNode<_Tp, _Fp, LLRBMapTag> {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = LLRBMultisetTag>",
			"    class LLRB {",
			"        struct node : _LLRBNode<_Tp, _Fp, _Tag> {",
			"            int subtree_weight;",
			"            bool node_color;",
			"            node *lchild;",
			"            node *rchild;",
			"            constexpr int node_weight() {",
			"                if constexpr (_Tag::multi_key)",
			"                    return this->_node_weight;",
			"                else",
			"                    return 1;",
			"            }",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static int node_weight(node *p) { return p ? p->node_weight() : 0; }",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->node_weight() + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static bool is_red(const node *p) { return p && p->node_color; }",
			"        static bool neg_node_color(bool b) { return !b; }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            q->node_color = p->node_color;",
			"            p->node_color = true;",
			"            return q;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            q->node_color = p->node_color;",
			"            p->node_color = true;",
			"            return q;",
			"        }",
			"        static node *rrotate_flip(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            p->rchild->node_color = true;",
			"            p->node_color = false;",
			"            q->rchild = update(p);",
			"            q->node_color = true;",
			"            q->lchild->node_color = false;",
			"            return q;",
			"        }",
			"        static node *rlrotate_flip(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            p->node_color = false;",
			"            p->lchild->node_color = true;",
			"            r->subtree_weight = p->subtree_weight;",
			"            r->node_color = true;",
			"            r->lchild = p;",
			"            r->rchild = update(q);",
			"            return r;",
			"        }",
			"        static node *node_color_flip(node *p) {",
			"            p->node_color = neg_node_color(p->node_color);",
			"            p->lchild->node_color = neg_node_color(p->lchild->node_color);",
			"            p->rchild->node_color = neg_node_color(p->rchild->node_color);",
			"            return p;",
			"        }",
			"        static node *move_red_right(node *cur) {",
			"            if (is_red(cur->lchild->lchild))",
			"                return rrotate_flip(cur);",
			"            else",
			"                return node_color_flip(cur);",
			"        }",
			"        static node *move_red_left(node *cur) {",
			"            if (is_red(cur->rchild->lchild))",
			"                return rlrotate_flip(cur);",
			"            else",
			"                return node_color_flip(cur);",
			"        }",
			"        static node *balance(node *cur) {",
			"            if (is_red(cur->rchild) && !is_red(cur->lchild))",
			"                cur = lrotate(cur);",
			"            if (is_red(cur->lchild) && is_red(cur->lchild->lchild))",
			"                cur = rrotate(cur);",
			"            if (is_red(cur->lchild) && is_red(cur->rchild))",
			"                node_color_flip(cur);",
			"            return update(cur);",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (cur->lchild == nullptr) {",
			"                res->key = cur->key;",
			"                if constexpr (_Tag::multi_key)",
			"                    res->_node_weight = cur->_node_weight;",
			"                delete cur;",
			"                return nullptr;",
			"            }",
			"            if (!is_red(cur->lchild) && !is_red(cur->lchild->lchild)) cur = move_red_left(cur);",
			"            cur->lchild = deleteMin(cur->lchild, res);",
			"            return balance(cur);",
			"        }",
			"        template <typename... Args>",
			"        node *_insert(node *cur, _Tp key, Args... args) {",
			"            if (cur == nullptr) return new node{key, args..., 1, true, nullptr, nullptr};",
			"            if (m_comp(key, cur->key))",
			"                cur->lchild = _insert(cur->lchild, key, args...);",
			"            else if (m_comp(cur->key, key))",
			"                cur->rchild = _insert(cur->rchild, key, args...);",
			"            else {",
			"                if constexpr (_Tag::multi_key) {",
			"                    cur->_node_weight++;",
			"                    cur->subtree_weight++;",
			"                }",
			"            }",
			"            return balance(cur);",
			"        }",
			"        node *deleteArbitrary(node *cur, _Tp key) {",
			"            if (m_comp(key, cur->key)) {",
			"                if (!is_red(cur->lchild) && !is_red(cur->lchild->lchild)) cur = move_red_left(cur);",
			"                cur->lchild = deleteArbitrary(cur->lchild, key);",
			"            } else {",
			"                if (is_red(cur->lchild)) cur = rrotate(cur);",
			"                if (!m_comp(cur->key, key) && !cur->rchild) {",
			"                    delete cur;",
			"                    return nullptr;",
			"                }",
			"                if (!is_red(cur->rchild) && !is_red(cur->rchild->lchild)) cur = move_red_right(cur);",
			"                if (m_comp(cur->key, key))",
			"                    cur->rchild = deleteArbitrary(cur->rchild, key);",
			"                else",
			"                    cur->rchild = deleteMin(cur->rchild, cur);",
			"            }",
			"            return balance(cur);",
			"        }",
			"        int decrease(node *cur, _Tp key) {",
			"            if (!cur) return 0;",
			"            int old;",
			"            if (m_comp(key, cur->key))",
			"                old = decrease(cur->lchild, key);",
			"            else if (m_comp(cur->key, key))",
			"                old = decrease(cur->rchild, key);",
			"            else {",
			"                old = cur->node_weight();",
			"                if constexpr (_Tag::multi_key) cur->_node_weight--;",
			"            }",
			"            if (old) cur->subtree_weight--;",
			"            return old;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        LLRB(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        ~LLRB() { clear(); }",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(Args... __args) {",
			"            if constexpr (_Tag::multi_key)",
			"                m_root = _insert(m_root, __args..., 1);",
			"            else",
			"                m_root = _insert(m_root, __args...);",
			"            m_root->node_color = false;",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            if (int old = decrease(m_root, __key); old == 1) {",
			"                if (!is_red(m_root->lchild) && !is_red(m_root->rchild)) m_root->node_color = true;",
			"                if (m_root = deleteArbitrary(m_root, __key)) m_root->node_color = false;",
			"                return true;",
			"            } else",
			"                return old;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord += cur->node_weight();",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + cur->node_weight(); __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            node *x = m_root;",
			"            while (x != nullptr) {",
			"                if (__key == x->key) return x;",
			"                if (m_comp(__key, x->key))",
			"                    x = x->lchild;",
			"                else",
			"                    x = x->rchild;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const { return node_weight(find(__key)); }",
			"    };",
			"    namespace LLRBContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = LLRB<_Tp, bool, _Compare, LLRBSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = LLRB<_Tp, bool, _Compare, LLRBMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = LLRB<_Tp, _Fp, _Compare, LLRBMapTag>;",
			"    }",
			"}",
		],
		"description": "llrb tree"
	},
	"memory pool":{
		"prefix": "POOL",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, int batch = 1 << 15>",
			"    struct MemoryPool {",
			"        static inline std::vector<_Tp *> s_pool;",
			"        static inline std::vector<_Tp *> s_gc;",
			"        static inline _Tp *s_cursor = nullptr;",
			"        static inline _Tp *s_end = nullptr;",
			"        static void _reserve(int __count = batch) {",
			"            s_pool.push_back((_Tp *)malloc(__count * sizeof(_Tp)));",
			"            s_cursor = s_pool.back();",
			"            s_end = s_cursor + __count;",
			"        }",
			"        static void *operator new(size_t) {",
			"            if (s_gc.size()) {",
			"                auto it = s_gc.back();",
			"                s_gc.pop_back();",
			"                return it;",
			"            } else if (s_cursor == s_end)",
			"                _reserve();",
			"            return s_cursor++;",
			"        }",
			"        static void operator delete(void *it) { s_gc.push_back((_Tp *)it); }",
			"        static void recycle(_Tp *it) { s_gc.push_back(it); }",
			"    };",
			"}",
		],
		"description": "memory pool"
	},
	"pb_ds tree":{
		"prefix": "PBDS",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"namespace OY {",
			"    struct PB_DS_TreeSetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    struct PB_DS_TreeMultisetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = true;",
			"    };",
			"    struct PB_DS_TreeMapTag {",
			"        static constexpr bool is_map = true;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    template <typename _Compare, bool multi_key>",
			"    struct PB_DS_less_equal {",
			"        _Compare __comp;",
			"        PB_DS_less_equal(_Compare __comp = _Compare()) : __comp(__comp) {}",
			"        template <typename _Tp, typename _Fp>",
			"        bool operator()(const _Tp &x, const _Fp &y) const {",
			"            if (multi_key)",
			"                return !__comp(y.key, x.key);",
			"            else",
			"                return __comp(x.key, y.key);",
			"        }",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PB_DS_TreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PB_DS_TreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = int, typename _Compare = std::less<_Tp>, typename _Tag = PB_DS_TreeMultisetTag>",
			"    class PB_DS_Tree {",
			"    public:",
			"        using node = _PB_DS_TreeNode<_Tp, _Fp, _Tag::is_map>;",
			"        using iterator = typename __gnu_pbds::tree<node, __gnu_pbds::null_type, PB_DS_less_equal<_Compare, _Tag::multi_key>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>::iterator;",
			"        __gnu_pbds::tree<node, __gnu_pbds::null_type, PB_DS_less_equal<_Compare, _Tag::multi_key>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> m_tree;",
			"        _Compare m_comp;",
			"        static node makeNode(_Tp __key) {",
			"            if constexpr (_Tag::is_map)",
			"                return {__key, _Fp()};",
			"            else",
			"                return {__key};",
			"        }",
			"",
			"    public:",
			"        PB_DS_Tree(_Compare __comp = _Compare()) : m_comp(__comp), m_tree(__comp) {}",
			"        void clear() { m_tree.clear(); }",
			"        template <typename... Args>",
			"        void insert(Args... __args) {",
			"            m_tree.insert({__args...});",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key); p != end())",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        void erase(_Tp __key) { m_tree.erase(find(__key)); }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            for (auto it = find(__count); __count-- && it != end() && !m_comp(__key, it->key);) it = m_tree.erase(it);",
			"        }",
			"        int rank(_Tp __key) const { return m_tree.order_of_key(makeNode(__key)); }",
			"        iterator kth(int __k) const { return m_tree.find_by_order(__k); }",
			"        iterator find(_Tp __key) const {",
			"            if (auto p = lower_bound(__key); p != end() && !m_comp(__key, p->key))",
			"                return p;",
			"            else",
			"                return m_tree.end();",
			"        }",
			"        iterator lower_bound(_Tp __key) const {",
			"            if constexpr (_Tag::multi_key)",
			"                return m_tree.upper_bound(makeNode(__key));",
			"            else",
			"                return m_tree.lower_bound(makeNode(__key));",
			"        }",
			"        iterator upper_bound(_Tp __key) const {",
			"            if constexpr (_Tag::multi_key)",
			"                return m_tree.lower_bound(makeNode(__key));",
			"            else",
			"                return m_tree.upper_bound(makeNode(__key));",
			"        }",
			"        iterator smaller_bound(_Tp __key) const { return prev(lower_bound(__key)); }",
			"        int size() const { return m_tree.size(); }",
			"        bool empty() const { return !size(); }",
			"        iterator end() const { return m_tree.end(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (it1 == end()) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if constexpr (!_Tag::multi_key)",
			"                return it2 != it1;",
			"            else {",
			"                if (it2 == end())",
			"                    return size() - rank(__key);",
			"                else",
			"                    return rank(it2->key) - rank(__key);",
			"            }",
			"        }",
			"    };",
			"    namespace PB_DS_TreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PB_DS_Tree<_Tp, bool, _Compare, PB_DS_TreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PB_DS_Tree<_Tp, __gnu_pbds::null_type, _Compare, PB_DS_TreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PB_DS_Tree<_Tp, _Fp, _Compare, PB_DS_TreeMapTag>;",
			"    }",
			"}",
		],
		"description": "pb_ds tree(rb tree)"
	},
	"persistent avl":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentAVLSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentAVLMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentAVLMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentAVLNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentAVLNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentAVLMultisetTag>",
			"    class PersistentAVL {",
			"#pragma pack(4)",
			"        struct node : _PersistentAVLNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            int subtree_height;",
			"            uint32_t time_stamp;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static inline uint32_t s_timer = 0;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int subtree_height(node *p) { return p ? p->subtree_height : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if (p->time_stamp == s_timer) {",
			"                p->lchild = l;",
			"                p->rchild = r;",
			"                return p;",
			"            }",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, 1, 1, s_timer, l, r};",
			"            else",
			"                return new node{p->key, 1, 1, s_timer, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            p->subtree_height = 1 + std::max(subtree_height(p->lchild), subtree_height(p->rchild));",
			"            return p;",
			"        }",
			"        static node *balance(node *cur) {",
			"            if (int lh = subtree_height(cur->lchild), rh = subtree_height(cur->rchild); lh > rh + 1) {",
			"                if (node *l = cur->lchild, *lr = l->rchild; subtree_height(lr) > rh)",
			"                    return update(raw_copy(lr, update(raw_copy(l, l->lchild, lr->lchild)), update(raw_copy(cur, lr->rchild, cur->rchild))));",
			"                else",
			"                    return update(raw_copy(l, l->lchild, update(raw_copy(cur, l->rchild, cur->rchild))));",
			"            } else if (rh > lh + 1) {",
			"                if (node *r = cur->rchild, *rl = r->lchild; subtree_height(rl) > lh)",
			"                    return update(raw_copy(rl, update(raw_copy(cur, cur->lchild, rl->lchild)), update(raw_copy(r, rl->rchild, r->rchild))));",
			"                else",
			"                    return update(raw_copy(r, update(raw_copy(cur, cur->lchild, r->lchild)), r->rchild));",
			"            } else",
			"                return update(cur);",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else",
			"                return balance(raw_copy(cur, deleteMin(cur->lchild, res), cur->rchild));",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentAVL(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentAVL() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, 1, s_timer + 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r)) : cur;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            s_timer += 2;",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __value, 1, 1, s_timer + 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key))",
			"                    return balance(raw_copy(cur, self(self, cur->lchild), cur->rchild));",
			"                else if (m_comp(cur->key, __key))",
			"                    return balance(raw_copy(cur, cur->lchild, self(self, cur->rchild)));",
			"                else {",
			"                    node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                    p->value = __value;",
			"                    return p;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            s_timer += 2;",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r)) : cur;",
			"                } else {",
			"                    res = true;",
			"                    if (!cur->rchild)",
			"                        return cur->lchild;",
			"                    node *res, *r = deleteMin(cur->rchild, res);",
			"                    return update(raw_copy(res, cur->lchild, r));",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        void copyVersion(int __version) { m_roots.push_back(_root(__version)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = _root(__version); cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            node *cur = _root(__version);",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentAVLContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentAVL<_Tp, bool, _Compare, PersistentAVLSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentAVL<_Tp, bool, _Compare, PersistentAVLMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentAVL<_Tp, _Fp, _Compare, PersistentAVLMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent avl"
	},
	"persistent B tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentBTreeSetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    struct PersistentBTreeMultisetTag {",
			"        static constexpr bool is_map = false;",
			"        static constexpr bool multi_key = true;",
			"    };",
			"    struct PersistentBTreeMapTag {",
			"        static constexpr bool is_map = true;",
			"        static constexpr bool multi_key = false;",
			"    };",
			"    template <typename _Compare>",
			"    struct PersistentBTreeLess {",
			"        _Compare __comp;",
			"        PersistentBTreeLess(_Compare __comp = _Compare()) : __comp(__comp) {}",
			"        template <typename _Tp>",
			"        bool operator()(const _Tp &x, const _Tp &y) const { return __comp(x.key, y.key); }",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentBTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentBTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = int, typename _Compare = std::less<_Tp>, typename _Tag = PersistentBTreeMultisetTag, int _K = 3>",
			"    class PersistentBTree {",
			"        using node = _PersistentBTreeNode<_Tp, _Fp, _Tag::is_map>;",
			"        struct block : MemoryPool<block> {",
			"            node keys[_K * 2 - 1];",
			"            int keyNum;",
			"            node min;",
			"            node max;",
			"            int weight;",
			"            block *child[_K * 2];",
			"            block() { child[0] = nullptr; }",
			"            block(const node &item) {",
			"                keys[0] = min = max = item;",
			"                keyNum = weight = 1;",
			"                child[0] = nullptr;",
			"            }",
			"            void push_front(node key, block *p) {",
			"                std::copy_backward(keys, keys + keyNum, keys + keyNum + 1);",
			"                if (child[0]) std::copy_backward(child, child + keyNum + 1, child + keyNum + 2);",
			"                keys[0] = key;",
			"                child[0] = p;",
			"                keyNum++;",
			"            }",
			"            void push_back(node key, block *p) {",
			"                keys[keyNum] = key;",
			"                child[keyNum + 1] = p;",
			"                keyNum++;",
			"            }",
			"            void pop_front() {",
			"                std::copy(keys + 1, keys + keyNum, keys);",
			"                bool is_leaf = !child[0];",
			"                std::copy(child + 1, child + keyNum + 1, child);",
			"                if (is_leaf) child[0] = nullptr;",
			"                keyNum--;",
			"            }",
			"            void pop_back() { keyNum--; }",
			"            void erase(int pos) {",
			"                if (pos + 1 < keyNum) {",
			"                    std::copy(keys + pos + 1, keys + keyNum, keys + pos);",
			"                    std::copy(child + pos + 2, child + keyNum + 1, child + pos + 1);",
			"                }",
			"                keyNum--;",
			"            }",
			"            void insertKey(int pos, node key) {",
			"                if (pos < keyNum)",
			"                    std::copy_backward(keys + pos, keys + keyNum, keys + keyNum + 1);",
			"                keys[pos] = key;",
			"                keyNum++;",
			"            }",
			"            void eraseKey(int pos) {",
			"                if (pos + 1 < keyNum)",
			"                    std::copy(keys + pos + 1, keys + keyNum, keys + pos);",
			"                keyNum--;",
			"            }",
			"            void updateMinMax() {",
			"                if (!child[0]) {",
			"                    min = keys[0];",
			"                    max = keys[keyNum - 1];",
			"                } else {",
			"                    min = child[0]->min;",
			"                    max = child[keyNum]->max;",
			"                }",
			"            }",
			"        };",
			"        PersistentBTreeLess<_Compare> m_comp;",
			"        std::vector<block *> m_roots;",
			"        static node makeNode(_Tp __key) {",
			"            if constexpr (_Tag::is_map)",
			"                return {__key, _Fp()};",
			"            else",
			"                return {__key};",
			"        }",
			"        static void getLeftLast(block *parent, int pos) {",
			"            block *left = new block{*parent->child[pos - 1]};",
			"            block *old_right = parent->child[pos];",
			"            block *right = new block;",
			"            bool is_leaf = !old_right->child[0];",
			"            right->keys[0] = parent->keys[pos - 1]; //  p1->keys[p1->keyNum];",
			"            right->child[0] = left->child[left->keyNum];",
			"            parent->keys[pos - 1] = left->keys[left->keyNum - 1];",
			"            left->pop_back();",
			"            std::copy(old_right->keys, old_right->keys + old_right->keyNum, right->keys + 1);",
			"            std::copy(old_right->child, old_right->child + old_right->keyNum + 1, right->child + 1);",
			"            int w = is_leaf ? 1 : right->child[0]->weight + 1;",
			"            left->max = is_leaf ? left->keys[left->keyNum - 1] : left->child[left->keyNum]->max;",
			"            left->weight -= w;",
			"            right->min = is_leaf ? right->keys[0] : right->child[0]->min;",
			"            right->max = old_right->max;",
			"            right->weight = old_right->weight + w;",
			"            right->keyNum = old_right->keyNum + 1;",
			"            parent->child[pos - 1] = left;",
			"            parent->child[pos] = right;",
			"        }",
			"        static void getRightFirst(block *parent, int pos) {",
			"            block *left = new block{*parent->child[pos]};",
			"            block *old_right = parent->child[pos + 1];",
			"            block *right = new block;",
			"            bool is_leaf = !old_right->child[0];",
			"            int w = is_leaf ? 1 : old_right->child[0]->weight + 1;",
			"            left->push_back(parent->keys[pos], old_right->child[0]);",
			"            parent->keys[pos] = old_right->keys[0];",
			"            std::copy(old_right->keys + 1, old_right->keys + old_right->keyNum, right->keys);",
			"            std::copy(old_right->child + 1, old_right->child + old_right->keyNum + 1, right->child);",
			"            left->max = is_leaf ? left->keys[left->keyNum - 1] : left->child[left->keyNum]->max;",
			"            left->weight += w;",
			"            right->min = is_leaf ? right->keys[0] : right->child[0]->min;",
			"            right->max = old_right->max;",
			"            right->weight = old_right->weight - w;",
			"            right->keyNum = old_right->keyNum - 1;",
			"            parent->child[pos] = left;",
			"            parent->child[pos + 1] = right;",
			"        }",
			"        static void mergeAt(block *parent, int pos) {",
			"            block *left = parent->child[pos];",
			"            block *right = parent->child[pos + 1];",
			"            block *now = new block;",
			"            std::copy(left->keys, left->keys + _K - 1, now->keys);",
			"            now->keys[_K - 1] = parent->keys[pos];",
			"            std::copy(right->keys, right->keys + _K - 1, now->keys + _K);",
			"            std::copy(left->child, left->child + _K, now->child);",
			"            std::copy(right->child, right->child + _K, now->child + _K);",
			"            now->min = left->min;",
			"            now->max = right->max;",
			"            now->keyNum = _K * 2 - 1;",
			"            now->weight = left->weight + right->weight + 1;",
			"            parent->child[pos] = now;",
			"            parent->erase(pos);",
			"        }",
			"        static void splitAt(block *old, block *parent, int pos) {",
			"            block *left = new block;",
			"            block *right = new block;",
			"            left->keyNum = right->keyNum = _K - 1;",
			"            std::copy(old->keys, old->keys + _K - 1, left->keys);",
			"            std::copy(old->keys + _K, old->keys + (_K * 2 - 1), right->keys);",
			"            if (old->child[0]) {",
			"                int w = _K - 1;",
			"                std::copy(old->child, old->child + _K, left->child);",
			"                for (int i = 0; i < _K; i++) {",
			"                    right->child[i] = old->child[_K + i];",
			"                    w += right->child[i]->weight;",
			"                }",
			"                right->min = right->child[0]->min;",
			"                right->max = old->max;",
			"                right->weight = w;",
			"                left->min = old->min;",
			"                left->max = old->child[_K - 1]->max;",
			"                left->weight = old->weight - (w + 1);",
			"            } else {",
			"                right->min = right->keys[0];",
			"                right->max = old->max;",
			"                right->weight = _K - 1;",
			"                left->min = old->min;",
			"                left->max = left->keys[_K - 2];",
			"                left->weight = _K - 1;",
			"            }",
			"            parent->keys[pos] = old->keys[_K - 1];",
			"            parent->child[pos] = left;",
			"            parent->child[pos + 1] = right;",
			"            parent->keyNum++;",
			"        }",
			"        block *_insert(block *cur, const node &item, bool &res) {",
			"            int pos = std::upper_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys;",
			"            if constexpr (!_Tag::multi_key)",
			"                if (pos && !m_comp(cur->keys[pos - 1], item)) return cur;",
			"            if (!cur->child[0]) {",
			"                res = true;",
			"                cur->insertKey(pos, item);",
			"            } else {",
			"                if (cur->child[pos]->keyNum == _K * 2 - 1) {",
			"                    if (pos < cur->keyNum) {",
			"                        std::copy_backward(cur->keys + pos, cur->keys + cur->keyNum, cur->keys + cur->keyNum + 1);",
			"                        std::copy_backward(cur->child + pos + 1, cur->child + cur->keyNum + 1, cur->child + cur->keyNum + 2);",
			"                    }",
			"                    splitAt(cur->child[pos], cur, pos);",
			"                    if (m_comp(cur->keys[pos], item)) pos++;",
			"                    cur->child[pos] = _insert(cur->child[pos], item, res);",
			"                } else",
			"                    cur->child[pos] = _insert(new block{*cur->child[pos]}, item, res);",
			"            }",
			"            if (res) {",
			"                cur->weight++;",
			"                cur->updateMinMax();",
			"            }",
			"            return cur;",
			"        }",
			"        block *_update(block *cur, const node &item, bool &res) {",
			"            int pos = std::upper_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys;",
			"            if constexpr (!_Tag::multi_key)",
			"                if (pos && !m_comp(cur->keys[pos - 1], item)) {",
			"                    node *p = new block(*cur);",
			"                    p->keys[pos - 1] = item;",
			"                    return p;",
			"                }",
			"            if (!cur->child[0]) {",
			"                res = true;",
			"                cur->insertKey(pos, item);",
			"            } else {",
			"                if (cur->child[pos]->keyNum == _K * 2 - 1) {",
			"                    if (pos < cur->keyNum) {",
			"                        std::copy_backward(cur->keys + pos, cur->keys + cur->keyNum, cur->keys + cur->keyNum + 1);",
			"                        std::copy_backward(cur->child + pos + 1, cur->child + cur->keyNum + 1, cur->child + cur->keyNum + 2);",
			"                    }",
			"                    splitAt(cur->child[pos], cur, pos);",
			"                    if (m_comp(cur->keys[pos], item)) pos++;",
			"                    cur->child[pos] = _insert(cur->child[pos], item, res);",
			"                } else",
			"                    cur->child[pos] = _insert(new block{*cur->child[pos]}, item, res);",
			"            }",
			"            if (res) cur->weight++;",
			"            cur->updateMinMax();",
			"            return cur;",
			"        }",
			"        block *_erase(block *cur, const node &item, bool &res) {",
			"            if (int pos = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys; pos == cur->keyNum || m_comp(item, cur->keys[pos])) {",
			"                if (!cur->child[0]) return cur;",
			"                if (cur->child[pos]->keyNum == _K - 1) {",
			"                    if (pos && cur->child[pos - 1]->keyNum >= _K)",
			"                        getLeftLast(cur, pos);",
			"                    else if (pos < cur->keyNum && cur->child[pos + 1]->keyNum >= _K)",
			"                        getRightFirst(cur, pos);",
			"                    else {",
			"                        if (pos) pos--;",
			"                        mergeAt(cur, pos);",
			"                        if (!cur->keyNum) return _erase(cur->child[0], item, res);",
			"                    }",
			"                } else",
			"                    cur->child[pos] = new block{*cur->child[pos]};",
			"                cur->child[pos] = _erase(cur->child[pos], item, res);",
			"                if (res) {",
			"                    cur->weight--;",
			"                    cur->updateMinMax();",
			"                }",
			"                return cur;",
			"            } else {",
			"                res = true;",
			"                if (!--cur->weight) {",
			"                    delete cur;",
			"                    return nullptr;",
			"                }",
			"                if (!cur->child[0]) {",
			"                    cur->eraseKey(pos);",
			"                    cur->updateMinMax();",
			"                } else if (cur->child[pos]->keyNum >= _K) {",
			"                    node leftMax = cur->child[pos]->max;",
			"                    cur->keys[pos] = leftMax;",
			"                    cur->child[pos] = _erase(new block{*cur->child[pos]}, leftMax, res);",
			"                } else if (pos < cur->keyNum && cur->child[pos + 1]->keyNum >= _K) {",
			"                    node rightMin = cur->child[pos + 1]->min;",
			"                    cur->keys[pos] = rightMin;",
			"                    cur->child[pos + 1] = _erase(new block{*cur->child[pos + 1]}, rightMin, res);",
			"                } else {",
			"                    mergeAt(cur, pos);",
			"                    if (!cur->keyNum) return _erase(cur->child[0], item, res);",
			"                    cur->child[pos] = _erase(new block{*cur->child[pos]}, item, res);",
			"                }",
			"                return cur;",
			"            }",
			"        }",
			"        block *&_root(int version) { return ~version ? m_roots[version] : m_roots.back(); }",
			"        block *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { block::_reserve(__count); }",
			"        PersistentBTree(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentBTree() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, Args... __args) {",
			"            block *root = _root(__prevVersion);",
			"            const node &item = node{__args...};",
			"            bool res = false;",
			"            if (!root)",
			"                root = new block(item);",
			"            else {",
			"                if (root->keyNum == _K * 2 - 1) {",
			"                    block *p = new block;",
			"                    p->keyNum = 0;",
			"                    p->child[0] = root;",
			"                    p->weight = root->weight;",
			"                    splitAt(root, p, 0);",
			"                    root = _insert(p, item, res);",
			"                } else",
			"                    root = _insert(new block{*root}, item, res);",
			"            }",
			"            m_roots.push_back(root);",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            block *root = _root(__prevVersion);",
			"            const node &item = node{__key, __value};",
			"            bool res = false;",
			"            if (!root)",
			"                root = new block(item);",
			"            else {",
			"                if (root->keyNum == _K * 2 - 1) {",
			"                    block *p = new block;",
			"                    p->keyNum = 0;",
			"                    p->child[0] = root;",
			"                    p->weight = root->weight;",
			"                    splitAt(root, p, 0);",
			"                    root = _update(p, item, res);",
			"                } else",
			"                    root = _update(new block{*root}, item, res);",
			"            }",
			"            m_roots.push_back(root);",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            m_roots.push_back(_root(__prevVersion) ? _erase(new block{*_root(__prevVersion)}, makeNode(__key), res) : nullptr);",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            node item = makeNode(__key);",
			"            int ord = 0;",
			"            while (cur) {",
			"                int pos = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys;",
			"                ord += pos;",
			"                if (!cur->child[0]) break;",
			"                for (int i = 0; i < pos; i++) ord += cur->child[i]->weight;",
			"                cur = cur->child[pos];",
			"            }",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int k) const {",
			"            block *cur = _root(__version);",
			"            for (int i; cur->child[0]; cur = cur->child[i])",
			"                for (i = 0; k >= cur->child[i]->weight; i++) {",
			"                    k -= cur->child[i]->weight;",
			"                    if (!k--) return cur->keys + i;",
			"                }",
			"            return cur->keys + k;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            node item = makeNode(__key);",
			"            for (int i;; cur = cur->child[i]) {",
			"                if (i = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys; i < cur->keyNum && !m_comp(item, cur->keys[i])) return cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            node item = makeNode(__key);",
			"            for (int i;; cur = cur->child[i]) {",
			"                if (i = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys) res = cur->keys + i - 1;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            node item = makeNode(__key);",
			"            for (int i; cur; cur = i ? cur->child[i - 1] : nullptr) {",
			"                if (i = std::lower_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys; i < cur->keyNum) res = cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            block *cur = _root(__version);",
			"            if (!cur) return nullptr;",
			"            node *res = nullptr;",
			"            node item = makeNode(__key);",
			"            for (int i; cur; cur = cur->child[i]) {",
			"                if (i = std::upper_bound(cur->keys, cur->keys + cur->keyNum, item, m_comp) - cur->keys; i < cur->keyNum) res = cur->keys + i;",
			"                if (!cur->child[0]) break;",
			"            }",
			"            return res;",
			"        }",
			"        int size(int __version) const { return _root(__version) ? _root(__version)->weight : 0; }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if constexpr (!_Tag::multi_key)",
			"                return it2 != it1;",
			"            else {",
			"                if (!it2)",
			"                    return size(__version) - rank(__version, __key);",
			"                else",
			"                    return rank(__version, it2->key) - rank(__version, __key);",
			"            }",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentBTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>, int _K = 6>",
			"        using Set = PersistentBTree<_Tp, bool, _Compare, PersistentBTreeSetTag, _K>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>, int _K = 6>",
			"        using Multiset = PersistentBTree<_Tp, bool, _Compare, PersistentBTreeMultisetTag, _K>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>, int _K = 6>",
			"        using Map = PersistentBTree<_Tp, _Fp, _Compare, PersistentBTreeMapTag, _K>;",
			"    }",
			"}",
		],
		"description": "persistent B tree"
	},
	"persistent lazy tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Fp>",
			"    struct PersistentLazySegAdd {",
			"        _Tp operator()(const _Fp &__x, const _Tp &__y, int __size) const { return __x * __size + __y; }",
			"    };",
			"    template <typename _Tp = int64_t, typename _Fp = _Tp, typename _Operation = std::plus<_Tp>, typename _Mapping = OY::PersistentLazySegAdd<_Tp, _Fp>, typename _Composition = std::plus<_Fp>>",
			"    class PersistentLazySegTree {",
			"        struct _Tp_FpNode : MemoryPool<_Tp_FpNode> {",
			"            _Tp val;",
			"            _Fp inc;",
			"            _Tp_FpNode *lchild;",
			"            _Tp_FpNode *rchild;",
			"            _Tp_FpNode(_Tp _val, _Fp _inc, _Tp_FpNode *_lchild, _Tp_FpNode *_rchild) : val(_val), inc(_inc), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        std::vector<_Tp_FpNode *> m_roots;",
			"        int m_length;",
			"        _Operation m_op;",
			"        _Mapping m_map;",
			"        _Composition m_com;",
			"        _Tp m_defaultValue;",
			"        _Fp m_defaultIncrement;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue && m_com(m_defaultIncrement, m_defaultIncrement) == m_defaultIncrement);",
			"            // if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>) assert(m_map(m_defaultIncrement, m_defaultValue, 1) == m_defaultValue);",
			"            // else assert(m_map(m_defaultIncrement, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _Tp_FpNode *lchild(_Tp_FpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _Tp_FpNode *rchild(_Tp_FpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        _Tp _map(_Fp inc, _Tp val, int length) const {",
			"            if constexpr (std::is_invocable_v<_Mapping, _Fp, _Tp, int>)",
			"                return m_map(inc, val, length);",
			"            else",
			"                return m_map(inc, val);",
			"        }",
			"        _Tp_FpNode *_update(_Tp_FpNode *cur, int length) {",
			"            cur->val = _map(cur->inc, m_op(cur->lchild ? cur->lchild->val : m_defaultValue, cur->rchild ? cur->rchild->val : m_defaultValue), length);",
			"            return cur;",
			"        }",
			"        _Tp_FpNode *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"        void _clear() { m_roots.clear(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_Tp_FpNode>::_reserve(__count); }",
			"        PersistentLazySegTree(int __n = 0, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        PersistentLazySegTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Mapping __map = _Mapping(), _Composition __com = _Composition(), _Tp __defaultValue = _Tp(), _Fp __defaultIncrement = _Fp()) : m_op(__op), m_map(__map), m_com(__com), m_defaultValue(__defaultValue), m_defaultIncrement(__defaultIncrement) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        ~PersistentLazySegTree() { _clear(); }",
			"        void resize(int __n) {",
			"            _clear();",
			"            if (m_length = __n) m_roots.push_back(new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr));",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            _clear();",
			"            m_length = __last - __first;",
			"            auto dfs = [&](auto self, _Iterator first, _Iterator last) -> _Tp_FpNode * {",
			"                if (first + 1 == last)",
			"                    return new _Tp_FpNode(*first, m_defaultIncrement, nullptr, nullptr);",
			"                else",
			"                    return _update(new _Tp_FpNode(*first, m_defaultIncrement, self(self, first, first + (last - first + 1) / 2), self(self, first + (last - first + 1) / 2, last)), last - first);",
			"            };",
			"            m_roots.push_back(dfs(dfs, __first, __last));",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        void add(int __prevVersion, int __i, _Fp __inc) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *prev, int left, int right) -> _Tp_FpNode * {",
			"                _Tp_FpNode *cur = prev ? new _Tp_FpNode(*prev) : new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"                if (left == right) {",
			"                    cur->val = _map(__inc, cur->val, 1);",
			"                    cur->inc = m_com(__inc, cur->inc);",
			"                } else {",
			"                    if (__i <= (left + right) / 2)",
			"                        cur->lchild = self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur, right - left + 1);",
			"                }",
			"                return cur;",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion), 0, m_length - 1));",
			"        }",
			"        void add(int __prevVersion, int __left, int __right, _Fp __inc) {",
			"            auto dfs = [&](auto self, _Tp_FpNode *prev, int left, int right) -> _Tp_FpNode * {",
			"                _Tp_FpNode *cur = prev ? new _Tp_FpNode(*prev) : new _Tp_FpNode(m_defaultValue, m_defaultIncrement, nullptr, nullptr);",
			"                if (left >= __left && right <= __right) {",
			"                    cur->val = _map(__inc, cur->val, right - left + 1);",
			"                    cur->inc = m_com(__inc, cur->inc);",
			"                } else {",
			"                    if (__left <= (left + right) / 2)",
			"                        cur->lchild = self(self, cur->lchild, left, (left + right) / 2);",
			"                    if (__right > (left + right) / 2)",
			"                        cur->rchild = self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur, right - left + 1);",
			"                }",
			"                return cur;",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion), 0, m_length - 1));",
			"        }",
			"        _Tp query(int __version, int __i) const {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right, _Fp inc) {",
			"                if (left == right)",
			"                    return _map(inc, cur->val, 1);",
			"                else {",
			"                    inc = m_com(cur->inc, inc);",
			"                    if (__i <= (left + right) / 2)",
			"                        return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2, inc) : _map(inc, m_defaultValue, 1);",
			"                    else",
			"                        return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right, inc) : _map(inc, m_defaultValue, 1);",
			"                }",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1, m_defaultIncrement);",
			"        }",
			"        _Tp query(int __version, int __left, int __right) const {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right, _Fp inc) {",
			"                if (left >= __left && right <= __right)",
			"                    return _map(inc, cur->val, right - left + 1);",
			"                else {",
			"                    inc = m_com(cur->inc, inc);",
			"                    if (__right <= (left + right) / 2)",
			"                        return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2, inc) : _map(inc, m_defaultValue, __right - left + 1);",
			"                    else if (__left > (left + right) / 2)",
			"                        return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right, inc) : _map(inc, m_defaultValue, right - __left + 1);",
			"                    else",
			"                        return _map(inc, m_op(cur->lchild ? self(self, cur->lchild, left, (left + right) / 2, m_defaultIncrement) : m_defaultValue, cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right, m_defaultIncrement) : m_defaultValue), std::min(right, __right) - std::max(left, __left) + 1);",
			"                }",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1, m_defaultIncrement);",
			"        }",
			"        _Tp queryAll(int __version) const {",
			"            return _root(__version)->val;",
			"        }",
			"        int kth(int __version, _Tp __k) const {",
			"            auto dfs = [&](auto self, _Tp_FpNode *cur, int left, int right, int k, _Fp inc) {",
			"                if (left == right) return left;",
			"                inc += cur->inc;",
			"                if (cur->lchild) {",
			"                    if (_Tp lval = cur->lchild->val + inc * ((left + right) / 2 - left + 1); lval > k)",
			"                        return self(self, cur->lchild, left, (left + right) / 2, k, inc);",
			"                    else",
			"                        return self(self, cur->rchild, (left + right) / 2 + 1, right, k - lval, inc);",
			"                } else",
			"                    return self(self, cur->rchild, (left + right) / 2 + 1, right, k, inc);",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1, __k, 0);",
			"        }",
			"        _Tp periodQuery(int __leftVersion, int __rightVersion, int __i) const {",
			"            if (__leftVersion == 0) return query(__rightVersion, __i);",
			"            auto dfs = [&](auto self, _Tp_FpNode *root1, _Tp_FpNode *root2, int left, int right, _Fp inc) {",
			"                if (root1 == root2) return 0;",
			"                if (left == right)",
			"                    return inc + (root1 ? root2->val - root1->val : root2->val);",
			"                else {",
			"                    inc += root2->inc - (root1 ? root1->inc : 0);",
			"                    if (__i <= (left + right) / 2)",
			"                        return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2, inc);",
			"                    else",
			"                        return self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, inc);",
			"                }",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1, 0);",
			"        }",
			"        _Tp periodQuery(int __leftVersion, int __rightVersion, int __left, int __right) const {",
			"            if (__leftVersion == 0) return query(__rightVersion, __left, __right);",
			"            auto dfs = [&](auto self, _Tp_FpNode *root1, _Tp_FpNode *root2, int left, int right, _Fp inc) -> _Tp {",
			"                if (root1 == root2) return 0;",
			"                if (left >= __left && right <= __right)",
			"                    return inc + (root1 ? root2->val - root1->val : root2->val, right - left + 1);",
			"                else {",
			"                    inc += root2->inc + (root1 ? root1->inc : 0);",
			"                    if (__right <= (left + right) / 2)",
			"                        return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2, inc);",
			"                    else if (__left > (left + right) / 2)",
			"                        return self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, inc);",
			"                    else",
			"                        return inc * (std::min(right, __right) - std::max(left, __left) + 1) + self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2, 0) + self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, 0);",
			"                }",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1, 0);",
			"        }",
			"        int periodKth(int __leftVersion, int __rightVersion, _Tp __k) const {",
			"            if (__leftVersion == 0) return kth(__rightVersion, __k);",
			"            auto dfs = [&](auto self, _Tp_FpNode *root1, _Tp_FpNode *root2, int left, int right, int k, _Fp inc) {",
			"                if (left == right) return left;",
			"                inc += (root2 ? root2->inc : 0) - (root1 ? root1->inc : 0);",
			"                if (!root1 || !root1->lchild) {",
			"                    if (!root2->lchild)",
			"                        return self(self, root1 && root1->rchild ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, k, inc);",
			"                    else if (_Tp lval = root2->lchild->val + inc * ((left + right) / 2 - left + 1); lval > k)",
			"                        return self(self, nullptr, root2->lchild, left, (left + right) / 2, k, inc);",
			"                    else",
			"                        return self(self, root1 && root1->rchild ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, k - lval, inc);",
			"                } else if (_Tp lval = root2->lchild->val - root1->lchild->val + inc * ((left + right) / 2 - left + 1); lval > k)",
			"                    return self(self, root1->lchild, root2->lchild, left, (left + right) / 2, k, inc);",
			"                else",
			"                    return self(self, root1->rchild, root2->rchild, (left + right) / 2 + 1, right, k - lval, inc);",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1, __k, 0);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    template <typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    PersistentLazySegTree(int = 0, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Fp = _Fp()) -> PersistentLazySegTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"    template <typename _Iterator, typename _Operation, typename _Mapping, typename _Composition, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>, typename _Fp = std::decay_t<typename decltype(std::mem_fn(&_Composition::operator()))::result_type>>",
			"    PersistentLazySegTree(_Iterator, _Iterator, _Operation = _Operation(), _Mapping = _Mapping(), _Composition = _Composition(), _Tp = _Tp(), _Fp = _Fp()) -> PersistentLazySegTree<_Tp, _Fp, _Operation, _Mapping, _Composition>;",
			"}",
			"",
		],
		"description": "persistent lazy tree"
	},
	"persistent fhq treap":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentFHQTreapSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentFHQTreapMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentFHQTreapMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentFHQTreapNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentFHQTreapNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentFHQTreapMultisetTag>",
			"    class PersistentFHQTreap {",
			"#pragma pack(4)",
			"        struct node : _PersistentFHQTreapNode<_Tp, _Fp, _Tag::is_map> {",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            uint32_t time_stamp;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static inline std::mt19937 s_rand;",
			"        static inline uint32_t s_timer = 0;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if (p->time_stamp == s_timer) {",
			"                p->lchild = l;",
			"                p->rchild = r;",
			"                return p;",
			"            }",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, p->priority, p->subtree_weight, s_timer, l, r};",
			"            else",
			"                return new node{p->key, p->priority, p->subtree_weight, s_timer, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        void split_less(node *p, const _Tp &key, node *&l, node *&r) {",
			"            if (!p)",
			"                l = r = nullptr;",
			"            else if (m_comp(p->key, key)) {",
			"                split_less(p->rchild, key, l, r);",
			"                l = update(raw_copy(p, p->lchild, l));",
			"            } else {",
			"                split_less(p->lchild, key, l, r);",
			"                r = update(raw_copy(p, r, p->rchild));",
			"            }",
			"        }",
			"        void split_less_equal(node *p, const _Tp &key, node *&l, node *&r) {",
			"            if (!p)",
			"                l = r = nullptr;",
			"            else if (m_comp(key, p->key)) {",
			"                split_less_equal(p->lchild, key, l, r);",
			"                r = update(raw_copy(p, r, p->rchild));",
			"            } else {",
			"                split_less_equal(p->rchild, key, l, r);",
			"                l = update(raw_copy(p, p->lchild, l));",
			"            }",
			"        }",
			"        void split_by_key(node *p, const _Tp &key, node *&l, node *&mid, node *&r) {",
			"            if (!p)",
			"                l = mid = r = nullptr;",
			"            else if (m_comp(p->key, key)) {",
			"                split_by_key(p->rchild, key, l, mid, r);",
			"                l = update(raw_copy(p, p->lchild, l));",
			"            } else if (m_comp(key, p->key)) {",
			"                split_by_key(p->lchild, key, l, mid, r);",
			"                r = update(raw_copy(p, r, p->rchild));",
			"            } else {",
			"                node *l_mid, *r_mid;",
			"                split_less(p->lchild, key, l, l_mid);",
			"                split_less_equal(p->rchild, key, r_mid, r);",
			"                mid = update(raw_copy(p, l_mid, r_mid));",
			"            }",
			"        }",
			"        void split_by_rank(node *p, int k, node *&l, node *&r) {",
			"            if (!k) {",
			"                l = nullptr;",
			"                r = p;",
			"            } else if (subtree_weight(p->lchild) > k) {",
			"                split_by_rank(p->lchild, k, l, r);",
			"                r = update(raw_copy(p, r, p->rchild));",
			"            } else if (k -= subtree_weight(p->lchild); !k) {",
			"                l = p->lchild;",
			"                r = update(raw_copy(p, nullptr, p->rchild));",
			"            } else {",
			"                split_by_rank(p->rchild, k - 1, l, r);",
			"                l = update(raw_copy(p, p->lchild, l));",
			"            }",
			"        }",
			"        static node *merge(node *l, node *r) {",
			"            if (!l) return r;",
			"            if (!r) return l;",
			"            if (l->priority > r->priority)",
			"                return update(raw_copy(l, l->lchild, merge(l->rchild, r)));",
			"            else",
			"                return update(raw_copy(r, merge(l, r->lchild), r->rchild));",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        void roll() { s_timer++; }",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentFHQTreap(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentFHQTreap() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            node *l, *r;",
			"            split_less_equal(_root(__prevVersion), __key, l, r);",
			"            if constexpr (!_Tag::multi_key) {",
			"                node *p = l;",
			"                if (p)",
			"                    while (p->rchild) p = p->rchild;",
			"                if (p && !m_comp(p->key, __key)) {",
			"                    m_roots.push_back(_root(__prevVersion));",
			"                    s_timer++;",
			"                    return;",
			"                }",
			"            }",
			"            m_roots.push_back(merge(merge(l, new node{__key, __args..., s_rand(), 1, s_timer + 1, nullptr, nullptr}), r));",
			"            s_timer += 2;",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            node *l, *mid, *r;",
			"            split_by_key(_root(__prevVersion), __key, l, mid, r);",
			"            m_roots.push_back(merge(merge(l, new node{__key, __value, s_rand(), 1, s_timer + 1, nullptr, nullptr}), r));",
			"            s_timer += 2;",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(_root(__prevVersion), __key, l, mid, r);",
			"            if (!mid)",
			"                m_roots.push_back(merge(l, r));",
			"            else",
			"                m_roots.push_back(mid->subtree_weight > 1 ? merge(merge(l, mid->lchild), merge(mid->rchild, r)) : merge(l, r));",
			"            s_timer++;",
			"            return mid;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) {",
			"            node *l, *r;",
			"            split_less(_root(__version), __key, l, r);",
			"            s_timer++;",
			"            return subtree_weight(l);",
			"        }",
			"        const node *kth(int __version, int __k) {",
			"            node *l, *r;",
			"            split_by_rank(_root(__version), __k, l, r);",
			"            node *res = r;",
			"            while (res->lchild) res = res->lchild;",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        const node *find(int __version, _Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(_root(__version), __key, l, mid, r);",
			"            node *res = mid;",
			"            m_roots.push_back(merge(merge(l, mid), r));",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) {",
			"            node *l, *r;",
			"            split_less(_root(__version), __key, l, r);",
			"            node *res = r;",
			"            if (r)",
			"                while (res->lchild) res = res->lchild;",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) {",
			"            node *l, *r;",
			"            split_less_equal(_root(__version), __key, l, r);",
			"            node *res = r;",
			"            if (r)",
			"                while (res->lchild) res = res->lchild;",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) {",
			"            node *l, *r;",
			"            split_less(_root(__version), __key, l, r);",
			"            node *res = l;",
			"            if (l)",
			"                while (res->rchild) res = res->rchild;",
			"            s_timer++;",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) {",
			"            node *l, *mid, *r;",
			"            split_by_key(_root(__version), __key, l, mid, r);",
			"            s_timer++;",
			"            return subtree_weight(mid);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentFHQTreapContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentFHQTreap<_Tp, bool, _Compare, PersistentFHQTreapSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentFHQTreap<_Tp, bool, _Compare, PersistentFHQTreapMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentFHQTreap<_Tp, _Fp, _Compare, PersistentFHQTreapMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent fhq treap"
	},
	"persistent scape goat":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentScapeGoatTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentScapeGoatTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentScapeGoatTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentScapeGoatTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentScapeGoatTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentScapeGoatTreeMultisetTag>",
			"    class PersistentScapeGoatTree {",
			"#pragma pack(4)",
			"        struct node : _PersistentScapeGoatTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            bool node_weight;",
			"            int subtree_weight;",
			"            int subtree_capacity;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>().operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static constexpr int ratio = 4, bias = 4;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int subtree_capacity(node *p) { return p ? p->subtree_capacity : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, p->node_weight, p->subtree_weight, p->subtree_capacity, l, r};",
			"            else",
			"                return new node{p->key, p->node_weight, p->subtree_weight, p->subtree_capacity, l, r};",
			"        }",
			"        static node *raw_copy_true(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, true, p->subtree_weight + 1, p->subtree_capacity, l, r};",
			"            else",
			"                return new node{p->key, true, p->subtree_weight + 1, p->subtree_capacity, l, r};",
			"        }",
			"        static node *raw_copy_false(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, false, p->subtree_weight - 1, p->subtree_capacity, l, r};",
			"            else",
			"                return new node{p->key, false, p->subtree_weight - 1, p->subtree_capacity, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->node_weight + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            p->subtree_capacity = 1 + subtree_capacity(p->lchild) + subtree_capacity(p->rchild);",
			"            return p;",
			"        }",
			"        static void traverse(node *p, node **&s_cursor) {",
			"            if (p->lchild) traverse(p->lchild, s_cursor);",
			"            if (p->node_weight) *s_cursor++ = p;",
			"            if (p->rchild) traverse(p->rchild, s_cursor);",
			"        }",
			"        static node *make_tree(node **first, node **last) {",
			"            if (first == last) return nullptr;",
			"            node **mid = first + (last - first) / 2;",
			"            return update(raw_copy(*mid, make_tree(first, mid), make_tree(mid + 1, last)));",
			"        }",
			"        static node *balance(node *cur) {",
			"            update(cur);",
			"            if (subtree_weight(cur->lchild) <= subtree_weight(cur->rchild) * ratio + bias && subtree_weight(cur->rchild) <= subtree_weight(cur->lchild) * ratio + bias && cur->subtree_capacity * 2 <= cur->subtree_weight * 3) return cur;",
			"            static std::vector<node *> s_buffer;",
			"            static node **s_cursor;",
			"            s_buffer.resize(cur->subtree_weight);",
			"            s_cursor = s_buffer.data();",
			"            traverse(cur, s_cursor);",
			"            return make_tree(s_buffer.data(), s_cursor);",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentScapeGoatTree(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentScapeGoatTree() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., true, 1, 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur->node_weight ? cur : raw_copy_true(cur, cur->lchild, cur->rchild);",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r)) : cur;",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __value, true, 1, 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key))",
			"                    return balance(raw_copy(cur, self(self, cur->lchild), cur->rchild));",
			"                else if (m_comp(cur->key, __key))",
			"                    return balance(raw_copy(cur, cur->lchild, self(self, cur->rchild)));",
			"                else",
			"                    return cur->node_weight ? cur : raw_copy_true(cur, cur->lchild, cur->rchild);",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r)) : cur;",
			"                } else if (cur->node_weight) {",
			"                    res = true;",
			"                    return raw_copy_false(cur, cur->lchild, cur->rchild);",
			"                } else {",
			"                    node *l = self(self, cur->lchild);",
			"                    if (res) return balance(raw_copy(cur, l, cur->rchild));",
			"                    l = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, l)) : cur;",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> int {",
			"                if (!cur)",
			"                    return 0;",
			"                else if (m_comp(cur->key, __key))",
			"                    return subtree_weight(cur->lchild) + cur->node_weight + self(self, cur->rchild);",
			"                else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            auto dfs = [&](auto self, node *cur, int k) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (int l_count = subtree_weight(cur->lchild); k < l_count)",
			"                    return self(self, cur->lchild, k);",
			"                else if (k -= l_count + cur->node_weight; k < 0)",
			"                    return cur;",
			"                else",
			"                    return self(self, cur->rchild, k);",
			"            };",
			"            return dfs(dfs, _root(__version), __k);",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key))",
			"                    return self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    return self(self, cur->rchild);",
			"                else if (cur->node_weight)",
			"                    return cur;",
			"                else if (node *res = self(self, cur->rchild))",
			"                    return res;",
			"                else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key)) {",
			"                    node *res = self(self, cur->lchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->rchild);",
			"                    return res;",
			"                } else if (!m_comp(cur->key, __key) && cur->node_weight)",
			"                    return cur;",
			"                else",
			"                    return self(self, cur->rchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key)) {",
			"                    node *res = self(self, cur->lchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->rchild);",
			"                    return res;",
			"                } else",
			"                    return self(self, cur->rchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(cur->key, __key)) {",
			"                    node *res = self(self, cur->rchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->lchild);",
			"                    return res;",
			"                } else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, _root(__version));",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentScapeGoatContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentScapeGoatTree<_Tp, bool, _Compare, PersistentScapeGoatTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentScapeGoatTree<_Tp, bool, _Compare, PersistentScapeGoatTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentScapeGoatTree<_Tp, _Fp, _Compare, PersistentScapeGoatTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent scape goat tree"
	},
	"persistent size balanced tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentSizeBalancedTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentSizeBalancedTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentSizeBalancedTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentSizeBalancedTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentSizeBalancedTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentSizeBalancedTreeMultisetTag>",
			"    class PersistentSizeBalancedTree {",
			"#pragma pack(4)",
			"        struct node : _PersistentSizeBalancedTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int lchild_weight(node *p) { return p && p->lchild ? p->lchild->subtree_weight : 0; }",
			"        static int rchild_weight(node *p) { return p && p->rchild ? p->rchild->subtree_weight : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, 1, l, r};",
			"            else",
			"                return new node{p->key, 1, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *set_lchild(node *p, node *l) {",
			"            p->lchild = l;",
			"            return p;",
			"        }",
			"        static node *set_rchild(node *p, node *r) {",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *set_lrchild(node *p, node *l, node *r) {",
			"            p->lchild = l;",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p, int d) {",
			"            if (node *q = p->lchild; !d)",
			"                return set_rchild(q, update(set_lchild(p, q->rchild)));",
			"            else",
			"                return raw_copy(q, q->lchild, update(set_lchild(p, q->rchild)));",
			"        }",
			"        static node *lrotate(node *p, int d) {",
			"            if (node *q = p->rchild; !d)",
			"                return set_lchild(q, update(set_rchild(p, q->lchild)));",
			"            else",
			"                return raw_copy(q, update(set_rchild(p, q->lchild)), q->rchild);",
			"        }",
			"        static node *lrrotate(node *p, int d) {",
			"            if (node *l = p->lchild, *lr = l->rchild; !d)",
			"                return set_lrchild(lr, update(set_rchild(l, lr->lchild)), update(set_lchild(p, lr->rchild)));",
			"            else if (d == 1)",
			"                return raw_copy(lr, update(raw_copy(l, l->lchild, lr->lchild)), update(set_lchild(p, lr->rchild)));",
			"            else",
			"                return raw_copy(lr, update(raw_copy(l, l->lchild, lr->lchild)), update(raw_copy(p, lr->rchild, p->rchild)));",
			"        }",
			"        static node *rlrotate(node *p, int d) {",
			"            if (node *r = p->rchild, *rl = r->lchild; !d)",
			"                return set_lrchild(rl, update(set_rchild(p, rl->lchild)), update(set_lchild(r, rl->rchild)));",
			"            else if (d == 1)",
			"                return raw_copy(rl, update(set_rchild(p, rl->lchild)), update(raw_copy(r, rl->rchild, r->rchild)));",
			"            else",
			"                return raw_copy(rl, update(raw_copy(p, p->lchild, rl->lchild)), update(raw_copy(r, rl->rchild, r->rchild)));",
			"        }",
			"        static node *lbalance(node *cur, int d) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->lchild) < lchild_weight(cur->rchild))",
			"                cur = rlrotate(cur, d);",
			"            else if (subtree_weight(cur->lchild) < rchild_weight(cur->rchild))",
			"                cur = lrotate(cur, d);",
			"            else",
			"                return update(cur);",
			"            return rbalance(lbalance(set_lrchild(cur, rbalance(cur->lchild, d + 1), lbalance(cur->rchild, d + 1)), d + 1), d + 1);",
			"        }",
			"        static node *rbalance(node *cur, int d) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->rchild) < rchild_weight(cur->lchild))",
			"                cur = lrrotate(cur, d);",
			"            else if (subtree_weight(cur->rchild) < lchild_weight(cur->lchild))",
			"                cur = rrotate(cur, d);",
			"            else",
			"                return update(cur);",
			"            return rbalance(lbalance(set_lrchild(cur, rbalance(cur->lchild, d + 1), lbalance(cur->rchild, d + 1)), d + 1), d + 1);",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else",
			"                return update(raw_copy(cur, deleteMin(cur->lchild, res), cur->rchild));",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentSizeBalancedTree(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentSizeBalancedTree() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? rbalance(raw_copy(cur, l, cur->rchild), 0) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? lbalance(raw_copy(cur, cur->lchild, r), 0) : cur;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __value, 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key))",
			"                    return rbalance(raw_copy(cur, self(self, cur->lchild), cur->rchild));",
			"                else if (m_comp(cur->key, __key))",
			"                    return lbalance(raw_copy(cur, cur->lchild, self(self, cur->rchild)));",
			"                else {",
			"                    node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                    p->value = __value;",
			"                    return p;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? update(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? update(raw_copy(cur, cur->lchild, r)) : cur;",
			"                } else {",
			"                    res = true;",
			"                    if (!cur->rchild)",
			"                        return cur->lchild;",
			"                    node *res, *r = deleteMin(cur->rchild, res);",
			"                    return update(raw_copy(res, cur->lchild, r));",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = _root(__version); cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            node *cur = _root(__version);",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentSizeBalancedTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentSizeBalancedTree<_Tp, bool, _Compare, PersistentSizeBalancedTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentSizeBalancedTree<_Tp, bool, _Compare, PersistentSizeBalancedTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentSizeBalancedTree<_Tp, _Fp, _Compare, PersistentSizeBalancedTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent size balanced tree"
	},
	"persistent splay":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentSplaySetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentSplayMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentSplayMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentSplayNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentSplayNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentSplayMultisetTag>",
			"    class PersistentSplay {",
			"#pragma pack(4)",
			"        struct node : _PersistentSplayNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            uint32_t time_stamp;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        int m_state;",
			"        static inline uint32_t s_timer;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if (p->time_stamp == s_timer) return set_lrchild(p, l, r);",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, 1, s_timer, l, r};",
			"            else",
			"                return new node{p->key, 1, s_timer, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            if (p) p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *set_lchild(node *p, node *l) {",
			"            p->lchild = l;",
			"            return p;",
			"        }",
			"        static node *set_rchild(node *p, node *r) {",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *set_lrchild(node *p, node *l, node *r) {",
			"            p->lchild = l;",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *l = p->lchild;",
			"            return raw_copy(l, l->lchild, update(raw_copy(p, l->rchild, p->rchild)));",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *r = p->rchild;",
			"            return raw_copy(r, update(raw_copy(p, p->lchild, r->lchild)), r->rchild);",
			"        }",
			"        static node *rrrotate(node *p) {",
			"            node *l = p->lchild, *ll = l->lchild;",
			"            return raw_copy(ll, ll->lchild, update(raw_copy(l, ll->rchild, update(raw_copy(p, l->rchild, p->rchild)))));",
			"        }",
			"        static node *llrotate(node *p) {",
			"            node *r = p->rchild, *rr = r->rchild;",
			"            return raw_copy(rr, update(raw_copy(r, update(raw_copy(p, p->lchild, r->lchild)), rr->lchild)), rr->rchild);",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *l = p->lchild, *lr = l->rchild;",
			"            return raw_copy(lr, update(raw_copy(l, l->lchild, lr->lchild)), update(raw_copy(p, lr->rchild, p->rchild)));",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *r = p->rchild, *rl = r->lchild;",
			"            return raw_copy(rl, update(raw_copy(p, p->lchild, rl->lchild)), update(raw_copy(r, rl->rchild, r->rchild)));",
			"        }",
			"        node *update_from_lchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 1;",
			"            if (m_state == 3) {",
			"                m_state = 0;",
			"                return rrrotate(cur);",
			"            } else if (m_state == 5) {",
			"                m_state = 0;",
			"                return lrrotate(cur);",
			"            } else if (m_state == 1 && cur == root)",
			"                return rrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *update_from_rchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 2;",
			"            if (m_state == 4) {",
			"                m_state = 0;",
			"                return rlrotate(cur);",
			"            } else if (m_state == 6) {",
			"                m_state = 0;",
			"                return llrotate(cur);",
			"            } else if (m_state == 2 && cur == root)",
			"                return lrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *splay_max(node *cur, node *const &root) {",
			"            if (cur->rchild) {",
			"                cur->rchild = splay_max(cur->rchild, root);",
			"                m_state++;",
			"                if (m_state == 2) {",
			"                    m_state = 0;",
			"                    return llrotate(cur);",
			"                } else if (m_state == 1 && cur == root)",
			"                    return lrotate(cur);",
			"                else",
			"                    return cur;",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        node *splay_kth(node *cur, node *const &root, int k) {",
			"            if (k < subtree_weight(cur->lchild)) {",
			"                cur->lchild = splay_kth(cur->lchild, root, k);",
			"                return update_from_lchild(cur, root);",
			"            } else if (k -= subtree_weight(cur->lchild); k--) {",
			"                cur->rchild = splay_kth(cur->rchild, root, k);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        template <typename... Args>",
			"        node *splay_insert(node *cur, node *const &root, _Tp key, Args... args) {",
			"            if (!cur) {",
			"                m_state = 0;",
			"                return new node{key, args..., 1, s_timer + 1, nullptr, nullptr};",
			"            } else if (m_comp(key, cur->key)) {",
			"                node *p = splay_insert(cur->lchild, root, key, args...);",
			"                if (m_state < 0) return cur;",
			"                p = raw_copy(cur, p, cur->rchild);",
			"                if (cur == root && !m_state) return rrotate(p);",
			"                return update_from_lchild(p, root);",
			"            } else {",
			"                if constexpr (!_Tag::multi_key) {",
			"                    if (!m_comp(cur->key, key)) {",
			"                        m_state = -1;",
			"                        return cur;",
			"                    }",
			"                }",
			"                node *p = splay_insert(cur->rchild, root, key, args...);",
			"                if (m_state < 0) return cur;",
			"                p = raw_copy(cur, cur->lchild, p);",
			"                if (cur == root && !m_state) return lrotate(p);",
			"                return update_from_rchild(p, root);",
			"            }",
			"        }",
			"        node *splay_update(node *cur, node *const &root, _Tp key, _Fp value) {",
			"            if (!cur) {",
			"                m_state = 0;",
			"                return new node{key, value, 1, s_timer + 1, nullptr, nullptr};",
			"            } else if (m_comp(key, cur->key)) {",
			"                node *p = splay_update(cur->lchild, root, key, value);",
			"                if (m_state < 0) return cur;",
			"                p = raw_copy(cur, p, cur->rchild);",
			"                if (cur == root && !m_state) return rrotate(p);",
			"                return update_from_lchild(p, root);",
			"            } else if (m_comp(cur->key, key)) {",
			"                node *p = splay_update(cur->rchild, root, key, value);",
			"                if (m_state < 0) return cur;",
			"                p = raw_copy(cur, cur->lchild, p);",
			"                if (cur == root && !m_state) return lrotate(p);",
			"                return update_from_rchild(p, root);",
			"            } else {",
			"                m_state = 0;",
			"                node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                p->value = value;",
			"                return p;",
			"            }",
			"        }",
			"        node *splay_find(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_find(cur->lchild, root, key);",
			"                return update_from_lchild(cur, root);",
			"            } else if (m_comp(cur->key, key)) {",
			"                cur->rchild = splay_find(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        node *splay_smaller_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(cur->key, key)) {",
			"                cur->rchild = splay_smaller_bound(cur->rchild, root, key);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                cur->lchild = splay_smaller_bound(cur->lchild, root, key);",
			"                return update_from_lchild(cur, root);",
			"            }",
			"        }",
			"        node *splay_upper_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_upper_bound(cur->lchild, root, key);",
			"                if (m_state < 0) {",
			"                    m_state = 0;",
			"                    return cur;",
			"                }",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                cur->rchild = splay_upper_bound(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            }",
			"        }",
			"        node *splay_lower_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (!m_comp(cur->key, key)) {",
			"                cur->lchild = splay_lower_bound(cur->lchild, root, key);",
			"                if (m_state < 0) {",
			"                    m_state = 0;",
			"                    return cur;",
			"                }",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                cur->rchild = splay_lower_bound(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            }",
			"        }",
			"        node *&_root(int version) { return ~version ? m_roots[version] : m_roots.back(); }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentSplay(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentSplay() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, Args... __args) {",
			"            m_roots.push_back(update(splay_insert(_root(__prevVersion), _root(__prevVersion), __args...)));",
			"            s_timer += 2;",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            m_roots.push_back(update(splay_update(_root(__prevVersion), _root(__prevVersion), __key, __value)));",
			"            s_timer += 2;",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            node *root = update(splay_find(_root(__prevVersion), _root(__prevVersion), __key));",
			"            if (~m_state) {",
			"                node *r = root->rchild;",
			"                if (root->lchild) {",
			"                    root = update(splay_max(root->lchild, root->lchild));",
			"                    if (r) root = update(raw_copy(root, root->lchild, r));",
			"                } else",
			"                    root = r;",
			"            }",
			"            m_roots.push_back(root);",
			"            s_timer++;",
			"            return ~m_state;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_lower_bound(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? subtree_weight(_root(__version)->lchild) : subtree_weight(_root(__version));",
			"        }",
			"        const node *kth(int __version, int __k) {",
			"            _root(__version) = update(splay_kth(_root(__version), _root(__version), __k));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        const node *find(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_find(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_lower_bound(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_upper_bound(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) {",
			"            _root(__version) = update(splay_smaller_bound(_root(__version), _root(__version), __key));",
			"            s_timer++;",
			"            return ~m_state ? _root(__version) : nullptr;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) {",
			"            node *root1, *root2;",
			"            if (!(root1 = update(lower_bound(_root(__version), _root(__version), __key)))) return 0;",
			"            int smaller = subtree_weight(root1->lchild);",
			"            if (!(root2 = update(upper_bound(_root(__version), _root(__version), __key)))) {",
			"                s_timer++;",
			"                return size(__version) - smaller;",
			"            } else {",
			"                s_timer++;",
			"                return subtree_weight(root2->lchild) - smaller;",
			"            }",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentSplayContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentSplay<_Tp, bool, _Compare, PersistentSplaySetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentSplay<_Tp, bool, _Compare, PersistentSplayMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentSplay<_Tp, _Fp, _Compare, PersistentSplayMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent splay tree"
	},
	"persistent treap":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentTreapSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentTreapMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentTreapMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentTreapNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentTreapNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentTreapMultisetTag>",
			"    class PersistentTreap {",
			"#pragma pack(4)",
			"        struct node : _PersistentTreapNode<_Tp, _Fp, _Tag::is_map> {",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static inline std::mt19937 s_rand;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, p->priority, p->subtree_weight, l, r};",
			"            else",
			"                return new node{p->key, p->priority, p->subtree_weight, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentTreap(_Compare __comp = _Compare()) : m_comp(__comp) { m_roots.push_back(nullptr); }",
			"        ~PersistentTreap() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., s_rand(), 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    if (!res) return cur;",
			"                    if (subtree_priority(l) > cur->priority) {",
			"                        l->rchild = update(raw_copy(cur, l->rchild, cur->rchild));",
			"                        return update(l);",
			"                    } else {",
			"                        cur = raw_copy(cur, l, cur->rchild);",
			"                        cur->subtree_weight++;",
			"                        return cur;",
			"                    }",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    node *r = self(self, cur->rchild);",
			"                    if (!res) return cur;",
			"                    if (subtree_priority(r) > cur->priority) {",
			"                        r->lchild = update(raw_copy(cur, cur->lchild, r->lchild));",
			"                        return update(r);",
			"                    } else {",
			"                        cur = raw_copy(cur, cur->lchild, r);",
			"                        cur->subtree_weight++;",
			"                        return cur;",
			"                    }",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return new node{__key, __value, s_rand(), 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    if (subtree_priority(l) > cur->priority) {",
			"                        l->rchild = update(raw_copy(cur, l->rchild, cur->rchild));",
			"                        return update(l);",
			"                    } else {",
			"                        cur = raw_copy(cur, l, cur->rchild);",
			"                        cur->subtree_weight++;",
			"                        return cur;",
			"                    }",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    if (subtree_priority(r) > cur->priority) {",
			"                        r->lchild = update(raw_copy(cur, cur->lchild, r->lchild));",
			"                        return update(r);",
			"                    } else {",
			"                        cur = raw_copy(cur, cur->lchild, r);",
			"                        cur->subtree_weight++;",
			"                        return cur;",
			"                    }",
			"                } else {",
			"                    node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                    p->value = __value;",
			"                    return p;",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? update(raw_copy(cur, l, cur->rchild)) : cur;",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? update(raw_copy(cur, cur->lchild, r)) : cur;",
			"                } else {",
			"                    res = true;",
			"                    if (node *l = cur->lchild, *r = cur->rchild; !l)",
			"                        return r;",
			"                    else if (!r)",
			"                        return l;",
			"                    else if (l->subtree_weight > r->subtree_weight)",
			"                        return update(raw_copy(l, l->lchild, self(self, raw_copy(cur, l->rchild, r))));",
			"                    else",
			"                        return update(raw_copy(r, self(self, raw_copy(cur, l, r->lchild)), r->rchild));",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = _root(__version); cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            node *cur = _root(__version);",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)); }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentTreapContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentTreap<_Tp, bool, _Compare, PersistentTreapSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentTreap<_Tp, bool, _Compare, PersistentTreapMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentTreap<_Tp, _Fp, _Compare, PersistentTreapMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent treap"
	},
	"persistent tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation = std::plus<_Tp>>",
			"    class PersistentSegTree {",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        std::vector<_TpNode *> m_roots;",
			"        int m_length;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        _TpNode *_update(_TpNode *cur) {",
			"            cur->val = m_op(cur->lchild ? cur->lchild->val : m_defaultValue, cur->rchild ? cur->rchild->val : m_defaultValue);",
			"            return cur;",
			"        }",
			"        _TpNode *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"        void _clear() { m_roots.clear(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_TpNode>::_reserve(__count); }",
			"        PersistentSegTree(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        PersistentSegTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            _clear();",
			"            if (m_length = __n) m_roots.push_back(new _TpNode(m_defaultValue, nullptr, nullptr));",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            _clear();",
			"            m_length = __last - __first;",
			"            auto dfs = [&](auto self, _Iterator first, _Iterator last) -> _TpNode * {",
			"                if (first + 1 == last)",
			"                    return new _TpNode(*first, nullptr, nullptr);",
			"                else",
			"                    return _update(new _TpNode(*first, self(self, first, first + (last - first + 1) / 2), self(self, first + (last - first + 1) / 2, last)));",
			"            };",
			"            m_roots.push_back(dfs(dfs, __first, __last));",
			"        }",
			"        void copyVersion(int __prevVersion) {",
			"            m_roots.push_back(_root(__prevVersion));",
			"        }",
			"        void update(int __prevVersion, int __i, _Tp __val) {",
			"            auto dfs = [&](auto self, _TpNode *prev, int left, int right) -> _TpNode * {",
			"                _TpNode *cur = prev ? new _TpNode(*prev) : new _TpNode(m_defaultValue, nullptr, nullptr);",
			"                if (left == right)",
			"                    cur->val = __val;",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        cur->lchild = self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"                return cur;",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion), 0, m_length - 1));",
			"        }",
			"        void add(int __prevVersion, int __i, _Tp __inc) {",
			"            auto dfs = [&](auto self, _TpNode *prev, int left, int right) -> _TpNode * {",
			"                _TpNode *cur = prev ? new _TpNode(*prev) : new _TpNode(m_defaultValue, nullptr, nullptr);",
			"                if (left == right)",
			"                    cur->val = m_op(cur->val, __inc);",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        cur->lchild = self(self, cur->lchild, left, (left + right) / 2);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"                return cur;",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion), 0, m_length - 1));",
			"        }",
			"        _Tp query(int __version, int __i) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) {",
			"                if (left == right)",
			"                    return cur->val;",
			"                else if (__i <= (left + right) / 2)",
			"                    return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                else",
			"                    return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1);",
			"        }",
			"        _Tp query(int __version, int __left, int __right) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) {",
			"                if (left >= __left && right <= __right)",
			"                    return cur->val;",
			"                else if (__right <= (left + right) / 2)",
			"                    return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                else if (__left > (left + right) / 2)",
			"                    return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"                else",
			"                    return m_op(cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue, cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue);",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1);",
			"        }",
			"        _Tp queryAll(int __version) const {",
			"            return _root(__version)->val;",
			"        }",
			"        int kth(int __version, _Tp __k) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right, int k) {",
			"                if (left == right) return left;",
			"                if (cur->lchild) {",
			"                    if (cur->lchild->val > k)",
			"                        return self(self, cur->lchild, left, (left + right) / 2, k);",
			"                    else",
			"                        return self(self, cur->rchild, (left + right) / 2 + 1, right, k - cur->lchild->val);",
			"                } else",
			"                    return self(self, cur->rchild, (left + right) / 2 + 1, right, k);",
			"            };",
			"            return dfs(dfs, _root(__version), 0, m_length - 1, __k);",
			"        }",
			"        _Tp periodQuery(int __leftVersion, int __rightVersion, int __i) const {",
			"            if (__leftVersion == 0) return query(__rightVersion, __i);",
			"            auto dfs = [&](auto self, _TpNode *root1, _TpNode *root2, int left, int right) {",
			"                if (root1 == root2) return 0;",
			"                if (left == right)",
			"                    return root1 ? root2->val - root1->val : root2->val;",
			"                else if (__i <= (left + right) / 2)",
			"                    return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2);",
			"                else",
			"                    return self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right);",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1);",
			"        }",
			"        _Tp periodQuery(int __leftVersion, int __rightVersion, int __left, int __right) const {",
			"            if (__leftVersion == 0) return query(__rightVersion, __left, __right);",
			"            auto dfs = [&](auto self, _TpNode *root1, _TpNode *root2, int left, int right) -> _Tp {",
			"                if (root1 == root2) return 0;",
			"                if (left >= __left && right <= __right)",
			"                    return root1 ? root2->val - root1->val : root2->val;",
			"                else if (__right <= (left + right) / 2)",
			"                    return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2);",
			"                else if (__left > (left + right) / 2)",
			"                    return self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right);",
			"                else",
			"                    return self(self, root1 ? root1->lchild : nullptr, root2->lchild, left, (left + right) / 2) + self(self, root1 ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right);",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1);",
			"        }",
			"        int periodKth(int __leftVersion, int __rightVersion, _Tp __k) const {",
			"            if (__leftVersion == 0) return kth(__rightVersion, __k);",
			"            auto dfs = [&](auto self, _TpNode *root1, _TpNode *root2, int left, int right, int k) {",
			"                if (left == right) return left;",
			"                if (!root1 || !root1->lchild) {",
			"                    if (!root2->lchild)",
			"                        return self(self, root1 && root1->rchild ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, k);",
			"                    else if (root2->lchild->val > k)",
			"                        return self(self, nullptr, root2->lchild, left, (left + right) / 2, k);",
			"                    else",
			"                        return self(self, root1 && root1->rchild ? root1->rchild : nullptr, root2->rchild, (left + right) / 2 + 1, right, k - root2->lchild->val);",
			"                } else if (root2->lchild->val - root1->lchild->val > k)",
			"                    return self(self, root1->lchild, root2->lchild, left, (left + right) / 2, k);",
			"                else",
			"                    return self(self, root1->rchild, root2->rchild, (left + right) / 2 + 1, right, k - root2->lchild->val + root1->lchild->val);",
			"            };",
			"            return dfs(dfs, _root(__leftVersion - 1), _root(__rightVersion), 0, m_length - 1, __k);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    PersistentSegTree(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp()) -> PersistentSegTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int64_t>",
			"    PersistentSegTree(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> PersistentSegTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    PersistentSegTree(int = 0, _Operation = _Operation(), _Tp = _Tp()) -> PersistentSegTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    PersistentSegTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp()) -> PersistentSegTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    PersistentSegTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> PersistentSegTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>>",
			"    PersistentSegTree(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp()) -> PersistentSegTree<_Tp, _Operation>;",
			"}",
		],
		"description": "persistent tree"
	},
	"persistent weight balanced leafy tree":{
		"prefix": "PER",
		"body": [
			"namespace OY {",
			"    struct PersistentWeightBalancedLeafySetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentWeightBalancedLeafyMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct PersistentWeightBalancedLeafyMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _PersistentWeightBalancedLeafyTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _PersistentWeightBalancedLeafyTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = PersistentWeightBalancedLeafyMultisetTag>",
			"    class PersistentWeightBalancedLeafyTree {",
			"#pragma pack(4)",
			"        struct node : _PersistentWeightBalancedLeafyTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_roots;",
			"        _Compare m_comp;",
			"        static constexpr int ratio = 4, bias = 2;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *raw_copy(node *p, node *l, node *r) {",
			"            if constexpr (_Tag::is_map)",
			"                return new node{p->key, p->value, p->subtree_weight, l, r};",
			"            else",
			"                return new node{p->key, p->subtree_weight, l, r};",
			"        }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->lchild->subtree_weight + p->rchild->subtree_weight;",
			"            p->key = p->rchild->key;",
			"            return p;",
			"        }",
			"        static node *set_lchild(node *p, node *l) {",
			"            p->lchild = l;",
			"            return p;",
			"        }",
			"        static node *set_rchild(node *p, node *r) {",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *set_lrchild(node *p, node *l, node *r) {",
			"            p->lchild = l;",
			"            p->rchild = r;",
			"            return p;",
			"        }",
			"        static node *lrotate(node *p, int reuse) {",
			"            if (node *r = p->rchild; reuse == 2)",
			"                return update(set_lchild(r, update(set_rchild(p, r->lchild))));",
			"            else if (reuse == 1)",
			"                return update(raw_copy(r, update(set_rchild(p, r->lchild)), r->rchild));",
			"            else",
			"                return update(raw_copy(r, update(raw_copy(p, p->lchild, r->lchild)), r->rchild));",
			"        }",
			"        static node *rrotate(node *p, int reuse) {",
			"            if (node *l = p->lchild; reuse == 2)",
			"                return update(set_rchild(l, update(set_lchild(p, l->rchild))));",
			"            else if (reuse == 1)",
			"                return update(raw_copy(l, l->lchild, update(set_lchild(p, l->rchild))));",
			"            else",
			"                return update(raw_copy(l, l->lchild, update(raw_copy(p, l->rchild, p->rchild))));",
			"        }",
			"        static node *balance(node *cur, bool is_insert) {",
			"            if (cur->lchild->subtree_weight > cur->rchild->subtree_weight * ratio + bias) {",
			"                if (cur->lchild->rchild->subtree_weight > cur->lchild->lchild->subtree_weight * (ratio - 1) + bias)",
			"                    cur->lchild = lrotate(cur->lchild, 0);",
			"                return rrotate(cur, 1 + is_insert);",
			"            } else if (cur->rchild->subtree_weight > cur->lchild->subtree_weight * ratio + bias) {",
			"                if (cur->rchild->lchild->subtree_weight > cur->rchild->rchild->subtree_weight * (ratio - 1) + bias)",
			"                    cur->rchild = rrotate(cur->rchild, 0);",
			"                return lrotate(cur, 1 + is_insert);",
			"            } else",
			"                return update(cur);",
			"        }",
			"        node *_root(int version) const { return ~version ? m_roots[version] : m_roots.back(); }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        PersistentWeightBalancedLeafyTree(_Tp __maxKey = std::numeric_limits<_Tp>::max(), _Compare __comp = _Compare()) : m_comp(__comp) {",
			"            node *root = new node;",
			"            root->key = __maxKey;",
			"            root->subtree_weight = 1;",
			"            root->lchild = nullptr;",
			"            root->rchild = nullptr;",
			"            m_roots.push_back(root);",
			"        }",
			"        ~PersistentWeightBalancedLeafyTree() { clear(); }",
			"        void clear() { m_roots.resize(1); }",
			"        template <typename... Args>",
			"        void insert(int __prevVersion, _Tp __key, Args... __args) {",
			"            bool res = _Tag::multi_key;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur->lchild) {",
			"                    res = true;",
			"                    node *p = raw_copy(cur, new node{__key, __args..., 1, nullptr, nullptr}, cur);",
			"                    p->subtree_weight = 2;",
			"                    return p;",
			"                } else if (m_comp(cur->lchild->key, __key)) {",
			"                    node *r = self(self, cur->rchild);",
			"                    return res ? balance(raw_copy(cur, cur->lchild, r), true) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(__key, cur->lchild->key)) return cur;",
			"                    node *l = self(self, cur->lchild);",
			"                    return res ? balance(raw_copy(cur, l, cur->rchild), true) : cur;",
			"                };",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        void update(int __prevVersion, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur->lchild) {",
			"                    if (m_comp(__key, cur->key)) {",
			"                        node *p = raw_copy(cur, new node{__key, __value, 1, nullptr, nullptr}, cur);",
			"                        p->subtree_weight = 2;",
			"                        return p;",
			"                    } else {",
			"                        node *p = raw_copy(cur, cur->lchild, cur->rchild);",
			"                        p->value = __value;",
			"                        return p;",
			"                    }",
			"                } else if (m_comp(cur->lchild->key, __key))",
			"                    return balance(raw_copy(cur, cur->lchild, self(self, cur->rchild)), true);",
			"                else",
			"                    return balance(raw_copy(cur, self(self, cur->lchild), cur->rchild), true);",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"        }",
			"        bool erase(int __prevVersion, _Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur->lchild) {",
			"                    if (m_comp(__key, cur->key)) return cur;",
			"                    res = true;",
			"                    return nullptr;",
			"                } else if (!m_comp(cur->lchild->key, __key)) {",
			"                    node *l = self(self, cur->lchild);",
			"                    if (!res) return cur;",
			"                    if (!l) return cur->rchild;",
			"                    return balance(raw_copy(cur, l, cur->rchild), false);",
			"                } else {",
			"                    node *r = self(self, cur->rchild);",
			"                    if (!res) return cur;",
			"                    if (!r) return cur->lchild;",
			"                    return balance(raw_copy(cur, cur->lchild, r), false);",
			"                }",
			"            };",
			"            m_roots.push_back(dfs(dfs, _root(__prevVersion)));",
			"            return res;",
			"        }",
			"        void copyVersion(int __prevVersion) { m_roots.push_back(_root(__prevVersion)); }",
			"        int rank(int __version, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = _root(__version); cur->lchild;)",
			"                if (m_comp(cur->lchild->key, __key)) {",
			"                    ord += cur->lchild->subtree_weight;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            return ord;",
			"        }",
			"        const node *kth(int __version, int __k) const {",
			"            node *cur = _root(__version);",
			"            while (cur->lchild)",
			"                if (int l_count = cur->lchild->subtree_weight; __k < l_count)",
			"                    cur = cur->lchild;",
			"                else {",
			"                    __k -= l_count;",
			"                    cur = cur->rchild;",
			"                }",
			"            return cur;",
			"        }",
			"        const node *find(int __version, _Tp __key) const {",
			"            node *cur = _root(__version);",
			"            while (cur->lchild)",
			"                if (m_comp(cur->lchild->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    cur = cur->lchild;",
			"            return m_comp(__key, cur->key) ? nullptr : cur;",
			"        }",
			"        const node *lower_bound(int __version, _Tp __key) const {",
			"            node *cur = _root(__version);",
			"            while (cur->lchild)",
			"                if (m_comp(cur->lchild->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    cur = cur->lchild;",
			"            return cur;",
			"        }",
			"        const node *upper_bound(int __version, _Tp __key) const {",
			"            node *cur = _root(__version);",
			"            while (cur->lchild)",
			"                if (m_comp(__key, cur->lchild->key))",
			"                    cur = cur->lchild;",
			"                else",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *smaller_bound(int __version, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = _root(__version); cur->lchild;) {",
			"                if (m_comp(cur->lchild->key, __key)) {",
			"                    res = cur->lchild;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            if (res)",
			"                while (res->rchild) res = res->rchild;",
			"            return res;",
			"        }",
			"        int size(int __version) const { return subtree_weight(_root(__version)) - 1; }",
			"        bool empty(int __version) const { return !size(__version); }",
			"        int count(int __version, _Tp __key) const {",
			"            auto it1 = lower_bound(__version, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__version, __key);",
			"            if (!it2)",
			"                return size(__version) - rank(__version, __key);",
			"            else",
			"                return rank(__version, it2->key) - rank(__version, __key);",
			"        }",
			"        int versionCount() const { return m_roots.size(); }",
			"    };",
			"    namespace PersistentWeightBalancedLeafyTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = PersistentWeightBalancedLeafyTree<_Tp, bool, _Compare, PersistentWeightBalancedLeafySetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = PersistentWeightBalancedLeafyTree<_Tp, bool, _Compare, PersistentWeightBalancedLeafyMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = PersistentWeightBalancedLeafyTree<_Tp, _Fp, _Compare, PersistentWeightBalancedLeafyMapTag>;",
			"    }",
			"}",
		],
		"description": "persistent weight balanced leafy tree"
	},
	"scape goat tree":{
		"prefix": "SGT",
		"body": [
			"namespace OY {",
			"    struct ScapeGoatTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct ScapeGoatTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct ScapeGoatTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _ScapeGoatTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _ScapeGoatTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = ScapeGoatTreeMultisetTag>",
			"    class ScapeGoatTree {",
			"        struct node : _ScapeGoatTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            bool node_weight;",
			"            int subtree_weight;",
			"            int subtree_capacity;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>().operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static constexpr int ratio = 4, bias = 4;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int subtree_capacity(node *p) { return p ? p->subtree_capacity : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->node_weight + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            p->subtree_capacity = 1 + subtree_capacity(p->lchild) + subtree_capacity(p->rchild);",
			"            return p;",
			"        }",
			"        static void traverse(node *p, node **&s_cursor) {",
			"            if (p->lchild) traverse(p->lchild, s_cursor);",
			"            if (p->node_weight)",
			"                *s_cursor++ = p;",
			"            else",
			"                delete p;",
			"            if (p->rchild) traverse(p->rchild, s_cursor);",
			"        }",
			"        static node *make_tree(node **first, node **last) {",
			"            if (first == last) return nullptr;",
			"            node **mid = first + (last - first) / 2;",
			"            (*mid)->lchild = make_tree(first, mid);",
			"            (*mid)->rchild = make_tree(mid + 1, last);",
			"            return update(*mid);",
			"        }",
			"        static node *balance(node *cur) {",
			"            update(cur);",
			"            if (subtree_weight(cur->lchild) <= subtree_weight(cur->rchild) * ratio + bias && subtree_weight(cur->rchild) <= subtree_weight(cur->lchild) * ratio + bias && cur->subtree_capacity * 2 <= cur->subtree_weight * 3) return cur;",
			"            static std::vector<node *> s_buffer;",
			"            static node **s_cursor;",
			"            s_buffer.resize(cur->subtree_weight);",
			"            s_cursor = s_buffer.data();",
			"            traverse(cur, s_cursor);",
			"            return make_tree(s_buffer.data(), s_cursor);",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        ScapeGoatTree(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur)",
			"                    return new node{__key, __args..., true, 1, 1, nullptr, nullptr};",
			"                else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return balance(cur);",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) {",
			"                            if (!cur->node_weight) {",
			"                                cur->node_weight = true;",
			"                                cur->subtree_weight++;",
			"                            }",
			"                            return cur;",
			"                        }",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return balance(cur);",
			"                }",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key))",
			"                    cur->lchild = self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    cur->rchild = self(self, cur->rchild);",
			"                else if (cur->node_weight) {",
			"                    cur->node_weight = false;",
			"                    cur->subtree_weight--;",
			"                    res = true;",
			"                } else {",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    if (!res) cur->lchild = self(self, cur->lchild);",
			"                }",
			"                return res ? balance(cur) : cur;",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"            return res;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> int {",
			"                if (!cur)",
			"                    return 0;",
			"                else if (m_comp(cur->key, __key))",
			"                    return subtree_weight(cur->lchild) + cur->node_weight + self(self, cur->rchild);",
			"                else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        const node *kth(int __k) const {",
			"            auto dfs = [&](auto self, node *cur, int k) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (int l_count = subtree_weight(cur->lchild); k < l_count)",
			"                    return self(self, cur->lchild, k);",
			"                else if (k -= l_count + cur->node_weight; k < 0)",
			"                    return cur;",
			"                else",
			"                    return self(self, cur->rchild, k);",
			"            };",
			"            return dfs(dfs, m_root, __k);",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key))",
			"                    return self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    return self(self, cur->rchild);",
			"                else if (cur->node_weight)",
			"                    return cur;",
			"                else if (node *res = self(self, cur->rchild))",
			"                    return res;",
			"                else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key)) {",
			"                    node *res = self(self, cur->lchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->rchild);",
			"                    return res;",
			"                } else if (!m_comp(cur->key, __key) && cur->node_weight)",
			"                    return cur;",
			"                else",
			"                    return self(self, cur->rchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(__key, cur->key)) {",
			"                    node *res = self(self, cur->lchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->rchild);",
			"                    return res;",
			"                } else",
			"                    return self(self, cur->rchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) return nullptr;",
			"                if (m_comp(cur->key, __key)) {",
			"                    node *res = self(self, cur->rchild);",
			"                    if (!res && cur->node_weight) res = cur;",
			"                    if (!res) res = self(self, cur->lchild);",
			"                    return res;",
			"                } else",
			"                    return self(self, cur->lchild);",
			"            };",
			"            return dfs(dfs, m_root);",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace ScapeGoatContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = ScapeGoatTree<_Tp, bool, _Compare, ScapeGoatTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = ScapeGoatTree<_Tp, bool, _Compare, ScapeGoatTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = ScapeGoatTree<_Tp, _Fp, _Compare, ScapeGoatTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "scape goat tree"
	},
	"segtree":{
		"prefix": "SEG",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation = std::plus<_Tp>>",
			"    class SegTree {",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        _TpNode *m_root;",
			"        int m_length;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        _TpNode *_update(_TpNode *cur) {",
			"            cur->val = m_op(cur->lchild ? cur->lchild->val : m_defaultValue, cur->rchild ? cur->rchild->val : m_defaultValue);",
			"            return cur;",
			"        }",
			"        void _clear(_TpNode *p) {",
			"            // if (p->lchild) delete p->lchild;",
			"            // if (p->rchild) delete p->rchild;",
			"            // delete p;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_TpNode>::_reserve(__count); }",
			"        SegTree(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_root(nullptr), m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        SegTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_root(nullptr), m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        ~SegTree() {",
			"            if (m_root) _clear(m_root);",
			"        }",
			"        void resize(int __n) {",
			"            if (m_root) _clear(m_root);",
			"            m_root = (m_length = __n) ? new _TpNode(m_defaultValue, nullptr, nullptr) : nullptr;",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            if (m_root) _clear(m_root);",
			"            m_length = __last - __first;",
			"            auto dfs = [&](auto self, _Iterator first, _Iterator last) -> _TpNode * {",
			"                if (first + 1 == last)",
			"                    return new _TpNode(*first, nullptr, nullptr);",
			"                else",
			"                    return _update(new _TpNode(m_defaultValue, self(self, first, first + (last - first + 1) / 2), self(self, first + (last - first + 1) / 2, last)));",
			"            };",
			"            m_root = dfs(dfs, __first, __last);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) -> void {",
			"                if (left == right)",
			"                    cur->val = __val;",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        self(self, lchild(cur), left, (left + right) / 2);",
			"                    else",
			"                        self(self, rchild(cur), (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void add(int __i, _Tp __inc) {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) -> void {",
			"                if (left == right)",
			"                    cur->val = m_op(cur->val, __inc);",
			"                else {",
			"                    if (__i <= (left + right) / 2)",
			"                        self(self, lchild(cur), left, (left + right) / 2);",
			"                    else",
			"                        self(self, rchild(cur), (left + right) / 2 + 1, right);",
			"                    _update(cur);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp query(int __i) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) {",
			"                if (left == right)",
			"                    return cur->val;",
			"                else if (__i <= (left + right) / 2)",
			"                    return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                else",
			"                    return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp query(int __left, int __right) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right) {",
			"                if (left >= __left && right <= __right)",
			"                    return cur->val;",
			"                else if (__right <= (left + right) / 2)",
			"                    return cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue;",
			"                else if (__left > (left + right) / 2)",
			"                    return cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue;",
			"                else",
			"                    return m_op(cur->lchild ? self(self, cur->lchild, left, (left + right) / 2) : m_defaultValue, cur->rchild ? self(self, cur->rchild, (left + right) / 2 + 1, right) : m_defaultValue);",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        _Tp queryAll() const { return m_root->val; }",
			"        int kth(_Tp __k) const {",
			"            auto dfs = [&](auto self, _TpNode *cur, int left, int right, int k) {",
			"                if (left == right) return left;",
			"                if (cur->lchild) {",
			"                    if (cur->lchild->val > k)",
			"                        return self(self, cur->lchild, left, (left + right) / 2, k);",
			"                    else",
			"                        return self(self, cur->rchild, (left + right) / 2 + 1, right, k - cur->lchild->val);",
			"                } else",
			"                    return self(self, cur->rchild, (left + right) / 2 + 1, right, k);",
			"            };",
			"            return dfs(dfs, m_root, 0, m_length - 1, __k);",
			"        }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    SegTree(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp()) -> SegTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int64_t>",
			"    SegTree(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> SegTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    SegTree(int = 0, _Operation = _Operation(), _Tp = _Tp()) -> SegTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SegTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp()) -> SegTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SegTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> SegTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>>",
			"    SegTree(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp()) -> SegTree<_Tp, _Operation>;",
			"}",
		],
		"description": "segtree"
	},
	"segtree 2d":{
		"prefix": "SEG2D",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation = std::plus<_Tp>>",
			"    class SegTree2d {",
			"#pragma pack(4)",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"        struct _TpTree : MemoryPool<_TpTree> {",
			"            _TpNode *root;",
			"            _TpTree *lchild;",
			"            _TpTree *rchild;",
			"            _TpTree() : root(nullptr), lchild(nullptr), rchild(nullptr) {}",
			"        };",
			"#pragma pack()",
			"        _TpTree *m_root;",
			"        int m_row;",
			"        int m_column;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        static _TpTree *lchild(_TpTree *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpTree;",
			"            return cur->lchild;",
			"        }",
			"        static _TpTree *rchild(_TpTree *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpTree;",
			"            return cur->rchild;",
			"        }",
			"        _TpNode *root(_TpTree *cur) {",
			"            if (!cur->root)",
			"                cur->root = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->root;",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        void _add(_TpNode *cur, int left, int right, int col, _Tp inc) {",
			"            cur->val = m_op(cur->val, inc);",
			"            if (left == right) return;",
			"            if (int mid = (left + right) / 2; col <= mid)",
			"                _add(lchild(cur), left, mid, col, inc);",
			"            else",
			"                _add(rchild(cur), mid + 1, right, col, inc);",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col) const {",
			"            if (left == right)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col) : m_defaultValue;",
			"            else",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col) : m_defaultValue;",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col1, int col2) const {",
			"            if (left >= col1 && right <= col2)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col2 <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue;",
			"            else if (col1 > mid)",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue;",
			"            else",
			"                return m_op(cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue, cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue);",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __treeCount, int __nodeCount) {",
			"            MemoryPool<_TpTree>::_reserve(__treeCount);",
			"            MemoryPool<_TpNode>::_reserve(__nodeCount);",
			"        }",
			"        SegTree2d(int __row, int __column, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_root(nullptr), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__row, __column);",
			"        }",
			"        template <typename Ref>",
			"        SegTree2d(Ref __ref, int __row, int __column, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_root(nullptr), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__ref, __row, __column);",
			"        }",
			"        ~SegTree2d() {",
			"            if (m_root) {",
			"                // _clear(m_root);",
			"                m_root = nullptr;",
			"            }",
			"        }",
			"        void resize(int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_root = new _TpTree;",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            m_row = __row;",
			"            m_column = __column;",
			"            auto build_leaf = [&](auto self, int left, int right, int row) {",
			"                if (left == right) return new _TpNode(__ref(row, left), nullptr, nullptr);",
			"                int mid = (left + right) / 2;",
			"                _TpNode *lchild = self(self, left, mid, row);",
			"                _TpNode *rchild = self(self, mid + 1, right, row);",
			"                return new _TpNode(m_op(lchild->val, rchild->val), lchild, rchild);",
			"            };",
			"            auto build_nonleaf = [&](auto self, _TpNode *lc, _TpNode *rc) -> _TpNode * {",
			"                _TpNode *p = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"                p->val = m_op(lc->val, rc->val);",
			"                if (lc->lchild) {",
			"                    p->lchild = self(self, lc->lchild, rc->lchild);",
			"                    p->rchild = self(self, lc->rchild, rc->rchild);",
			"                }",
			"                return p;",
			"            };",
			"            auto build = [&](auto self, int left, int right) -> _TpTree * {",
			"                _TpTree *p = new _TpTree;",
			"                if (left == right)",
			"                    p->root = build_leaf(build_leaf, 0, m_column - 1, left);",
			"                else {",
			"                    int mid = (left + right) / 2;",
			"                    p->lchild = self(self, left, mid);",
			"                    p->rchild = self(self, mid + 1, right);",
			"                    p->root = build_nonleaf(build_nonleaf, p->lchild->root, p->rchild->root);",
			"                }",
			"                return p;",
			"            };",
			"            m_root = build(build, 0, m_row - 1);",
			"        }",
			"        void add(int __row, int __column, _Tp __inc) {",
			"            auto dfs = [&](auto self, _TpTree *cur, int row1, int row2) {",
			"                _add(root(cur), 0, m_column - 1, __column, __inc);",
			"                if (row1 == row2) return;",
			"                if (int mid = (row1 + row2) / 2; __row <= mid)",
			"                    self(self, lchild(cur), row1, mid);",
			"                else",
			"                    self(self, rchild(cur), mid + 1, row2);",
			"            };",
			"            dfs(dfs, m_root, 0, m_row - 1);",
			"        }",
			"        _Tp query(int __row, int __column) const {",
			"            auto dfs = [&](auto self, _TpTree *cur, int left, int right) {",
			"                if (left == right)",
			"                    return cur->root ? _query(cur->root, 0, m_column - 1, __column) : m_defaultValue;",
			"                else if (int mid = (left + right) / 2; __row <= mid)",
			"                    return cur->lchild ? self(self, cur->lchild, left, mid) : m_defaultValue;",
			"                else",
			"                    return cur->rchild ? self(self, cur->rchild, mid + 1, right) : m_defaultValue;",
			"            };",
			"            return dfs(dfs, m_root, 0, m_row - 1);",
			"        }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const {",
			"            auto dfs = [&](auto self, _TpTree *cur, int left, int right) {",
			"                if (left >= __row1 && right <= __row2)",
			"                    return cur->root ? _query(cur->root, 0, m_column - 1, __column1, __column2) : m_defaultValue;",
			"                else if (int mid = (left + right) / 2; __row2 <= mid)",
			"                    return cur->lchild ? self(self, cur->lchild, left, mid) : m_defaultValue;",
			"                else if (__row1 > (left + right) / 2)",
			"                    return cur->rchild ? self(self, cur->rchild, mid + 1, right) : m_defaultValue;",
			"                else",
			"                    return m_op(cur->lchild ? self(self, cur->lchild, left, mid) : m_defaultValue, cur->rchild ? self(self, cur->rchild, mid + 1, right) : m_defaultValue);",
			"            };",
			"            return dfs(dfs, m_root, 0, m_row - 1);",
			"        }",
			"        _Tp queryAll() const { return query(0, m_row - 1, 0, m_column - 1); }",
			"        int rowKth(int __row1, int __row2, _Tp __k) const {",
			"            static std::vector<_TpNode *> roots_plus;",
			"            roots_plus.clear();",
			"            auto dfs = [&](auto self, _TpTree *cur, int left, int right) {",
			"                if (left >= __row1 && right <= __row2) {",
			"                    if (cur->root) roots_plus.push_back(cur->root);",
			"                    return;",
			"                }",
			"                int mid = (left + right) / 2;",
			"                if (__row1 <= mid && cur->lchild) self(self, cur->lchild, left, mid);",
			"                if (__row2 > mid && cur->rchild) self(self, cur->rchild, mid + 1, right);",
			"            };",
			"            if (m_root) dfs(dfs, m_root, 0, m_row - 1);",
			"            int left = 0, right = m_column - 1;",
			"#define FILTER(vec, prop)                    \\",
			"    {                                        \\",
			"        int i = 0;                           \\",
			"        for (auto a : vec)                   \\",
			"            if (a->prop) vec[i++] = a->prop; \\",
			"        vec.resize(i);                       \\",
			"    }",
			"            while (left < right) {",
			"                _Tp sum = 0;",
			"                for (_TpNode *root : roots_plus) sum += root->lchild ? root->lchild->val : 0;",
			"                if (__k < sum) {",
			"                    right = (left + right) / 2;",
			"                    FILTER(roots_plus, lchild);",
			"                } else {",
			"                    left = (left + right) / 2 + 1;",
			"                    __k -= sum;",
			"                    FILTER(roots_plus, rchild);",
			"                }",
			"            }",
			"            return left;",
			"#undef FILTER",
			"        }",
			"    };",
			"    template <typename _Tp = int, typename _Operation = std::plus<_Tp>>",
			"    SegTree2d(int, int, _Operation = _Operation(), _Tp = _Tp()) -> SegTree2d<_Tp, _Operation>;",
			"    template <typename Ref, typename _Tp = typename std::iterator_traits<typename decltype(std::mem_fn(&Ref::operator()))::result_type>::value_type, typename _Operation = std::plus<_Tp>>",
			"    SegTree2d(Ref, int, int, _Operation = _Operation(), std::enable_if_t<std::is_invocable_v<Ref, int>, _Tp> = _Tp()) -> SegTree2d<_Tp, _Operation>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>, typename _Operation = std::plus<_Tp>>",
			"    SegTree2d(Ref, int, int, _Operation = _Operation(), std::enable_if_t<std::is_invocable_v<Ref, int, int>, _Tp> = _Tp()) -> SegTree2d<_Tp, _Operation>;",
			"}",
		],
		"description": "segtree 2d"
	},
	"seg-binary indexed tree":{
		"prefix": "SEGBIT",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    class SegBIT {",
			"#pragma pack(4)",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"#pragma pack()",
			"        std::vector<_TpNode *> m_sub;",
			"        int m_row;",
			"        int m_column;",
			"        int m_length;",
			"        _Plus m_plus;",
			"        _Minus m_minus;",
			"        _Tp m_defaultValue;",
			"        _TpNode *sub(int i) {",
			"            if (!m_sub[i]) m_sub[i] = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return m_sub[i];",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        void _add(_TpNode *cur, int left, int right, int col, _Tp inc) {",
			"            cur->val = m_plus(cur->val, inc);",
			"            if (left == right) return;",
			"            if (int mid = (left + right) / 2; col <= mid)",
			"                _add(lchild(cur), left, mid, col, inc);",
			"            else",
			"                _add(rchild(cur), mid + 1, right, col, inc);",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col) const {",
			"            if (left == right)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col) : m_defaultValue;",
			"            else",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col) : m_defaultValue;",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col1, int col2) const {",
			"            if (left >= col1 && right <= col2)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col2 <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue;",
			"            else if (col1 > mid)",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue;",
			"            else",
			"                return m_plus(cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue, cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue);",
			"        }",
			"        void _clear(_TpNode *cur) {",
			"            if (cur->lchild) _clear(cur->lchild);",
			"            if (cur->rchild) _clear(cur->rchild);",
			"            delete cur;",
			"        }",
			"        void _clear() {",
			"            // for (_TpNode *root : m_sub)",
			"            //     if (root) _clear(root);",
			"            m_sub.clear();",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_TpNode>::_reserve(__count); }",
			"        SegBIT(int __row, int __column, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) { resize(__row, __column); }",
			"        template <typename Ref>",
			"        SegBIT(Ref __ref, int __row, int __column, _Plus __plus = _Plus(), _Minus __minus = _Minus(), _Tp __defaultValue = _Tp()) : m_plus(__plus), m_minus(__minus), m_defaultValue(__defaultValue) { reset(__ref, __row, __column); }",
			"        ~SegBIT() { _clear(); }",
			"        void resize(int __row, int __column) {",
			"            _clear();",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_length = m_row > 1 ? 1 << (32 - std::__countl_zero(m_row - 1)) : 1;",
			"            m_sub.assign(m_length, nullptr);",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            _clear();",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_length = m_row > 1 ? 1 << (32 - std::__countl_zero(m_row - 1)) : 1;",
			"            auto build_leaf = [&](auto self, int left, int right, int row) {",
			"                if (left == right) return new _TpNode(__ref(row, left), nullptr, nullptr);",
			"                int mid = (left + right) / 2;",
			"                _TpNode *lchild = self(self, left, mid, row);",
			"                _TpNode *rchild = self(self, mid + 1, right, row);",
			"                return new _TpNode(m_op(lchild->val, rchild->val), lchild, rchild);",
			"            };",
			"            auto build_sum = [&](auto self, _TpNode *cur, _TpNode *other) {",
			"                cur->val = m_plus(cur->val, other->val);",
			"                if (!other->lchild) return;",
			"                self(self, lchild(cur), other->lchild);",
			"                self(self, rchild(cur), other->rchild);",
			"            };",
			"            m_sub.resize(m_length);",
			"            for (int i = 0; i < m_row; i++) m_sub[i] = build_leaf(build_leaf, 0, m_column - 1, i);",
			"            for (int i = 0; i < m_length; i++)",
			"                if (int j = i + (1 << std::__countr_zero(i + 1)); j < m_length) m_plus(sub(j), m_sub[i]);",
			"        }",
			"        void add(int __row, int __column, _Tp __inc) {",
			"            while (__row < m_length) {",
			"                _add(sub(__row), 0, m_column - 1, __column, __inc);",
			"                __row += 1 << std::__countr_zero(__row + 1);",
			"            }",
			"        }",
			"        _Tp presum(int __row, int __column) const {",
			"            _Tp ret = m_defaultValue;",
			"            while (__row >= 0) {",
			"                ret = m_plus(ret, m_sub[__row] ? _query(m_sub[__row], 0, m_column - 1, __column) : m_defaultValue);",
			"                __row -= 1 << std::__countr_zero(__row + 1);",
			"            }",
			"            return ret;",
			"        }",
			"        _Tp presum(int __row, int __column1, int __column2) const {",
			"            _Tp ret = m_defaultValue;",
			"            while (__row >= 0) {",
			"                ret = m_plus(ret, m_sub[__row] ? _query(m_sub[__row], 0, m_column - 1, __column1, __column2) : m_defaultValue);",
			"                __row -= 1 << std::__countr_zero(__row + 1);",
			"            }",
			"            return ret;",
			"        }",
			"        _Tp query(int __row, int __column) const { return m_minus(presum(__row, __column), presum(__row - 1, __column)); }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const { return m_minus(presum(__row2, __column1, __column2), presum(__row1 - 1, __column1, __column2)); }",
			"        _Tp queryAll() const { return presum(m_row - 1, 0, m_column - 1); }",
			"        int rowKth(int __row1, int __row2, _Tp __k) const {",
			"            static std::vector<_TpNode *> roots_plus, roots_minus;",
			"            roots_plus.clear();",
			"            roots_minus.clear();",
			"            while (__row2 >= 0) {",
			"                if (m_sub[__row2]) roots_plus.push_back(m_sub[__row2]);",
			"                __row2 -= 1 << std::__countr_zero(__row2 + 1);",
			"            }",
			"            __row1--;",
			"            while (__row1 >= 0) {",
			"                if (m_sub[__row1]) roots_minus.push_back(m_sub[__row1]);",
			"                __row1 -= 1 << std::__countr_zero(__row1 + 1);",
			"            }",
			"            int left = 0, right = m_column - 1;",
			"#define FILTER(vec, prop)                    \\",
			"    {                                        \\",
			"        int i = 0;                           \\",
			"        for (auto a : vec)                   \\",
			"            if (a->prop) vec[i++] = a->prop; \\",
			"        vec.resize(i);                       \\",
			"    }",
			"            while (left < right) {",
			"                _Tp sum = 0;",
			"                for (_TpNode *root : roots_plus) sum += root->lchild ? root->lchild->val : 0;",
			"                for (_TpNode *root : roots_minus) sum -= root->lchild ? root->lchild->val : 0;",
			"                if (__k < sum) {",
			"                    right = (left + right) / 2;",
			"                    FILTER(roots_plus, lchild);",
			"                    FILTER(roots_minus, lchild);",
			"                } else {",
			"                    left = (left + right) / 2 + 1;",
			"                    __k -= sum;",
			"                    FILTER(roots_plus, rchild);",
			"                    FILTER(roots_minus, rchild);",
			"                }",
			"            }",
			"            return left;",
			"#undef FILTER",
			"        }",
			"    };",
			"    template <typename _Tp = int, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    SegBIT(int, int, _Plus = _Plus(), _Minus = _Minus(), _Tp = _Tp()) -> SegBIT<_Tp, _Plus, _Minus>;",
			"    template <typename Ref, typename _Tp = typename std::iterator_traits<typename decltype(std::mem_fn(&Ref::operator()))::result_type>::value_type, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    SegBIT(Ref, int, int, _Plus = _Plus(), _Minus = _Minus(), std::enable_if_t<std::is_invocable_v<Ref, int>, _Tp> = _Tp()) -> SegBIT<_Tp, _Plus, _Minus>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>, typename _Plus = std::plus<_Tp>, typename _Minus = std::minus<_Tp>>",
			"    SegBIT(Ref, int, int, _Plus = _Plus(), _Minus = _Minus(), std::enable_if_t<std::is_invocable_v<Ref, int, int>, _Tp> = _Tp()) -> SegBIT<_Tp, _Plus, _Minus>;",
			"}",
		],
		"description": "seg-binary indexedc tree"
	},
	"seg-zkwtree":{
		"prefix": "SEGZKW",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Operation = std::plus<_Tp>>",
			"    class SegZkwTree {",
			"#pragma pack(4)",
			"        struct _TpNode : MemoryPool<_TpNode> {",
			"            _Tp val;",
			"            _TpNode *lchild;",
			"            _TpNode *rchild;",
			"            _TpNode(_Tp _val, _TpNode *_lchild, _TpNode *_rchild) : val(_val), lchild(_lchild), rchild(_rchild) {}",
			"        };",
			"#pragma pack()",
			"        std::vector<_TpNode *> m_sub;",
			"        int m_row;",
			"        int m_column;",
			"        int m_depth;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        _TpNode *sub(int i) {",
			"            if (!m_sub[i]) m_sub[i] = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return m_sub[i];",
			"        }",
			"        _TpNode *lchild(_TpNode *cur) {",
			"            if (!cur->lchild)",
			"                cur->lchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->lchild;",
			"        }",
			"        _TpNode *rchild(_TpNode *cur) {",
			"            if (!cur->rchild)",
			"                cur->rchild = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"            return cur->rchild;",
			"        }",
			"        void _add(_TpNode *cur, int left, int right, int col, _Tp inc) {",
			"            cur->val = m_op(cur->val, inc);",
			"            if (left == right) return;",
			"            if (int mid = (left + right) / 2; col <= mid)",
			"                _add(lchild(cur), left, mid, col, inc);",
			"            else",
			"                _add(rchild(cur), mid + 1, right, col, inc);",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col) const {",
			"            if (left == right)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col) : m_defaultValue;",
			"            else",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col) : m_defaultValue;",
			"        }",
			"        _Tp _query(_TpNode *cur, int left, int right, int col1, int col2) const {",
			"            if (left >= col1 && right <= col2)",
			"                return cur->val;",
			"            else if (int mid = (left + right) / 2; col2 <= mid)",
			"                return cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue;",
			"            else if (col1 > mid)",
			"                return cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue;",
			"            else",
			"                return m_op(cur->lchild ? _query(cur->lchild, left, mid, col1, col2) : m_defaultValue, cur->rchild ? _query(cur->rchild, mid + 1, right, col1, col2) : m_defaultValue);",
			"        }",
			"        void _clear(_TpNode *cur) {",
			"            if (cur->lchild) _clear(cur->lchild);",
			"            if (cur->rchild) _clear(cur->rchild);",
			"            delete cur;",
			"        }",
			"        void _clear() {",
			"            // for (_TpNode *root : m_sub)",
			"            //     if (root) _clear(root);",
			"            m_sub.clear();",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<_TpNode>::_reserve(__count); }",
			"        SegZkwTree(int __row, int __column, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__row, __column);",
			"        }",
			"        template <typename Ref>",
			"        SegZkwTree(Ref __ref, int __row, int __column, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__ref, __row, __column);",
			"        }",
			"        ~SegZkwTree() { _clear(); }",
			"        void resize(int __row, int __column) {",
			"            _clear();",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_depth = 32 - (m_row > 1 ? std::__countl_zero(m_row - 1) : 32);",
			"            m_sub.resize(1 << (m_depth + 1), nullptr);",
			"        }",
			"        template <typename Ref>",
			"        void reset(Ref __ref, int __row, int __column) {",
			"            _clear();",
			"            m_row = __row;",
			"            m_column = __column;",
			"            m_depth = 32 - (m_row > 1 ? std::__countl_zero(m_row - 1) : 32);",
			"            auto build_leaf = [&](auto self, int left, int right, int row) {",
			"                if (left == right) return new _TpNode(__ref(row, left), nullptr, nullptr);",
			"                int mid = (left + right) / 2;",
			"                _TpNode *lchild = self(self, left, mid, row);",
			"                _TpNode *rchild = self(self, mid + 1, right, row);",
			"                return new _TpNode(m_op(lchild->val, rchild->val), lchild, rchild);",
			"            };",
			"            auto build_nonleaf = [&](auto self, _TpNode *lc, _TpNode *rc) -> _TpNode * {",
			"                _TpNode *p = new _TpNode(m_defaultValue, nullptr, nullptr);",
			"                p->val = m_op(lc->val, rc->val);",
			"                if (lc->lchild) {",
			"                    p->lchild = self(self, lc->lchild, rc->lchild);",
			"                    p->rchild = self(self, lc->rchild, rc->rchild);",
			"                }",
			"                return p;",
			"            };",
			"            m_sub.resize(1 << (m_depth + 1));",
			"            for (int i = 0; i < m_row; i++) m_sub[i + (1 << m_depth)] = build_leaf(build_leaf, 0, m_column - 1, i);",
			"            for (int i = (1 << m_depth) - 1; i; i--) m_sub[i] = build_nonleaf(build_nonleaf, m_sub[i << 1], m_sub[i << 1 ^ 1]);",
			"        }",
			"        void add(int __row, int __column, _Tp __inc) {",
			"            for (int i = __row + (1 << m_depth); i; i >>= 1) _add(sub(i), 0, m_column - 1, __column, __inc);",
			"        }",
			"        _Tp query(int __row, int __column) const { return m_sub[__row] ? _query(m_sub[__row], 0, m_column - 1, __column) : m_defaultValue; }",
			"        _Tp query(int __row1, int __row2, int __column1, int __column2) const {",
			"            __row1 += 1 << m_depth;",
			"            __row2 += 1 << m_depth;",
			"            if (__row1 == __row2) return m_sub[__row1] ? _query(m_sub[__row1], 0, m_column - 1, __column1, __column2) : m_defaultValue;",
			"            _Tp res = m_sub[__row1] ? _query(m_sub[__row1], 0, m_column - 1, __column1, __column2) : m_defaultValue;",
			"            int j = 31 - std::__countl_zero(__row1 ^ __row2);",
			"            for (int i = 0; i < j; i++)",
			"                if (!(__row1 >> i & 1)) res = m_op(res, m_sub[__row1 >> i ^ 1] ? _query(m_sub[__row1 >> i ^ 1], 0, m_column - 1, __column1, __column2) : m_defaultValue);",
			"            for (int i = j - 1; i >= 0; i--)",
			"                if (__row2 >> i & 1) res = m_op(res, m_sub[__row2 >> i ^ 1] ? _query(m_sub[__row2 >> i ^ 1], 0, m_column - 1, __column1, __column2) : m_defaultValue);",
			"            return m_op(res, m_sub[__row2] ? _query(m_sub[__row2], 0, m_column - 1, __column1, __column2) : m_defaultValue);",
			"        }",
			"        _Tp queryAll() const { return query(0, m_row - 1, 0, m_column - 1); }",
			"        int rowKth(int __row1, int __row2, _Tp __k) const {",
			"            static std::vector<_TpNode *> roots_plus;",
			"            roots_plus.clear();",
			"            __row1 += 1 << m_depth;",
			"            __row2 += 1 << m_depth;",
			"            if (__row1 < __row2) {",
			"                if (m_sub[__row1]) roots_plus.push_back(m_sub[__row1]);",
			"                int j = 31 - std::__countl_zero(__row1 ^ __row2);",
			"                for (int i = 0; i < j; i++)",
			"                    if (!(__row1 >> i & 1) && m_sub[__row1 >> i ^ 1]) roots_plus.push_back(m_sub[__row1 >> i ^ 1]);",
			"                for (int i = j - 1; i >= 0; i--)",
			"                    if ((__row2 >> i & 1) && m_sub[__row2 >> i ^ 1]) roots_plus.push_back(m_sub[__row2 >> i ^ 1]);",
			"                if (m_sub[__row2]) roots_plus.push_back(m_sub[__row2]);",
			"            } else if (m_sub[__row1])",
			"                roots_plus.push_back(m_sub[__row1]);",
			"            int left = 0, right = m_column - 1;",
			"#define FILTER(vec, prop)                    \\",
			"    {                                        \\",
			"        int i = 0;                           \\",
			"        for (auto a : vec)                   \\",
			"            if (a->prop) vec[i++] = a->prop; \\",
			"        vec.resize(i);                       \\",
			"    }",
			"            while (left < right) {",
			"                _Tp sum = 0;",
			"                for (_TpNode *root : roots_plus) sum += root->lchild ? root->lchild->val : 0;",
			"                if (__k < sum) {",
			"                    right = (left + right) / 2;",
			"                    FILTER(roots_plus, lchild);",
			"                } else {",
			"                    left = (left + right) / 2 + 1;",
			"                    __k -= sum;",
			"                    FILTER(roots_plus, rchild);",
			"                }",
			"            }",
			"            return left;",
			"#undef FILTER",
			"        }",
			"    };",
			"    template <typename _Tp = int, typename _Operation = std::plus<_Tp>>",
			"    SegZkwTree(int, int, _Operation = _Operation(), _Tp = _Tp()) -> SegZkwTree<_Tp, _Operation>;",
			"    template <typename Ref, typename _Tp = typename std::iterator_traits<typename decltype(std::mem_fn(&Ref::operator()))::result_type>::value_type, typename _Operation = std::plus<_Tp>>",
			"    SegZkwTree(Ref, int, int, _Operation = _Operation(), std::enable_if_t<std::is_invocable_v<Ref, int>, _Tp> = _Tp()) -> SegZkwTree<_Tp, _Operation>;",
			"    template <typename Ref, typename _Tp = typename std::decay_t<typename decltype(std::mem_fn(&Ref::operator()))::result_type>, typename _Operation = std::plus<_Tp>>",
			"    SegZkwTree(Ref, int, int, _Operation = _Operation(), std::enable_if_t<std::is_invocable_v<Ref, int, int>, _Tp> = _Tp()) -> SegZkwTree<_Tp, _Operation>;",
			"}",
		],
		"description": "seg-zkwtree"
	},
	"size balanced tree":{
		"prefix": "SBT",
		"body": [
			"namespace OY {",
			"    struct SizeBalancedTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _SizeBalancedTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SizeBalancedTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = SizeBalancedTreeMultisetTag>",
			"    class SizeBalancedTree {",
			"        struct node : _SizeBalancedTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int lchild_weight(node *p) { return p && p->lchild ? p->lchild->subtree_weight : 0; }",
			"        static int rchild_weight(node *p) { return p && p->rchild ? p->rchild->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        static node *lbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->lchild) < lchild_weight(cur->rchild))",
			"                cur = rlrotate(cur);",
			"            else if (subtree_weight(cur->lchild) < rchild_weight(cur->rchild))",
			"                cur = lrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *rbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->rchild) < rchild_weight(cur->lchild))",
			"                cur = lrrotate(cur);",
			"            else if (subtree_weight(cur->rchild) < lchild_weight(cur->lchild))",
			"                cur = rrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur) return nullptr;",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else {",
			"                cur->lchild = deleteMin(cur->lchild, res);",
			"                return update(cur);",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        SizeBalancedTree(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return _Tag::multi_key || res ? rbalance(cur) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return _Tag::multi_key || res ? lbalance(cur) : cur;",
			"                };",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                } else if (m_comp(cur->key, __key)) {",
			"                    cur->rchild = self(self, cur->rchild);",
			"                } else if (!cur->rchild) {",
			"                    delete cur;",
			"                    return cur->lchild;",
			"                } else {",
			"                    node *res;",
			"                    cur->rchild = deleteMin(cur->rchild, res);",
			"                    res->lchild = cur->lchild;",
			"                    res->rchild = cur->rchild;",
			"                    delete cur;",
			"                    cur = res;",
			"                }",
			"                return update(cur);",
			"            };",
			"            int old_weight = size();",
			"            m_root = dfs(dfs, m_root);",
			"            return old_weight != size();",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace SizeBalancedTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = SizeBalancedTree<_Tp, bool, _Compare, SizeBalancedTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = SizeBalancedTree<_Tp, bool, _Compare, SizeBalancedTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = SizeBalancedTree<_Tp, _Fp, _Compare, SizeBalancedTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "size balanced tree"
	},
	"size balanced segtree":{
		"prefix": "SBSEG",
		"body": [
			"namespace OY {",
			"    struct SizeBalancedSegTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedSegTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedSegTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _SizeBalancedSegTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SizeBalancedSegTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = SizeBalancedSegTreeMultisetTag>",
			"    class SizeBalancedSegTree {",
			"#pragma pack(4)",
			"        struct node : _SizeBalancedSegTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        struct treenode : MemoryPool<treenode> {",
			"            node *root;",
			"            treenode *lchild;",
			"            treenode *rchild;",
			"            treenode() : root(nullptr), lchild(nullptr), rchild(nullptr) {}",
			"        };",
			"#pragma pack()",
			"        treenode *m_root;",
			"        _Compare m_comp;",
			"        int m_length;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int lchild_weight(node *p) { return p && p->lchild ? p->lchild->subtree_weight : 0; }",
			"        static int rchild_weight(node *p) { return p && p->rchild ? p->rchild->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        static node *lbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->lchild) < lchild_weight(cur->rchild))",
			"                cur = rlrotate(cur);",
			"            else if (subtree_weight(cur->lchild) < rchild_weight(cur->rchild))",
			"                cur = lrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *rbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->rchild) < rchild_weight(cur->lchild))",
			"                cur = lrrotate(cur);",
			"            else if (subtree_weight(cur->rchild) < lchild_weight(cur->lchild))",
			"                cur = rrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur) return nullptr;",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else {",
			"                cur->lchild = deleteMin(cur->lchild, res);",
			"                return update(cur);",
			"            }",
			"        }",
			"        void _clear() {",
			"            m_root = nullptr;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __treeCount, int __nodeCount) {",
			"            MemoryPool<treenode>::_reserve(__treeCount);",
			"            MemoryPool<node>::_reserve(__nodeCount);",
			"        }",
			"        SizeBalancedSegTree(int __n = 0, _Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) { resize(__n); }",
			"        template <typename _Iterator>",
			"        SizeBalancedSegTree(_Iterator __first, _Iterator __last, _Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) { reset(__first, __last); }",
			"        ~SizeBalancedSegTree() { _clear(); }",
			"        void resize(int __n) {",
			"            _clear();",
			"            m_length = __n;",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            static_assert(!_Tag::is_map);",
			"            _clear();",
			"            std::vector<_Tp> data(__first, __last);",
			"            m_length = __last - __first;",
			"            auto makenode = [&](auto self, auto first, auto last) -> node * {",
			"                if (first == last) return nullptr;",
			"                auto mid = first + (last - first) / 2;",
			"                return new node{*mid, int(last - first), self(self, first, mid), self(self, mid + 1, last)};",
			"            };",
			"            auto dfs = [&](auto self, auto first, auto last) -> treenode * {",
			"                if (first == last) return nullptr;",
			"                treenode *p = new treenode;",
			"                if (last - first > 1) {",
			"                    auto mid = first + (last - first + 1) / 2;",
			"                    p->lchild = self(self, first, mid);",
			"                    p->rchild = self(self, mid, last);",
			"                    std::inplace_merge(first, mid, last);",
			"                }",
			"                p->root = makenode(makenode, first, last);",
			"                return p;",
			"            };",
			"            m_root = dfs(dfs, data.data(), data.data() + m_length);",
			"        }",
			"        template <typename... Args>",
			"        void insert(int __i, _Tp __key, Args... __args) {",
			"            auto dfs = [&](auto self, treenode *cur, int left, int right) -> treenode * {",
			"                if (!cur) cur = new treenode;",
			"                cur->root = insert(cur->root, __key, __args...);",
			"                if (left < right) {",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        cur->lchild = self(self, cur->lchild, left, mid);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, mid + 1, right);",
			"                }",
			"                return cur;",
			"            };",
			"            m_root = dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void update(int __i, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            auto dfs = [&](auto self, treenode *cur, int left, int right) {",
			"                if (!cur) cur = new treenode;",
			"                cur->root = update(cur->root, __key, __value);",
			"                if (left < right) {",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        cur->lchild = self(self, cur->lchild, left, mid);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, mid + 1, right);",
			"                }",
			"                return cur;",
			"            };",
			"            m_root = dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        void erase(int __i, _Tp __key) {",
			"            auto dfs = [&](auto self, treenode *cur, int left, int right) -> treenode * {",
			"                if (!cur) return nullptr;",
			"                cur->root = erase(cur->root, __key);",
			"                if (left < right) {",
			"                    if (int mid = (left + right) / 2; __i <= mid)",
			"                        cur->lchild = self(self, cur->lchild, left, mid);",
			"                    else",
			"                        cur->rchild = self(self, cur->rchild, mid + 1, right);",
			"                }",
			"                return cur;",
			"            };",
			"            m_root = dfs(dfs, m_root, 0, m_length - 1);",
			"        }",
			"        int rank(int __left, int __right, _Tp __key) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += rank(root, __key);",
			"            return sum;",
			"        }",
			"        node *kth(int __left, int __right, int __k, _Tp __min, _Tp __max) const {",
			"            std::vector<node *> roots = find_roots(__left, __right);",
			"            int len = __max - __min;",
			"            while (len) {",
			"                int half = len + 1 >> 1;",
			"                auto mid = __min + half;",
			"                int sum = 0;",
			"                for (node *root : roots) sum += rank(root, mid);",
			"                if (sum > __k) {",
			"                    __max = mid - 1;",
			"                    len = half - 1;",
			"                } else {",
			"                    __min = mid;",
			"                    len -= half;",
			"                }",
			"            }",
			"            for (node *root : roots)",
			"                if (auto it = find(root, __min)) return it;",
			"            return nullptr;",
			"        }",
			"        node *lower_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = lower_bound(root, __key); it && (!res || m_comp(it->key, res->key))) res = it;",
			"            return res;",
			"        }",
			"        node *upper_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = upper_bound(root, __key); it && (!res || m_comp(it->key, res->key))) res = it;",
			"            return res;",
			"        }",
			"        node *smaller_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = smaller_bound(root, __key); it && (!res || m_comp(res->key, it->key))) res = it;",
			"            return res;",
			"        }",
			"        int size(int __left, int __right) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += size(root);",
			"            return sum;",
			"        }",
			"        bool empty(int __left, int __right) const {",
			"            for (auto root : find_roots(__left, __right))",
			"                if (size(root)) return false;",
			"            return true;",
			"        }",
			"        int count(int __left, int __right, _Tp __key) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += count(root, __key);",
			"            return sum;",
			"        }",
			"        std::vector<node *> find_roots(int __left, int __right) const {",
			"            static std::vector<node *> res;",
			"            res.clear();",
			"            auto dfs = [&](auto self, treenode *cur, int left, int right) {",
			"                if (!cur) return;",
			"                if (left >= __left && right <= __right) {",
			"                    if (cur->root) res.push_back(cur->root);",
			"                } else {",
			"                    int mid = (left + right) / 2;",
			"                    if (__left <= mid) self(self, cur->lchild, left, mid);",
			"                    if (__right > mid) self(self, cur->rchild, mid + 1, right);",
			"                }",
			"            };",
			"            dfs(dfs, m_root, 0, m_length - 1);",
			"            return res;",
			"        }",
			"        template <typename... Args>",
			"        node *insert(node *__root, _Tp __key, Args... __args) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return _Tag::multi_key || res ? rbalance(cur) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return _Tag::multi_key || res ? lbalance(cur) : cur;",
			"                };",
			"            };",
			"            return dfs(dfs, __root);",
			"        }",
			"        node *update(node *__root, _Tp __key, _Fp __value) {",
			"            if (auto p = find(__root, __key))",
			"                p->value = __value;",
			"            else",
			"                __root = insert(__root, __key, __value);",
			"            return __root;",
			"        }",
			"        node *erase(node *__cur, _Tp __key) {",
			"            if (!__cur)",
			"                return nullptr;",
			"            else if (m_comp(__key, __cur->key)) {",
			"                __cur->lchild = erase(__cur->lchild, __key);",
			"            } else if (m_comp(__cur->key, __key)) {",
			"                __cur->rchild = erase(__cur->rchild, __key);",
			"            } else if (!__cur->rchild) {",
			"                delete __cur;",
			"                return __cur->lchild;",
			"            } else {",
			"                node *res;",
			"                __cur->rchild = deleteMin(__cur->rchild, res);",
			"                res->lchild = __cur->lchild;",
			"                res->rchild = __cur->rchild;",
			"                delete __cur;",
			"                __cur = res;",
			"            }",
			"            return update(__cur);",
			"        }",
			"        int rank(node *__root, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = __root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        node *kth(node *__root, int __k) const {",
			"            node *cur = __root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        node *find(node *__root, _Tp __key) const {",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        node *lower_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        node *upper_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        node *smaller_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(node *__root) const { return subtree_weight(__root); }",
			"        bool empty(node *__root) const { return !size(__root); }",
			"        int count(node *__root, _Tp __key) const {",
			"            auto it1 = lower_bound(__root, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__root, __key);",
			"            if (!it2)",
			"                return size(__root) - rank(__root, __key);",
			"            else",
			"                return rank(__root, it2->key) - rank(__root, __key);",
			"        }",
			"    };",
			"    namespace SizeBalancedSegTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = SizeBalancedSegTree<_Tp, bool, _Compare, SizeBalancedSegTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = SizeBalancedSegTree<_Tp, bool, _Compare, SizeBalancedSegTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = SizeBalancedSegTree<_Tp, _Fp, _Compare, SizeBalancedSegTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "size balanced segtree"
	},
	"size balanced zkwtree":{
		"prefix": "SBZKW",
		"body": [
			"namespace OY {",
			"    struct SizeBalancedZkwTreeSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedZkwTreeMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SizeBalancedZkwTreeMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _SizeBalancedZkwTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SizeBalancedZkwTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = SizeBalancedZkwTreeMultisetTag>",
			"    class SizeBalancedZkwTree {",
			"#pragma pack(4)",
			"        struct node : _SizeBalancedZkwTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"#pragma pack()",
			"        std::vector<node *> m_sub;",
			"        _Compare m_comp;",
			"        int m_length;",
			"        int m_depth;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static int lchild_weight(node *p) { return p && p->lchild ? p->lchild->subtree_weight : 0; }",
			"        static int rchild_weight(node *p) { return p && p->rchild ? p->rchild->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        static node *lbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->lchild) < lchild_weight(cur->rchild))",
			"                cur = rlrotate(cur);",
			"            else if (subtree_weight(cur->lchild) < rchild_weight(cur->rchild))",
			"                cur = lrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *rbalance(node *cur) {",
			"            if (!cur) return cur;",
			"            if (subtree_weight(cur->rchild) < rchild_weight(cur->lchild))",
			"                cur = lrrotate(cur);",
			"            else if (subtree_weight(cur->rchild) < lchild_weight(cur->lchild))",
			"                cur = rrotate(cur);",
			"            else",
			"                return update(cur);",
			"            cur->lchild = rbalance(cur->lchild);",
			"            cur->rchild = lbalance(cur->rchild);",
			"            return rbalance(lbalance(cur));",
			"        }",
			"        static node *deleteMin(node *cur, node *&res) {",
			"            if (!cur) return nullptr;",
			"            if (!cur->lchild) {",
			"                res = cur;",
			"                return cur->rchild;",
			"            } else {",
			"                cur->lchild = deleteMin(cur->lchild, res);",
			"                return update(cur);",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        SizeBalancedZkwTree(int __n = 0, _Compare __comp = _Compare()) : m_comp(__comp) { resize(__n); }",
			"        template <typename _Iterator>",
			"        SizeBalancedZkwTree(_Iterator __first, _Iterator __last, _Compare __comp = _Compare()) : m_comp(__comp) { reset(__first, __last); }",
			"        ~SizeBalancedZkwTree() { clear(); }",
			"        void resize(int __n) {",
			"            clear();",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.assign(1 << (m_depth + 1), nullptr);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            static_assert(!_Tag::is_map);",
			"            clear();",
			"            auto makenode = [&](auto self, auto first, auto last) -> node * {",
			"                if (first == last) return nullptr;",
			"                auto mid = first + (last - first) / 2;",
			"                return new node{*mid, int(last - first), self(self, first, mid), self(self, mid + 1, last)};",
			"            };",
			"            std::vector<_Tp> data(__first, __last);",
			"            m_length = data.size();",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.assign(1 << (m_depth + 1), nullptr);",
			"            for (int d = m_depth, len = 1; d >= 0; d--, len <<= 1) {",
			"                int it = 0;",
			"                int i = 1 << d, o = m_length - len;",
			"                for (; it <= o; i++, it += len) {",
			"                    if (len > 1) std::inplace_merge(data.data() + it, data.data() + it + len / 2, data.data() + it + len);",
			"                    m_sub[i] = makenode(makenode, data.data() + it, data.data() + it + len);",
			"                }",
			"                if (len > 1 and m_length - it > len / 2) std::inplace_merge(data.data() + it, data.data() + it + len / 2, data.data() + m_length);",
			"                m_sub[i] = makenode(makenode, data.data() + it, data.data() + m_length);",
			"            }",
			"        }",
			"        void clear() {",
			"            m_sub.clear();",
			"        }",
			"        template <typename... Args>",
			"        void insert(int __i, _Tp __key, Args... __args) {",
			"            for (int i = __i + (1 << m_depth); i; i >>= 1) m_sub[i] = insert(m_sub[i], __key, __args...);",
			"        }",
			"        void update(int __i, _Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            for (int i = __i + (1 << m_depth); i; i >>= 1) m_sub[i] = update(m_sub[i], __key, __value);",
			"        }",
			"        void erase(int __i, _Tp __key) {",
			"            for (int i = __i + (1 << m_depth); i; i >>= 1) m_sub[i] = erase(m_sub[i], __key);",
			"        }",
			"        int rank(int __left, int __right, _Tp __key) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += rank(root, __key);",
			"            return sum;",
			"        }",
			"        node *kth(int __left, int __right, int __k, _Tp __min, _Tp __max) const {",
			"            std::vector<node *> roots = find_roots(__left, __right);",
			"            int len = __max - __min;",
			"            while (len) {",
			"                int half = len + 1 >> 1;",
			"                auto mid = __min + half;",
			"                int sum = 0;",
			"                for (node *root : roots) sum += rank(root, mid);",
			"                if (sum > __k) {",
			"                    __max = mid - 1;",
			"                    len = half - 1;",
			"                } else {",
			"                    __min = mid;",
			"                    len -= half;",
			"                }",
			"            }",
			"            for (node *root : roots)",
			"                if (auto it = find(root, __min)) return it;",
			"            return nullptr;",
			"        }",
			"        node *lower_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = lower_bound(root, __key); it && (!res || m_comp(it->key, res->key))) res = it;",
			"            return res;",
			"        }",
			"        node *upper_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = upper_bound(root, __key); it && (!res || m_comp(it->key, res->key))) res = it;",
			"            return res;",
			"        }",
			"        node *smaller_bound(int __left, int __right, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (auto root : find_roots(__left, __right))",
			"                if (auto it = smaller_bound(root, __key); it && (!res || m_comp(res->key, it->key))) res = it;",
			"            return res;",
			"        }",
			"        int size(int __left, int __right) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += size(root);",
			"            return sum;",
			"        }",
			"        bool empty(int __left, int __right) const {",
			"            for (auto root : find_roots(__left, __right))",
			"                if (size(root)) return false;",
			"            return true;",
			"        }",
			"        int count(int __left, int __right, _Tp __key) const {",
			"            int sum = 0;",
			"            for (auto root : find_roots(__left, __right)) sum += count(root, __key);",
			"            return sum;",
			"        }",
			"        std::vector<node *> find_roots(int __left, int __right) const {",
			"            static std::vector<node *> res;",
			"            res.clear();",
			"            __left += 1 << m_depth;",
			"            __right += 1 << m_depth;",
			"            if (__left < __right) {",
			"                if (m_sub[__left]) res.push_back(m_sub[__left]);",
			"                int j = 31 - std::__countl_zero(__left ^ __right);",
			"                for (int i = 0; i < j; i++)",
			"                    if (!(__left >> i & 1) && m_sub[__left >> i ^ 1]) res.push_back(m_sub[__left >> i ^ 1]);",
			"                for (int i = j - 1; i >= 0; i--)",
			"                    if ((__right >> i & 1) && m_sub[__right >> i ^ 1]) res.push_back(m_sub[__right >> i ^ 1]);",
			"                if (m_sub[__right]) res.push_back(m_sub[__right]);",
			"            } else if (m_sub[__left])",
			"                res.push_back(m_sub[__left]);",
			"            return res;",
			"        }",
			"        template <typename... Args>",
			"        node *insert(node *__root, _Tp __key, Args... __args) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) {",
			"                if (!cur) {",
			"                    res = true;",
			"                    return new node{__key, __args..., 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return _Tag::multi_key || res ? rbalance(cur) : cur;",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return _Tag::multi_key || res ? lbalance(cur) : cur;",
			"                };",
			"            };",
			"            return dfs(dfs, __root);",
			"        }",
			"        node *update(node *__root, _Tp __key, _Fp __value) {",
			"            if (auto p = find(__root, __key))",
			"                p->value = __value;",
			"            else",
			"                __root = insert(__root, __key, __value);",
			"            return __root;",
			"        }",
			"        node *erase(node *__cur, _Tp __key) {",
			"            if (!__cur)",
			"                return nullptr;",
			"            else if (m_comp(__key, __cur->key))",
			"                __cur->lchild = erase(__cur->lchild, __key);",
			"            else if (m_comp(__cur->key, __key))",
			"                __cur->rchild = erase(__cur->rchild, __key);",
			"            else if (!__cur->rchild) {",
			"                delete __cur;",
			"                return __cur->lchild;",
			"            } else {",
			"                node *res;",
			"                __cur->rchild = deleteMin(__cur->rchild, res);",
			"                res->lchild = __cur->lchild;",
			"                res->rchild = __cur->rchild;",
			"                delete __cur;",
			"                __cur = res;",
			"            }",
			"            return update(__cur);",
			"        }",
			"        int rank(node *__root, _Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = __root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        node *kth(node *__root, int __k) const {",
			"            node *cur = __root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        node *find(node *__root, _Tp __key) const {",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        node *lower_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        node *upper_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        node *smaller_bound(node *__root, _Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = __root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size(node *__root) const { return subtree_weight(__root); }",
			"        bool empty(node *__root) const { return !size(__root); }",
			"        int count(node *__root, _Tp __key) const {",
			"            auto it1 = lower_bound(__root, __key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__root, __key);",
			"            if (!it2)",
			"                return size(__root) - rank(__root, __key);",
			"            else",
			"                return rank(__root, it2->key) - rank(__root, __key);",
			"        }",
			"    };",
			"    namespace SizeBalancedZkwTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = SizeBalancedZkwTree<_Tp, bool, _Compare, SizeBalancedZkwTreeSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = SizeBalancedZkwTree<_Tp, bool, _Compare, SizeBalancedZkwTreeMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = SizeBalancedZkwTree<_Tp, _Fp, _Compare, SizeBalancedZkwTreeMapTag>;",
			"    }",
			"}",
		],
		"description": "size balanced zkwtree"
	},
	"skip list":{
		"prefix": "SKIP",
		"body": [
			"namespace OY {",
			"    struct SkipListSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SkipListMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SkipListMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, typename _Tag>",
			"    struct _SkipListNode;",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SkipListNode<_Tp, _Fp, SkipListSetTag> { _Tp key; };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SkipListNode<_Tp, _Fp, SkipListMultisetTag> {",
			"        _Tp key;",
			"        int _node_weight;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SkipListNode<_Tp, _Fp, SkipListMapTag> {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp = int, typename _Compare = std::less<_Tp>, typename _Tag = SkipListMultisetTag>",
			"    class SkipList {",
			"        struct node : _SkipListNode<_Tp, _Fp, _Tag> {",
			"            constexpr int node_weight() {",
			"                if constexpr (_Tag::multi_key)",
			"                    return this->_node_weight;",
			"                else",
			"                    return 1;",
			"            }",
			"            struct node_next {",
			"                node *pointer;",
			"                int distance;",
			"            };",
			"            std::vector<node_next> next;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"        node *m_head;",
			"        _Compare m_comp;",
			"        int m_height;",
			"        int m_size;",
			"        static bool testJump() { return rand() % 100 < 53; }",
			"        template <typename... Args>",
			"        int _insert(node *cur, int h, node *&res, _Tp __key, Args... __args) {",
			"            int distance = 0;",
			"            while (true) {",
			"                auto &&[nxt, dis] = cur->next[h];",
			"                if (!nxt || m_comp(__key, nxt->key))",
			"                    break;",
			"                else if (m_comp(nxt->key, __key)) {",
			"                    distance += dis + nxt->node_weight();",
			"                    cur = nxt;",
			"                } else {",
			"                    if constexpr (_Tag::multi_key) {",
			"                        res = nxt;",
			"                        res->_node_weight++;",
			"                        return distance + dis;",
			"                    } else",
			"                        return -1;",
			"                }",
			"            }",
			"            if (h) {",
			"                int next_level_distance = _insert(cur, h - 1, res, __key, __args...);",
			"                if (!res) return -1;",
			"                auto &&[nxt, dis] = cur->next[h];",
			"                dis++;",
			"                if (next_level_distance < 0) return -1;",
			"                if (!testJump()) {",
			"                    res->next.shrink_to_fit();",
			"                    return -1;",
			"                }",
			"                res->next.push_back({nxt, dis - next_level_distance - res->node_weight()});",
			"                cur->next[h] = {res, next_level_distance};",
			"                return distance + next_level_distance;",
			"            } else {",
			"                node *nxt = cur->next[h].pointer;",
			"                res = new node{__key, __args..., {{nxt, 0}}};",
			"                cur->next[h] = {res, 0};",
			"                return distance;",
			"            }",
			"        }",
			"        node *_erase(node *cur, int h, _Tp key) {",
			"            while (node *nxt = cur->next[h].pointer) {",
			"                if (!m_comp(nxt->key, key)) break;",
			"                cur = nxt;",
			"            }",
			"            if (h) {",
			"                if (node *res = _erase(cur, h - 1, key)) {",
			"                    if (cur->next[h].pointer != res)",
			"                        cur->next[h].distance--;",
			"                    else if (!_Tag::multi_key || !res->node_weight())",
			"                        cur->next[h] = {res->next[h].pointer, cur->next[h].distance + res->next[h].distance};",
			"                    return res;",
			"                } else",
			"                    return nullptr;",
			"            } else if (node *nxt = cur->next[h].pointer; !nxt || m_comp(key, nxt->key))",
			"                return nullptr;",
			"            else {",
			"                if constexpr (_Tag::multi_key) nxt->_node_weight--;",
			"                if (!_Tag::multi_key || !nxt->node_weight()) cur->next[h].pointer = nxt->next[h].pointer;",
			"                return nxt;",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        SkipList() : m_height(1), m_size(0) {",
			"            m_head = new node;",
			"            m_head->next.push_back({nullptr, 0});",
			"        }",
			"        void clear() {",
			"            m_head = nullptr;",
			"        }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            node *res = nullptr;",
			"            int distance;",
			"            if constexpr (_Tag::multi_key)",
			"                distance = _insert(m_head, m_height - 1, res, __key, __args..., 1);",
			"            else",
			"                distance = _insert(m_head, m_height - 1, res, __key, __args...);",
			"            m_size += bool(res);",
			"            if (distance < 0 || !testJump()) return;",
			"            m_height++;",
			"            m_head->next.push_back({res, distance});",
			"            res->next.push_back({nullptr, m_size - distance - res->node_weight()});",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            if (node *res = _erase(m_head, m_height - 1, __key)) {",
			"                if (!_Tag::multi_key || !res->node_weight()) delete res;",
			"                m_size--;",
			"                return true;",
			"            } else",
			"                return false;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            node *cur = m_head;",
			"            int ord = 0;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer && m_comp(cur->next[h].pointer->key, __key)) {",
			"                    ord += cur->next[h].distance + cur->next[h].pointer->node_weight();",
			"                    cur = cur->next[h].pointer;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            if (__k < 0 || __k >= m_size) return nullptr;",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].distance <= __k) {",
			"                    __k -= cur->next[h].distance;",
			"                    if (__k -= cur->next[h].pointer->node_weight(); __k < 0)",
			"                        return cur->next[h].pointer;",
			"                    else",
			"                        cur = cur->next[h].pointer;",
			"                }",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer) {",
			"                    if (m_comp(cur->next[h].pointer->key, __key))",
			"                        cur = cur->next[h].pointer;",
			"                    else if (!m_comp(__key, cur->next[h].pointer->key))",
			"                        return cur->next[h].pointer;",
			"                    else",
			"                        break;",
			"                }",
			"            return nullptr;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer && m_comp(cur->next[h].pointer->key, __key)) cur = cur->next[h].pointer;",
			"            return cur;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer) {",
			"                    if (m_comp(cur->next[h].pointer->key, __key))",
			"                        cur = cur->next[h].pointer;",
			"                    else if (!m_comp(__key, cur->next[h].pointer->key))",
			"                        return cur->next[h].pointer;",
			"                    else",
			"                        break;",
			"                }",
			"            return nullptr;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *cur = m_head;",
			"            for (int h = m_height - 1; ~h; h--)",
			"                while (cur->next[h].pointer && !m_comp(__key, cur->next[h].pointer->key)) cur = cur->next[h].pointer;",
			"            return cur->next[0].pointer;",
			"        }",
			"        int size() const { return m_size; }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            if (auto it = find(__key))",
			"                return it->node_weight();",
			"            else",
			"                return 0;",
			"        }",
			"    };",
			"    namespace SkipListContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = SkipList<_Tp, bool, _Compare, SkipListSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = SkipList<_Tp, bool, _Compare, SkipListMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = SkipList<_Tp, _Fp, _Compare, SkipListMapTag>;",
			"    }",
			"}",
		],
		"description": "skip list"
	},
	"splay":{
		"prefix": "SPLAY",
		"body": [
			"namespace OY {",
			"    struct SplaySetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SplayMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct SplayMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _SplayNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _SplayNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = SplayMultisetTag>",
			"    class Splay {",
			"        struct node : _SplayNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node*)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        int m_state;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            if (p) p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *rrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *s = q->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            q->lchild = s->rchild;",
			"            s->rchild = update(q);",
			"            return s;",
			"        }",
			"        static node *llrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *s = q->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            q->rchild = s->lchild;",
			"            s->lchild = update(q);",
			"            return s;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        node *update_from_lchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 1;",
			"            if (m_state == 3) {",
			"                m_state = 0;",
			"                return rrrotate(cur);",
			"            } else if (m_state == 5) {",
			"                m_state = 0;",
			"                return lrrotate(cur);",
			"            } else if (m_state == 1 && cur == root)",
			"                return rrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *update_from_rchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 2;",
			"            if (m_state == 4) {",
			"                m_state = 0;",
			"                return rlrotate(cur);",
			"            } else if (m_state == 6) {",
			"                m_state = 0;",
			"                return llrotate(cur);",
			"            } else if (m_state == 2 && cur == root)",
			"                return lrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *splay_max(node *cur, node *const &root) {",
			"            if (cur->rchild) {",
			"                cur->rchild = splay_max(cur->rchild, root);",
			"                m_state++;",
			"                if (m_state == 2) {",
			"                    m_state = 0;",
			"                    return llrotate(cur);",
			"                } else if (m_state == 1 && cur == root)",
			"                    return lrotate(cur);",
			"            } else",
			"                m_state = 0;",
			"            return cur;",
			"        }",
			"        node *splay_kth(node *cur, node *const &root, int k) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (k < subtree_weight(cur->lchild)) {",
			"                cur->lchild = splay_kth(cur->lchild, root, k);",
			"                return update_from_lchild(cur, root);",
			"            } else if (k -= subtree_weight(cur->lchild); k--) {",
			"                cur->rchild = splay_kth(cur->rchild, root, k);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        template <typename... Args>",
			"        node *splay_insert(node *cur, node *const &root, _Tp key, Args... args) {",
			"            if (!cur) {",
			"                m_state = 0;",
			"                return new node{key, args..., 1, nullptr, nullptr};",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_insert(cur->lchild, root, key, args...);",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                if constexpr (!_Tag::multi_key) {",
			"                    if (!m_comp(cur->key, key)) {",
			"                        m_state = -1;",
			"                        return cur;",
			"                    }",
			"                }",
			"                cur->rchild = splay_insert(cur->rchild, root, key, args...);",
			"                return update_from_rchild(cur, root);",
			"            }",
			"        }",
			"        node *splay_find(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_find(cur->lchild, root, key);",
			"                return update_from_lchild(cur, root);",
			"            } else if (m_comp(cur->key, key)) {",
			"                cur->rchild = splay_find(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        node *splay_smaller_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(cur->key, key)) {",
			"                cur->rchild = splay_smaller_bound(cur->rchild, root, key);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                cur->lchild = splay_smaller_bound(cur->lchild, root, key);",
			"                return update_from_lchild(cur, root);",
			"            }",
			"        }",
			"        node *splay_upper_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (m_comp(key, cur->key)) {",
			"                cur->lchild = splay_upper_bound(cur->lchild, root, key);",
			"                if (m_state < 0) {",
			"                    m_state = 0;",
			"                    return cur;",
			"                }",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                cur->rchild = splay_upper_bound(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            }",
			"        }",
			"        node *splay_lower_bound(node *cur, node *const &root, const _Tp &key) {",
			"            if (!cur) {",
			"                m_state = -1;",
			"                return nullptr;",
			"            } else if (!m_comp(cur->key, key)) {",
			"                cur->lchild = splay_lower_bound(cur->lchild, root, key);",
			"                if (m_state < 0) {",
			"                    m_state = 0;",
			"                    return cur;",
			"                }",
			"                return update_from_lchild(cur, root);",
			"            } else {",
			"                cur->rchild = splay_lower_bound(cur->rchild, root, key);",
			"                return ~m_state ? update_from_rchild(cur, root) : cur;",
			"            }",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        Splay(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(Args... __args) { m_root = update(splay_insert(m_root, m_root, __args...)); }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            m_root = update(splay_find(m_root, m_root, __key));",
			"            if (!~m_state) return false;",
			"            delete m_root;",
			"            node *r = m_root->rchild;",
			"            if (m_root->lchild) {",
			"                m_root = update(splay_max(m_root->lchild, m_root->lchild));",
			"                if (r) {",
			"                    m_root->rchild = r;",
			"                    update(m_root);",
			"                }",
			"            } else",
			"                m_root = r;",
			"            return true;",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) {",
			"            m_root = update(splay_lower_bound(m_root, m_root, __key));",
			"            return ~m_state ? subtree_weight(m_root->lchild) : subtree_weight(m_root);",
			"        }",
			"        const node *kth(int __k) {",
			"            m_root = update(splay_kth(m_root, m_root, __k));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        const node *find(_Tp __key) {",
			"            m_root = update(splay_find(m_root, m_root, __key));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) {",
			"            m_root = update(splay_lower_bound(m_root, m_root, __key));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        const node *upper_bound(_Tp __key) {",
			"            m_root = update(splay_upper_bound(m_root, m_root, __key));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        const node *smaller_bound(_Tp __key) {",
			"            m_root = update(splay_smaller_bound(m_root, m_root, __key));",
			"            return ~m_state ? m_root : nullptr;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) {",
			"            if (!(m_root = update(lower_bound(m_root, m_root, __key)))) return 0;",
			"            int smaller = subtree_weight(m_root->lchild);",
			"            if (!(m_root = update(upper_bound(m_root, m_root, __key))))",
			"                return size() - smaller;",
			"            else",
			"                return subtree_weight(m_root->lchild) - smaller;",
			"        }",
			"    };",
			"    namespace SplayContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = Splay<_Tp, bool, _Compare, SplaySetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = Splay<_Tp, bool, _Compare, SplayMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = Splay<_Tp, _Fp, _Compare, SplayMapTag>;",
			"    }",
			"}",
		],
		"description": "splay"
	},
	"splay array":{
		"prefix": "SPLAY",
		"body": [
			"namespace OY {",
			"    template <typename _Tp>",
			"    class SplayArray {",
			"        struct node : MemoryPool<node> {",
			"            _Tp key;",
			"            bool reversed;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            node() = default;",
			"            void reverse() { reversed = reversed ? false : true; }",
			"            void push_down() {",
			"                reverse();",
			"                std::swap(lchild, rchild);",
			"                if (lchild) lchild->reverse();",
			"                if (rchild) rchild->reverse();",
			"            }",
			"        };",
			"        node *m_root;",
			"        int m_state;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            if (p) p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return q;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return q;",
			"        }",
			"        static node *rrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *s = q->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            q->lchild = s->rchild;",
			"            s->rchild = update(q);",
			"            return s;",
			"        }",
			"        static node *llrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *s = q->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            q->rchild = s->lchild;",
			"            s->lchild = update(q);",
			"            return s;",
			"        }",
			"        static node *lrrotate(node *p) {",
			"            node *q = p->lchild;",
			"            node *r = q->rchild;",
			"            q->rchild = r->lchild;",
			"            p->lchild = r->rchild;",
			"            r->lchild = update(q);",
			"            r->rchild = update(p);",
			"            return r;",
			"        }",
			"        static node *rlrotate(node *p) {",
			"            node *q = p->rchild;",
			"            node *r = q->lchild;",
			"            q->lchild = r->rchild;",
			"            p->rchild = r->lchild;",
			"            r->rchild = update(q);",
			"            r->lchild = update(p);",
			"            return r;",
			"        }",
			"        node *update_from_lchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 1;",
			"            if (m_state == 3) {",
			"                m_state = 0;",
			"                return rrrotate(cur);",
			"            } else if (m_state == 5) {",
			"                m_state = 0;",
			"                return lrrotate(cur);",
			"            } else if (m_state == 1 && cur == root)",
			"                return rrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *update_from_rchild(node *cur, node *root) {",
			"            m_state = m_state * 2 + 2;",
			"            if (m_state == 4) {",
			"                m_state = 0;",
			"                return rlrotate(cur);",
			"            } else if (m_state == 6) {",
			"                m_state = 0;",
			"                return llrotate(cur);",
			"            } else if (m_state == 2 && cur == root)",
			"                return lrotate(cur);",
			"            else",
			"                return cur;",
			"        }",
			"        node *splay_max(node *cur, node *const &root) {",
			"            if (cur->reversed) cur->push_down();",
			"            if (cur->rchild) {",
			"                cur->rchild = splay_max(cur->rchild, root);",
			"                m_state++;",
			"                if (m_state == 2) {",
			"                    m_state = 0;",
			"                    return llrotate(cur);",
			"                } else if (m_state == 1 && cur == root)",
			"                    return lrotate(cur);",
			"            } else",
			"                m_state = 0;",
			"            return cur;",
			"        }",
			"        node *splay_min(node *cur, node *const &root) {",
			"            if (cur->reversed) cur->push_down();",
			"            if (cur->lchild) {",
			"                cur->lchild = splay_min(cur->lchild, root);",
			"                m_state++;",
			"                if (m_state == 2) {",
			"                    m_state = 0;",
			"                    return rrrotate(cur);",
			"                } else if (m_state == 1 && cur == root)",
			"                    return rrotate(cur);",
			"            } else",
			"                m_state = 0;",
			"            return cur;",
			"        }",
			"        node *splay_kth(node *cur, node *const &root, int k) {",
			"            if (cur->reversed) cur->push_down();",
			"            if (k < subtree_weight(cur->lchild)) {",
			"                cur->lchild = splay_kth(cur->lchild, root, k);",
			"                return update_from_lchild(cur, root);",
			"            } else if (k -= subtree_weight(cur->lchild); k) {",
			"                cur->rchild = splay_kth(cur->rchild, root, k - 1);",
			"                return update_from_rchild(cur, root);",
			"            } else {",
			"                m_state = 0;",
			"                return cur;",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        node *make_tree(_Iterator first, _Iterator last) {",
			"            auto _make_tree = [](auto self, _Iterator first, _Iterator last) -> node * {",
			"                if (first == last) return nullptr;",
			"                if (first + 1 == last) return new node{{}, *first, false, 1, nullptr, nullptr};",
			"                _Iterator mid = first + (last - first) / 2;",
			"                node *p = new node{{}, *mid, false, 1, self(self, first, mid), self(self, mid + 1, last)};",
			"                return update(p);",
			"            };",
			"            return _make_tree(_make_tree, first, last);",
			"        }",
			"        void _clear(node *cur) {",
			"            if (cur->lchild) _clear(cur->lchild);",
			"            if (cur->rchild) _clear(cur->rchild);",
			"            delete cur;",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        SplayArray() : m_root(nullptr) {}",
			"        template <typename _Iterator>",
			"        SplayArray(_Iterator __first, _Iterator __last) : m_root(make_tree(__first, __last)) {}",
			"        void clear() {",
			"            m_root = nullptr;",
			"        }",
			"        void insert(int __pos, _Tp __key) {",
			"            if (!__pos)",
			"                push_front(__key);",
			"            else if (__pos == size())",
			"                push_back(__key);",
			"            else {",
			"                m_root = splay_kth(m_root, m_root, __pos);",
			"                node *p = new node{{}, __key, false, 1, m_root->lchild, nullptr};",
			"                m_root->lchild = nullptr;",
			"                p->rchild = update(m_root);",
			"                m_root = update(p);",
			"            }",
			"        }",
			"        void update(int __pos, _Tp __key) { at(__pos)->key = __key; }",
			"        void erase(int __pos) {",
			"            if (!__pos)",
			"                pop_front();",
			"            else if (__pos == size() - 1)",
			"                pop_back();",
			"            else {",
			"                m_root = splay_kth(m_root, m_root, __pos);",
			"                m_root->lchild = splay_max(m_root->lchild, m_root->lchild);",
			"                m_root->lchild->rchild = m_root->rchild;",
			"                delete m_root;",
			"                m_root = update(m_root->lchild);",
			"            }",
			"        }",
			"        void erase(int __left, int __right) {",
			"            if (!__left) {",
			"                node *p = splay_kth(m_root, m_root, __right);",
			"                m_root = p->rchild;",
			"                p->rchild = nullptr;",
			"                _clear(p);",
			"            } else if (__right == size() - 1) {",
			"                node *p = splay_kth(m_root, m_root, __left);",
			"                m_root = p->lchild;",
			"                p->lchild = nullptr;",
			"                _clear(p);",
			"            } else {",
			"                node *p = splay_kth(m_root, m_root, __right + 1);",
			"                node *q = splay_kth(p->lchild, p->lchild, __left);",
			"                p->lchild = q->lchild;",
			"                m_root = update(p);",
			"                q->lchild = nullptr;",
			"                _clear(q);",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void assign(_Iterator __first, _Iterator __last) {",
			"            clear();",
			"            m_root = make_tree(__first, __last);",
			"        }",
			"        void reverse(int __left, int __right) {",
			"            if (!__left) {",
			"                if (__right == size() - 1)",
			"                    m_root->reverse();",
			"                else {",
			"                    m_root = update(splay_kth(m_root, m_root, __right + 1));",
			"                    m_root->lchild->reverse();",
			"                }",
			"            } else if (__right == size() - 1) {",
			"                m_root = update(splay_kth(m_root, m_root, __left - 1));",
			"                m_root->rchild->reverse();",
			"            } else {",
			"                m_root = update(splay_kth(m_root, m_root, __right + 1));",
			"                m_root->lchild = update(splay_kth(m_root->lchild, m_root->lchild, __left - 1));",
			"                m_root->lchild->rchild->reverse();",
			"            }",
			"        }",
			"        void push_front(_Tp __key) {",
			"            if (!m_root)",
			"                m_root = new node{{}, __key, false, 1, nullptr, nullptr};",
			"            else {",
			"                m_root = splay_min(m_root, m_root);",
			"                m_root->lchild = new node{{}, __key, false, 1, nullptr, nullptr};",
			"                m_root = update(m_root);",
			"            }",
			"        }",
			"        void pop_front() {",
			"            m_root = splay_min(m_root, m_root);",
			"            delete m_root;",
			"            m_root = m_root->rchild;",
			"        }",
			"        void push_back(_Tp __key) {",
			"            if (!m_root)",
			"                m_root = new node{{}, __key, false, 1, nullptr, nullptr};",
			"            else {",
			"                m_root = splay_max(m_root, m_root);",
			"                m_root->rchild = new node{{}, __key, false, 1, nullptr, nullptr};",
			"                m_root = update(m_root);",
			"            }",
			"        }",
			"        void pop_back() {",
			"            m_root = splay_max(m_root, m_root);",
			"            delete m_root;",
			"            m_root = m_root->lchild;",
			"        }",
			"        node *at(int __pos) { return m_root = update(splay_kth(m_root, m_root, __pos)); }",
			"        _Tp &operator[](int __index) { return at(__index)->key; }",
			"        node *front() { return m_root = update(splay_min(m_root, m_root)); }",
			"        node *back() { return m_root = update(splay_max(m_root, m_root)); }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        SplayArray<_Tp> subArray(int __left, int __right) {",
			"            SplayArray<_Tp> sub;",
			"            if (!__left) {",
			"                node *p = splay_kth(m_root, m_root, __right);",
			"                m_root = p->rchild;",
			"                p->rchild = nullptr;",
			"                sub.m_root = update(p);",
			"            } else if (__right == size() - 1) {",
			"                node *p = splay_kth(m_root, m_root, __left);",
			"                m_root = p->lchild;",
			"                p->lchild = nullptr;",
			"                sub.m_root = update(p);",
			"            } else {",
			"                node *p = splay_kth(m_root, m_root, __right + 1);",
			"                node *q = splay_kth(p->lchild, p->lchild, __left);",
			"                p->lchild = q->lchild;",
			"                m_root = update(p);",
			"                q->lchild = nullptr;",
			"                sub.m_root = update(q);",
			"            }",
			"            return sub;",
			"        }",
			"        void join(SplayArray<_Tp> &__other) {",
			"            m_root = splay_max(m_root, m_root);",
			"            m_root->rchild = __other.m_root;",
			"            __other.m_root = nullptr;",
			"            m_root = update(m_root);",
			"        }",
			"        std::vector<_Tp> to_vector() const {",
			"            std::vector<_Tp> v;",
			"            v.reserve(size());",
			"            auto dfs = [&](auto self, node *cur) -> void {",
			"                if (cur->reversed) cur->push_down();",
			"                if (cur->lchild) self(self, cur->lchild);",
			"                v.push_back(cur->key);",
			"                if (cur->rchild) self(self, cur->rchild);",
			"            };",
			"            if (m_root) dfs(dfs, m_root);",
			"            return v;",
			"        }",
			"    };",
			"    template <typename _Tp = int>",
			"    SplayArray() -> SplayArray<_Tp>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SplayArray(_Iterator, _Iterator) -> SplayArray<_Tp>;",
			"}",
		],
		"description": "splay array"
	},
	"sqrt tree":{
		"prefix": "SQRT",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = int64_t, typename _Operation = std::plus<_Tp>>",
			"    class SqrtTree {",
			"        int m_length;",
			"        int m_depth;",
			"        int m_mask;",
			"        int m_blockSize;",
			"        int m_blockCount;",
			"        std::vector<Accumulator<_Tp, _Operation, ACCUMULATE_PREFIX | ACCUMULATE_SUFFIX>> m_fix;",
			"        STTable<_Tp, _Operation> m_inter;",
			"        std::vector<ZkwTree<_Tp, _Operation>> m_subtree;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"",
			"    public:",
			"        SqrtTree(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp(), _Tp __initValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue), m_inter(0, __op, __defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        SqrtTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue), m_inter(0, __op, __defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32) >> 1;",
			"            while (std::__countr_zero(m_length) != m_depth) m_length++;",
			"            m_mask = (1 << m_depth) - 1;",
			"            m_blockSize = 1 << m_depth;",
			"            m_blockCount = m_length >> m_depth;",
			"            m_fix.clear();",
			"            m_fix.reserve(m_blockCount);",
			"            m_fix.emplace_back(m_blockSize, m_op, m_defaultValue);",
			"            for (int i = 1; i < m_blockCount; i++) m_fix.push_back(m_fix[0]);",
			"            m_subtree.clear();",
			"            m_subtree.reserve(m_blockCount);",
			"            m_subtree.emplace_back(m_blockSize, m_op, m_defaultValue);",
			"            for (int i = 1; i < m_blockCount; i++) m_subtree.push_back(m_subtree[0]);",
			"            std::vector<_Tp> sub_val(m_blockCount, m_subtree[0].queryAll());",
			"            m_inter.reset(sub_val.begin(), sub_val.end());",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32) >> 1;",
			"            while (std::__countr_zero(m_length) != m_depth) m_length++;",
			"            std::vector<_Tp> data;",
			"            data.reserve(m_length);",
			"            data.insert(data.end(), __first, __last);",
			"            data.insert(data.end(), m_length - (__last - __first), m_defaultValue);",
			"            m_mask = (1 << m_depth) - 1;",
			"            m_blockSize = 1 << m_depth;",
			"            m_blockCount = m_length >> m_depth;",
			"            m_fix.clear();",
			"            m_fix.reserve(m_blockCount);",
			"            for (int i = 0; i < m_blockCount; i++) m_fix.emplace_back(data.data() + i * m_blockSize, data.data() + (i + 1) * m_blockSize, m_op, m_defaultValue);",
			"            m_subtree.clear();",
			"            m_subtree.reserve(m_blockCount);",
			"            for (int i = 0; i < m_blockCount; i++) m_subtree.emplace_back(data.data() + i * m_blockSize, data.data() + (i + 1) * m_blockSize, m_op);",
			"            std::vector<_Tp> sub_val;",
			"            for (int i = 0; i < m_blockCount; i++) sub_val.push_back(m_subtree[i].queryAll());",
			"            m_inter.reset(sub_val.begin(), sub_val.end());",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            m_fix[__i >> m_depth].update(__i & m_mask, __val);",
			"            m_subtree[__i >> m_depth].update(__i & m_mask, __val);",
			"            m_inter.update(__i >> m_depth, m_subtree[__i >> m_depth].queryAll());",
			"        }",
			"        _Tp query(int __i) const { return m_subtree[__i >> m_depth].query(__i & m_mask); }",
			"        _Tp query(int __left, int __right) const {",
			"            int l1 = __left >> m_depth, l2 = __left & m_mask;",
			"            int r1 = __right >> m_depth, r2 = __right & m_mask;",
			"            if (l1 == r1)",
			"                return m_subtree[l1].query(l2, r2);",
			"            else if (l1 + 1 == r1)",
			"                return m_op(m_fix[l1].querySuffix(l2), m_fix[r1].queryPrefix(r2));",
			"            else",
			"                return m_op(m_op(m_fix[l1].querySuffix(l2), m_inter.query(l1 + 1, r1 - 1)), m_fix[r1].queryPrefix(r2));",
			"        }",
			"        _Tp queryAll() const { return m_inter.queryAll(); }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    SqrtTree(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int64_t>",
			"    SqrtTree(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    SqrtTree(int = 0, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SqrtTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    SqrtTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>>",
			"    SqrtTree(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> SqrtTree<_Tp, _Operation>;",
			"}",
			"",
		],
		"description": "sqrt tree"
	},
	"st table":{
        "prefix": "ST",
        "body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Maximum>",
			"    class STTable {",
			"        std::vector<std::vector<_Tp>> m_sub;",
			"        _Maximum m_maxi;",
			"        int m_length;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            // assert(m_maxi(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"",
			"    public:",
			"        STTable(int __n = 0, _Maximum __maxi = std::max<_Tp>, _Tp __defaultValue = _Tp()) : m_maxi(__maxi), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        STTable(_Iterator __first, _Iterator __last, _Maximum __maxi = std::max<_Tp>, _Tp __defaultValue = _Tp()) : m_maxi(__maxi), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            int d = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.resize(d);",
			"            m_sub[0].assign(__n, m_defaultValue);",
			"            for (int i = 1; i < d; i++) {",
			"                m_sub[i].clear();",
			"                m_sub[i].reserve(m_length - (1 << i) + 1);",
			"                for (int j = 0; j <= m_length - (1 << i); j++)",
			"                    m_sub[i].push_back(m_maxi(m_sub[i - 1][j], m_sub[i - 1][j + (1 << i - 1)]));",
			"            }",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            int d = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.resize(d);",
			"            m_sub[0].assign(__first, __last);",
			"            for (int i = 1; i < d; i++) {",
			"                m_sub[i].clear();",
			"                m_sub[i].reserve(m_length - (1 << i) + 1);",
			"                for (int j = 0; j <= m_length - (1 << i); j++)",
			"                    m_sub[i].push_back(m_maxi(m_sub[i - 1][j], m_sub[i - 1][j + (1 << i - 1)]));",
			"            }",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            m_sub[0][__i] = __val;",
			"            for (int i = 1; i < m_sub.size(); i++)",
			"                for (int j = std::max(0, __i - (1 << i) + 1), end = std::min(__i, int(m_sub[i].size() - 1)); j <= end; j++)",
			"                    m_sub[i][j] = m_maxi(m_sub[i - 1][j], m_sub[i - 1][j + (1 << i - 1)]);",
			"        }",
			"        _Tp query(int __i) const {",
			"            return m_sub[0][__i];",
			"        }",
			"        _Tp query(int __left, int __right) const {",
			"            if (__left == __right) return m_sub[0][__left];",
			"            int d = 31 - std::__countl_zero(__right - __left);",
			"            return m_maxi(m_sub[d][__left], m_sub[d][__right - (1 << d) + 1]);",
			"        }",
			"        _Tp queryAll() const {",
			"            return query(0, m_length - 1);",
			"        }",
			"    };",
			"    template <typename _Tp = int>",
			"    STTable(int = 0, const _Tp &(*)(const _Tp &, const _Tp &) = std::max<_Tp>, _Tp = _Tp()) -> STTable<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int>",
			"    STTable(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> STTable<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Maximum, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Maximum::operator()))::result_type>>",
			"    STTable(int, _Maximum, _Tp = _Tp()) -> STTable<_Tp, _Maximum>;",
			"    template <typename _Iterator, typename _Maximum, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    STTable(_Iterator, _Iterator, _Maximum, _Tp = _Tp()) -> STTable<_Tp, _Maximum>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    STTable(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &) = std::max<_Tp>, _Tp = _Tp()) -> STTable<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    STTable(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp()) -> STTable<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"}",
        ],
        "description": "st table"
    },
	"treap":{
		"prefix": "TREAP",
		"body": [
			"namespace OY {",
			"    struct TreapSetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct TreapMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct TreapMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _TreapNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _TreapNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = TreapMultisetTag>",
			"    class Treap {",
			"        struct node : _TreapNode<_Tp, _Fp, _Tag::is_map> {",
			"            uint_fast32_t priority;",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::operator delete(p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static inline std::mt19937 s_rand;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static uint_fast32_t subtree_priority(node *p) { return p ? p->priority : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = 1 + subtree_weight(p->lchild) + subtree_weight(p->rchild);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->rchild;",
			"            q->rchild = update(p);",
			"            return update(q);",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->lchild;",
			"            q->lchild = update(p);",
			"            return update(q);",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        Treap(_Compare __comp = _Compare()) : m_root(nullptr), m_comp(__comp) {}",
			"        void clear() { m_root = nullptr; }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            bool res = false;",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur) {",
			"                    res = true;",
			"                    cur = new node{__key, __args..., s_rand(), 1, nullptr, nullptr};",
			"                } else if (m_comp(__key, cur->key)) {",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    if (_Tag::multi_key || res) {",
			"                        if (subtree_priority(cur->lchild) > cur->priority)",
			"                            return rrotate(cur);",
			"                        else",
			"                            cur->subtree_weight++;",
			"                    }",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(cur->key, __key)) return cur;",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    if (_Tag::multi_key || res) {",
			"                        if (subtree_priority(cur->rchild) > cur->priority)",
			"                            return lrotate(cur);",
			"                        else",
			"                            cur->subtree_weight++;",
			"                    }",
			"                }",
			"                return cur;",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur)",
			"                    return nullptr;",
			"                else if (m_comp(__key, cur->key))",
			"                    cur->lchild = self(self, cur->lchild);",
			"                else if (m_comp(cur->key, __key))",
			"                    cur->rchild = self(self, cur->rchild);",
			"                else {",
			"                    delete cur;",
			"                    if (!cur->lchild)",
			"                        return cur->rchild;",
			"                    else if (!cur->rchild)",
			"                        return cur->lchild;",
			"                    else if (cur->lchild->subtree_weight > cur->rchild->subtree_weight) {",
			"                        node *q = cur->lchild;",
			"                        cur->lchild = q->rchild;",
			"                        q->rchild = self(self, cur);",
			"                        cur = q;",
			"                    } else {",
			"                        node *q = cur->rchild;",
			"                        cur->rchild = q->lchild;",
			"                        q->lchild = self(self, cur);",
			"                        cur = q;",
			"                    }",
			"                }",
			"                return update(cur);",
			"            };",
			"            int oldsize = size();",
			"            m_root = dfs(dfs, m_root);",
			"            return oldsize != size();",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur;)",
			"                if (!m_comp(cur->key, __key))",
			"                    cur = cur->lchild;",
			"                else {",
			"                    ord += subtree_weight(cur->lchild);",
			"                    if (m_comp(cur->key, __key)) {",
			"                        ord++;",
			"                        cur = cur->rchild;",
			"                    } else",
			"                        break;",
			"                }",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (__k >= 0)",
			"                if (int l_count = subtree_weight(cur->lchild); __k < l_count)",
			"                    cur = cur->lchild;",
			"                else if (__k -= subtree_weight(cur->lchild) + 1; __k >= 0)",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key))",
			"                    cur = cur->lchild;",
			"                else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return nullptr;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else if (m_comp(cur->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    return cur;",
			"            }",
			"            return res;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(__key, cur->key)) {",
			"                    res = cur;",
			"                    cur = cur->lchild;",
			"                } else",
			"                    cur = cur->rchild;",
			"            }",
			"            return res;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur;) {",
			"                if (m_comp(cur->key, __key)) {",
			"                    res = cur;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root); }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace TreapContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = Treap<_Tp, bool, _Compare, TreapSetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = Treap<_Tp, bool, _Compare, TreapMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = Treap<_Tp, _Fp, _Compare, TreapMapTag>;",
			"    }",
			"}",
		],
		"description": "treap"
	},
	"union and find":{
        "prefix": "UNION",
        "body": [
			"namespace OY {",
			"    class UnionFind {",
			"        int m_groupCnt;",
			"        std::vector<int> m_parent, m_size;",
			"",
			"    public:",
			"        UnionFind(int n = 1 << 20) {",
			"            resize(n);",
			"        }",
			"        void resize(int n) {",
			"            m_groupCnt = n;",
			"            m_parent.resize(n);",
			"            std::iota(m_parent.begin(), m_parent.end(), 0);",
			"            m_size.resize(n);",
			"            std::fill(m_size.begin(), m_size.end(), 1);",
			"        }",
			"        int find(int i) {",
			"            return m_parent[i] == i ? i : m_parent[i] = find(m_parent[i]);",
			"        }",
			"        int size(int i) {",
			"            return m_size[find(i)];",
			"        }",
			"        void uniteTo(int headA, int headB) {",
			"            if (headA == headB) return;",
			"            m_parent[headA] = headB;",
			"            m_size[headB] += m_size[headA];",
			"            m_groupCnt--;",
			"        }",
			"        bool uniteBySize(int a, int b) {",
			"            if (a = find(a), b = find(b); a == b) return false;",
			"            if (m_size[a] > m_size[b]) std::swap(a, b);",
			"            uniteTo(a, b);",
			"            return true;",
			"        }",
			"        bool uniteByID(int a, int b) {",
			"            if (a = find(a), b = find(b); a == b) return false;",
			"            if (a < b) std::swap(a, b);",
			"            uniteTo(a, b);",
			"            return true;",
			"        }",
			"        bool isSame(int a, int b) {",
			"            return find(a) == find(b);",
			"        }",
			"        bool isHead(int i) {",
			"            return i == m_parent[i];",
			"        }",
			"        std::vector<int> heads() {",
			"            std::vector<int> ret;",
			"            ret.reserve(m_groupCnt);",
			"            for (int i = 0; i < m_parent.size(); i++)",
			"                if (isHead(i)) ret.push_back(i);",
			"            return ret;",
			"        }",
			"        std::vector<std::vector<int>> groups() {",
			"            std::vector<std::vector<int>> ret;",
			"            ret.resize(m_groupCnt);",
			"            std::vector<int> index(m_parent.size());",
			"            for (int i = 0, j = 0; i < m_parent.size(); i++)",
			"                if (isHead(i)) {",
			"                    ret[j].reserve(m_size[i]);",
			"                    index[i] = j++;",
			"                }",
			"            for (int i = 0; i < m_parent.size(); i++)",
			"                ret[index[find(i)]].push_back(i);",
			"            return ret;",
			"        }",
			"    };",
			"}",
        ],
        "description": "union and find"
    },
	"weight balanced leafy tree":{
		"prefix": "WBLT",
		"body": [
			"namespace OY {",
			"    struct WeightBalancedLeafySetTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct WeightBalancedLeafyMultisetTag {",
			"        static constexpr bool multi_key = true;",
			"        static constexpr bool is_map = false;",
			"    };",
			"    struct WeightBalancedLeafyMapTag {",
			"        static constexpr bool multi_key = false;",
			"        static constexpr bool is_map = true;",
			"    };",
			"    template <typename _Tp, typename _Fp, bool is_map>",
			"    struct _WeightBalancedLeafyTreeNode {",
			"        _Tp key;",
			"        mutable _Fp value;",
			"    };",
			"    template <typename _Tp, typename _Fp>",
			"    struct _WeightBalancedLeafyTreeNode<_Tp, _Fp, false> { _Tp key; };",
			"    template <typename _Tp, typename _Fp = bool, typename _Compare = std::less<_Tp>, typename _Tag = WeightBalancedLeafyMultisetTag>",
			"    class WeightBalancedLeafyTree {",
			"        struct node : _WeightBalancedLeafyTreeNode<_Tp, _Fp, _Tag::is_map> {",
			"            int subtree_weight;",
			"            node *lchild;",
			"            node *rchild;",
			"            static void *operator new(size_t count) { return MemoryPool<node>::operator new(count); }",
			"            static void operator delete(void *p) { MemoryPool<node>::recycle((node *)p); }",
			"        };",
			"        node *m_root;",
			"        _Compare m_comp;",
			"        static constexpr int ratio = 4, bias = 2;",
			"        static int subtree_weight(node *p) { return p ? p->subtree_weight : 0; }",
			"        static node *update(node *p) {",
			"            p->subtree_weight = p->lchild->subtree_weight + p->rchild->subtree_weight;",
			"            p->key = p->rchild->key;",
			"            return p;",
			"        }",
			"        static node *lrotate(node *p) {",
			"            node *q = p->rchild;",
			"            p->rchild = q->rchild;",
			"            q->rchild = q->lchild;",
			"            q->lchild = p->lchild;",
			"            p->lchild = update(q);",
			"            return p;",
			"        }",
			"        static node *rrotate(node *p) {",
			"            node *q = p->lchild;",
			"            p->lchild = q->lchild;",
			"            q->lchild = q->rchild;",
			"            q->rchild = p->rchild;",
			"            p->rchild = update(q);",
			"            return p;",
			"        }",
			"        static node *balance(node *cur) {",
			"            if (cur->lchild->subtree_weight > cur->rchild->subtree_weight * ratio + bias) {",
			"                if (cur->lchild->rchild->subtree_weight > cur->lchild->lchild->subtree_weight * (ratio - 1) + bias)",
			"                    cur->lchild = lrotate(cur->lchild);",
			"                return update(rrotate(cur));",
			"            } else if (cur->rchild->subtree_weight > cur->lchild->subtree_weight * ratio + bias) {",
			"                if (cur->rchild->lchild->subtree_weight > cur->rchild->rchild->subtree_weight * (ratio - 1) + bias)",
			"                    cur->rchild = rrotate(cur->rchild);",
			"                return update(lrotate(cur));",
			"            } else",
			"                return update(cur);",
			"        }",
			"",
			"    public:",
			"        static void setBufferSize(int __count) { MemoryPool<node>::_reserve(__count); }",
			"        WeightBalancedLeafyTree(_Tp __maxKey = std::numeric_limits<_Tp>::max(), _Compare __comp = _Compare()) : m_comp(__comp) {",
			"            m_root = new node;",
			"            m_root->key = __maxKey;",
			"            m_root->subtree_weight = 1;",
			"            m_root->lchild = nullptr;",
			"            m_root->rchild = nullptr;",
			"        }",
			"        ~WeightBalancedLeafyTree() { clear(); }",
			"        void clear() {",
			"            m_root->subtree_weight = 1;",
			"            m_root->lchild = nullptr;",
			"            m_root->rchild = nullptr;",
			"        }",
			"        template <typename... Args>",
			"        void insert(_Tp __key, Args... __args) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if(!cur->lchild){",
			"                    cur->lchild = new node{__key, __args..., 1, nullptr, nullptr};",
			"                    cur->rchild = new node(*cur);",
			"                    cur->rchild->lchild = nullptr;",
			"                    cur->rchild->rchild = nullptr;",
			"                    cur->subtree_weight=2;",
			"                    return cur;",
			"                }",
			"                else if (m_comp(cur->lchild->key, __key)) {",
			"                    cur->rchild = self(self, cur->rchild);",
			"                    return balance(cur);",
			"                } else {",
			"                    if constexpr (!_Tag::multi_key)",
			"                        if (!m_comp(__key, cur->lchild->key)) return cur;",
			"                    cur->lchild = self(self, cur->lchild);",
			"                    return balance(cur);",
			"                };",
			"            };",
			"            m_root = dfs(dfs, m_root);",
			"        }",
			"        void update(_Tp __key, _Fp __value) {",
			"            static_assert(_Tag::is_map);",
			"            if (auto p = find(__key))",
			"                p->value = __value;",
			"            else",
			"                insert(__key, __value);",
			"        }",
			"        bool erase(_Tp __key) {",
			"            auto dfs = [&](auto self, node *cur) -> node * {",
			"                if (!cur->lchild) {",
			"                    if (m_comp(__key, cur->key)) return cur;",
			"                    delete cur;",
			"                    return nullptr;",
			"                } else if (m_comp(cur->lchild->key, __key)) {",
			"                    if (cur->rchild = self(self, cur->rchild)) return balance(cur);",
			"                    delete cur;",
			"                    return cur->lchild;",
			"                } else if (cur->lchild = self(self, cur->lchild))",
			"                    return balance(cur);",
			"                delete cur;",
			"                return cur->rchild;",
			"            };",
			"            int old_weight = size();",
			"            m_root = dfs(dfs, m_root);",
			"            return old_weight != size();",
			"        }",
			"        void erase(_Tp __key, int __count) {",
			"            static_assert(_Tag::multi_key);",
			"            while (__count-- && erase(__key))",
			"                ;",
			"        }",
			"        int rank(_Tp __key) const {",
			"            int ord = 0;",
			"            for (node *cur = m_root; cur->lchild;)",
			"                if (m_comp(cur->lchild->key, __key)) {",
			"                    ord += cur->lchild->subtree_weight;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            return ord;",
			"        }",
			"        const node *kth(int __k) const {",
			"            node *cur = m_root;",
			"            while (cur->lchild)",
			"                if (int l_count = cur->lchild->subtree_weight; __k < l_count)",
			"                    cur = cur->lchild;",
			"                else {",
			"                    __k -= l_count;",
			"                    cur = cur->rchild;",
			"                }",
			"            return cur;",
			"        }",
			"        const node *find(_Tp __key) const {",
			"            node *cur = m_root;",
			"            while (cur->lchild)",
			"                if (m_comp(cur->lchild->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    cur = cur->lchild;",
			"            return m_comp(__key, cur->key) ? nullptr : cur;",
			"        }",
			"        const node *lower_bound(_Tp __key) const {",
			"            node *cur = m_root;",
			"            while (cur->lchild)",
			"                if (m_comp(cur->lchild->key, __key))",
			"                    cur = cur->rchild;",
			"                else",
			"                    cur = cur->lchild;",
			"            return cur;",
			"        }",
			"        const node *upper_bound(_Tp __key) const {",
			"            node *cur = m_root;",
			"            while (cur->lchild)",
			"                if (m_comp(__key, cur->lchild->key))",
			"                    cur = cur->lchild;",
			"                else",
			"                    cur = cur->rchild;",
			"            return cur;",
			"        }",
			"        const node *smaller_bound(_Tp __key) const {",
			"            node *res = nullptr;",
			"            for (node *cur = m_root; cur->lchild;) {",
			"                if (m_comp(cur->lchild->key, __key)) {",
			"                    res = cur->lchild;",
			"                    cur = cur->rchild;",
			"                } else",
			"                    cur = cur->lchild;",
			"            }",
			"            if (res)",
			"                while (res->rchild) res = res->rchild;",
			"            return res;",
			"        }",
			"        int size() const { return subtree_weight(m_root) - 1; }",
			"        bool empty() const { return !size(); }",
			"        int count(_Tp __key) const {",
			"            auto it1 = lower_bound(__key);",
			"            if (!it1) return 0;",
			"            auto it2 = upper_bound(__key);",
			"            if (!it2)",
			"                return size() - rank(__key);",
			"            else",
			"                return rank(it2->key) - rank(__key);",
			"        }",
			"    };",
			"    namespace WeightBalancedLeafyTreeContainer {",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Set = WeightBalancedLeafyTree<_Tp, bool, _Compare, WeightBalancedLeafySetTag>;",
			"        template <typename _Tp, typename _Compare = std::less<_Tp>>",
			"        using Multiset = WeightBalancedLeafyTree<_Tp, bool, _Compare, WeightBalancedLeafyMultisetTag>;",
			"        template <typename _Tp, typename _Fp, typename _Compare = std::less<_Tp>>",
			"        using Map = WeightBalancedLeafyTree<_Tp, _Fp, _Compare, WeightBalancedLeafyMapTag>;",
			"    }",
			"}",
		],
		"description": "weight balanced leafy tree"
	},
	"zkw tree":{
		"prefix": "ZKW",
		"body": [
			"namespace OY {",
			"    template <typename _Tp = int64_t, typename _Operation = std::plus<_Tp>>",
			"    class ZkwTree {",
			"        std::vector<_Tp> m_sub;",
			"        int m_length;",
			"        int m_depth;",
			"        _Operation m_op;",
			"        _Tp m_defaultValue;",
			"        void _check() {",
			"            //assert(m_op(m_defaultValue, m_defaultValue) == m_defaultValue);",
			"        }",
			"        void _update(int cur) {",
			"            m_sub[cur] = m_op(m_sub[cur * 2], m_sub[cur * 2 + 1]);",
			"        }",
			"",
			"    public:",
			"        ZkwTree(int __n = 0, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            resize(__n);",
			"        }",
			"        template <typename _Iterator>",
			"        ZkwTree(_Iterator __first, _Iterator __last, _Operation __op = _Operation(), _Tp __defaultValue = _Tp()) : m_op(__op), m_defaultValue(__defaultValue) {",
			"            _check();",
			"            reset(__first, __last);",
			"        }",
			"        void resize(int __n) {",
			"            if (!__n) return;",
			"            m_length = __n;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.assign(1 << (m_depth + 1), m_defaultValue);",
			"        }",
			"        template <typename _Iterator>",
			"        void reset(_Iterator __first, _Iterator __last) {",
			"            m_length = __last - __first;",
			"            m_depth = 32 - (m_length > 1 ? std::__countl_zero(m_length - 1) : 32);",
			"            m_sub.resize(1 << (m_depth + 1));",
			"            std::copy(__first, __last, m_sub.begin() + (1 << m_depth));",
			"            std::fill(m_sub.begin() + (1 << m_depth) + m_length, m_sub.end(), m_defaultValue);",
			"            for (int i = 1 << m_depth; --i;) _update(i);",
			"        }",
			"        void update(int __i, _Tp __val) {",
			"            __i += 1 << m_depth;",
			"            m_sub[__i] = __val;",
			"            while (__i >>= 1) _update(__i);",
			"        }",
			"        void add(int __i, _Tp __inc) {",
			"            __i += 1 << m_depth;",
			"            m_sub[__i] = m_op(m_sub[__i], __inc);",
			"            while (__i >>= 1) _update(__i);",
			"        }",
			"        _Tp query(int __i) const {",
			"            return m_sub[(1 << m_depth) + __i];",
			"        }",
			"        _Tp query(int __left, int __right) const {",
			"            if (__left == __right) return m_sub[(1 << m_depth) + __left];",
			"            __left += 1 << m_depth;",
			"            __right += 1 << m_depth;",
			"            _Tp res = m_sub[__left];",
			"            int j = 31 - std::__countl_zero(__left ^ __right);",
			"            for (int i = 0; i < j; i++)",
			"                if (!(__left >> i & 1)) res = m_op(res, m_sub[__left >> i ^ 1]);",
			"            for (int i = j - 1; i >= 0; i--)",
			"                if (__right >> i & 1) res = m_op(res, m_sub[__right >> i ^ 1]);",
			"            return m_op(res, m_sub[__right]);",
			"        }",
			"        _Tp queryAll() const {",
			"            return m_sub[1];",
			"        }",
			"        int kth(_Tp __k) const {",
			"            int i = 1;",
			"            while (i < 1 << m_depth)",
			"                if (m_sub[i *= 2] <= __k) __k -= m_sub[i++];",
			"            return i - (1 << m_depth);",
			"        }",
			"    };",
			"    template <typename _Tp = int64_t>",
			"    ZkwTree(int, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Tp = int64_t>",
			"    ZkwTree(int, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Operation = std::plus<int64_t>, typename _Tp = std::decay_t<typename decltype(std::mem_fn(&_Operation::operator()))::result_type>>",
			"    ZkwTree(int = 0, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, _Operation>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    ZkwTree(_Iterator, _Iterator, const _Tp &(*)(const _Tp &, const _Tp &), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, const _Tp &(*)(const _Tp &, const _Tp &)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    ZkwTree(_Iterator, _Iterator, _Tp (*)(_Tp, _Tp), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, _Tp (*)(_Tp, _Tp)>;",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type, typename _Operation = std::plus<_Tp>>",
			"    ZkwTree(_Iterator, _Iterator, _Operation = _Operation(), _Tp = _Tp(), _Tp = _Tp()) -> ZkwTree<_Tp, _Operation>;",
			"}",
		],
		"description": "zkw tree"
	},
	
	"barrett reduce":{
		"prefix": "BRT",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct Barrett {",
			"        _ModType m_P;",
			"        __uint128_t m_Pinv;",
			"        constexpr Barrett() = default;",
			"        constexpr explicit Barrett(_ModType __P) : m_P(__P), m_Pinv(-uint64_t(__P) / __P + 1) {}",
			"        constexpr _ModType mod() const { return m_P; }",
			"        constexpr _ModType mod(uint64_t __a) const {",
			"            __a -= uint64_t(m_Pinv * __a >> 64) * m_P + m_P;",
			"            if (__a >= m_P) __a += m_P;",
			"            return __a;",
			"        }",
			"        constexpr _ModType multiply(uint64_t __a, uint64_t __b) const {",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return multiply_ld(__a, __b);",
			"            else",
			"                return multiply_64(__a, __b);",
			"        }",
			"        constexpr _ModType multiply_64(uint64_t __a, uint64_t __b) const {",
			"            // assert(__a * __b < 1ull << 64);",
			"            return mod(__a * __b);",
			"        }",
			"        constexpr _ModType multiply_128(uint64_t __a, uint64_t __b) const {",
			"            if (std::__countl_zero(__a) + std::__countl_zero(__b) >= 64) return multiply_64(__a, __b);",
			"            return __uint128_t(__a) * __b % m_P;",
			"        }",
			"        constexpr _ModType multiply_ld(uint64_t __a, uint64_t __b) const {",
			"            // assert(m_P < 1ull << 63 && __a < m_P && __b < m_P);",
			"            if (std::__countl_zero(__a) + std::__countl_zero(__b) >= 64) return multiply_64(__a, __b);",
			"            int64_t res = __a * __b - uint64_t(1.L / m_P * __a * __b) * m_P;",
			"            if (res < 0)",
			"                res += m_P;",
			"            else if (res >= m_P)",
			"                res -= m_P;",
			"            return res;",
			"        }",
			"        constexpr _ModType pow(uint64_t __a, uint64_t __n) const {",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return pow_ld(__a, __n);",
			"            else",
			"                return pow_64(__a, __n);",
			"        }",
			"        constexpr _ModType pow_64(uint64_t __a, uint64_t __n) const {",
			"            // assert(m_P < 1ull << 32);",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_64(res, b);",
			"                b = multiply_64(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        constexpr _ModType pow_128(uint64_t __a, uint64_t __n) const {",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_128(res, b);",
			"                b = multiply_128(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        constexpr _ModType pow_ld(uint64_t __a, uint64_t __n) const {",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_ld(res, b);",
			"                b = multiply_ld(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Tp>",
			"        constexpr _Tp divide(_Tp __a) const {",
			"            if (__a < m_P) return 0;",
			"            _Tp res = m_Pinv * __a >> 64;",
			"            if (__a - res * m_P >= m_P) res++;",
			"            return res;",
			"        }",
			"        template <typename _Tp>",
			"        constexpr std::pair<_Tp, _Tp> divmod(_Tp __a) const {",
			"            _Tp quo = (__a * m_Pinv) >> 64, rem = __a - quo * m_P;",
			"            if (rem >= m_P) {",
			"                quo++;",
			"                rem -= m_P;",
			"            }",
			"            return {quo, rem};",
			"        }",
			"    };",
			"    using Barrett32 = Barrett<uint32_t>;",
			"    using Barrett64 = Barrett<uint64_t>;",
			"}",
		],
		"description": "barrett reduce"
	},
	"bitwise":{
		"prefix": "BITWISE",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, typename _Increment>",
			"    struct _BitLoop {",
			"        _Tp m_start;",
			"        _Tp m_end;",
			"        mutable _Increment m_inc;",
			"        constexpr _BitLoop(_Tp __start, _Tp __end, _Increment __inc) : m_start(__start), m_end(__end), m_inc(__inc) {}",
			"        struct _BitIterator {",
			"            mutable _Tp value;",
			"            const _BitLoop<_Tp, _Increment> &loop;",
			"            constexpr _BitIterator(_Tp start, const _BitLoop<_Tp, _Increment> &loop) : value(start), loop(loop) {}",
			"            constexpr _BitIterator &operator++() {",
			"                loop.m_inc(value);",
			"                return *this;",
			"            }",
			"            constexpr _Tp operator*() { return value; }",
			"            constexpr bool operator!=(const _BitIterator &other) const { return value != other.value; }",
			"        };",
			"        constexpr _BitIterator begin() const { return _BitIterator(m_start, *this); }",
			"        constexpr _BitIterator end() const { return _BitIterator(m_end, *this); }",
			"    };",
			"    template <typename _Tp, typename _Increment>",
			"    _BitLoop(_Tp, _Tp, _Increment) -> _BitLoop<_Tp, _Increment>;",
			"    template <typename _Tp>",
			"    struct BitwiseHelper {",
			"        static constexpr uint8_t length() { return sizeof(_Tp) * 8; }",
			"        static constexpr uint8_t countOne(_Tp mask) { return std::__popcount(mask); }",
			"        static constexpr bool isOne(_Tp mask, uint8_t i) { return i < length() ? mask >> i & _Tp(1) : false; }",
			"        static constexpr bool isZero(_Tp mask, uint8_t i) { return !isOne(mask, i); }",
			"        static constexpr bool intersect(_Tp mask1, _Tp mask2) { return mask1 & mask2; }",
			"        static constexpr bool contains(_Tp mask1, _Tp mask2) { return (mask1 & mask2) == mask2; }",
			"        static constexpr bool isContained(_Tp mask1, _Tp mask2) { return (mask1 & mask2) == mask1; }",
			"        static constexpr uint8_t countFrontZeros(_Tp mask) { return std::__countl_zero(mask); }",
			"        static constexpr uint8_t countFrontOnes(_Tp mask) { return countFrontZeros(~mask); }",
			"        static constexpr uint8_t countBackZeros(_Tp mask) { return std::__countr_zero(mask); }",
			"        static constexpr uint8_t countBackOnes(_Tp mask) { return countBackZeros(~mask); }",
			"        static constexpr _Tp makeMask() { return -1; }",
			"        static constexpr _Tp makeMask(uint8_t i) { return i < length() ? _Tp(1) << i : _Tp(0); }",
			"        static constexpr _Tp makeMask(uint8_t l, uint8_t r) { return makeBackOnes(r + 1) ^ makeBackOnes(l); }",
			"        static constexpr _Tp makeBackOnes(uint8_t k) { return k >= length() ? _Tp(-1) : (_Tp(1) << k) - 1; }",
			"        static constexpr _Tp getMask(_Tp mask, uint8_t i) { return mask & makeMask(i); }",
			"        static constexpr _Tp getMask(_Tp mask, uint8_t l, uint8_t r) { return mask & makeMask(l, r); }",
			"        static constexpr _Tp getLowestOne(_Tp mask) { return makeMask(countBackZeros(mask)); }",
			"        static constexpr _Tp getCeil(_Tp mask) { return mask ? makeMask(length() - countFrontZeros(mask - 1)) : _Tp(0); }",
			"        static constexpr _Tp getFloor(_Tp mask) { return makeMask(length() - 1 - countFrontZeros(mask)); }",
			"        static constexpr _Tp getBackOnes(_Tp mask) { return makeBackOnes(countBackOnes(mask)); }",
			"        static constexpr void setMask(_Tp &mask) { mask = makeMask(); }",
			"        static constexpr void setMask(_Tp &mask, uint8_t i) { mask |= makeMask(i); }",
			"        static constexpr void setMask(_Tp &mask, uint8_t l, uint8_t r) { mask |= makeMask(l, r); }",
			"        static constexpr void resetMask(_Tp &mask) { mask = 0; }",
			"        static constexpr void resetMask(_Tp &mask, uint8_t i) { mask &= ~makeMask(i); }",
			"        static constexpr void resetMask(_Tp &mask, uint8_t l, uint8_t r) { mask &= ~makeMask(l, r); }",
			"        static constexpr void flipMask(_Tp &mask) { mask = ~mask; }",
			"        static constexpr void flipMask(_Tp &mask, uint8_t i) { mask ^= makeMask(i); }",
			"        static constexpr void flipMask(_Tp &mask, uint8_t l, uint8_t r) { mask ^= makeMask(l, r); }",
			"        static constexpr void fillBackZerosWithOnes(_Tp &mask) { mask |= getBackOnes(~mask); }",
			"        static constexpr void fillBackOnesWithZeros(_Tp &mask) { mask ^= getBackOnes(mask); }",
			"        static constexpr auto enumOne(_Tp mask) {",
			"            return _BitLoop(countBackZeros(mask), countBackZeros(0), [=](uint8_t &k) mutable {",
			"                resetMask(mask, k);",
			"                k = countBackZeros(mask);",
			"            });",
			"        }",
			"        static constexpr auto enumOne_reversed(_Tp mask) {",
			"            return _BitLoop(uint8_t(length() - 1 - countFrontZeros(mask)), uint8_t(-1), [=](uint8_t &k) mutable {",
			"                resetMask(mask, k);",
			"                k = length() - 1 - countFrontZeros(mask);",
			"            });",
			"        }",
			"        static constexpr auto enumChoose(uint8_t n) {",
			"            assert(n < length());",
			"            return _BitLoop(_Tp(0), makeMask(n), [](_Tp &mask) { mask++; });",
			"        }",
			"        static constexpr auto enumChoose_reversed(uint8_t n) {",
			"            assert(n < length());",
			"            return _BitLoop(makeBackOnes(n), _Tp(-1), [](_Tp &mask) { mask--; });",
			"        }",
			"        static constexpr auto enumChoose(uint8_t n, uint8_t k) {",
			"            assert(n < length() && k <= n);",
			"            return _BitLoop(makeBackOnes(k), makeMask(n) | makeBackOnes(k - 1), [k](_Tp &mask) {",
			"                int a = countBackZeros(mask);",
			"                fillBackZerosWithOnes(mask);",
			"                mask += makeBackOnes(countBackOnes(mask) - a - 1) + 1;",
			"            });",
			"        }",
			"        static constexpr auto enumChoose_reversed(uint8_t n, uint8_t k) {",
			"            assert(n < length() && k <= n);",
			"            return _BitLoop(makeMask(n - k, n - 1), _Tp(-1), [k](_Tp &mask) {",
			"                if (uint8_t a = countBackOnes(mask); a < k) {",
			"                    fillBackOnesWithZeros(mask);",
			"                    int b = countBackZeros(mask);",
			"                    flipMask(mask, b - a - 1, b);",
			"                } else",
			"                    mask = _Tp(-1);",
			"            });",
			"        }",
			"        static constexpr auto enumSubOf(_Tp mask) {",
			"            assert(mask != _Tp(-1));",
			"            return _BitLoop(_Tp(0), _Tp(-1), [mask](_Tp &cur) {",
			"                if (cur ^ mask)",
			"                    cur ^= (_Tp(1) << countBackZeros(cur ^ mask) + 1) - 1 & mask;",
			"                else",
			"                    cur = -1;",
			"            });",
			"        }",
			"        static constexpr auto enumSubOf_reversed(_Tp mask) {",
			"            assert(mask != _Tp(-1));",
			"            return _BitLoop(mask, _Tp(-1), [mask](_Tp &cur) { cur = cur ? (cur - 1) & mask : _Tp(-1); });",
			"        }",
			"        static constexpr auto enumSubOf(_Tp mask, uint8_t k) {",
			"            assert(mask != _Tp(-1) && k <= countOne(mask));",
			"            _Tp res[length() + 1]{0};",
			"            for (int i = 0, j = 0; i < length(); i++)",
			"                if (mask & makeMask(i)) res[++j] = mask & makeBackOnes(i + 1);",
			"            return _BitLoop(res[k], _Tp(-1), [=](_Tp &cur) {",
			"                if (_Tp back = makeBackOnes(countBackZeros(cur)) & mask; back < (mask ^ cur)) {",
			"                    uint8_t a = countBackZeros(mask - cur - back);",
			"                    _Tp mid = makeBackOnes(a) & cur;",
			"                    cur += makeMask(a) + res[countOne(mid) - 1] - mid;",
			"                } else",
			"                    cur = -1;",
			"            });",
			"        }",
			"        static constexpr auto enumSubOf_reversed(_Tp mask, uint8_t k) {",
			"            assert(mask != _Tp(-1) && k <= countOne(mask));",
			"            _Tp res[length() + 1]{0};",
			"            for (int i = 0, j = 0; i < length(); i++)",
			"                if (mask & makeMask(i)) res[++j] = mask & makeBackOnes(i + 1);",
			"            return _BitLoop(mask - res[countOne(mask) - k], _Tp(-1), [=](_Tp &cur) {",
			"                if (_Tp back = makeBackOnes(countBackZeros(mask ^ cur)) & mask; back < cur) {",
			"                    cur ^= back ^ (makeBackOnes(countBackZeros(cur ^ back) + 1) & mask);",
			"                    cur ^= res[countOne(cur) - k];",
			"                } else",
			"                    cur = -1;",
			"            });",
			"        }",
			"        template <uint8_t k = length()>",
			"        static std::string to_string(_Tp mask) {",
			"            const uint8_t ki = k > 0 ? k : length();",
			"            std::string res;",
			"            res.reserve(ki);",
			"            for (auto i = ki - 1; i >= 0; i--) res.push_back(isOne(mask, i) ? '1' : '0');",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "bitwise helper"
	},
	"BSGS":{
		"prefix": "BSGS",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, uint32_t _HashP, uint32_t _HashN>",
			"    _ModType BSGS(_ModType __a, _ModType __r, _ModType __P, _ModType __coef) {",
			"        if (__P == 1) return 0;",
			"        Barrett<_ModType> brt(__P);",
			"        __a = brt.mod(__a);",
			"        __r = brt.mod(__r);",
			"        __coef = brt.mod(__coef);",
			"        if (__r == __coef) return 0;",
			"        if (!__coef) return -1;",
			"        if (!__a) return __r ? -1 : 1;",
			"#pragma pack(4)",
			"        static struct node {",
			"            _ModType key;",
			"            uint32_t value;",
			"            uint32_t next;",
			"        } hash_item[_HashN];",
			"#pragma pack()",
			"        static uint32_t hash_first[_HashP]{}, *hash_used[_HashP], hash_used_cnt{};",
			"        while (hash_used_cnt) *hash_used[--hash_used_cnt] = 0;",
			"        uint32_t hash_cnt = 0, sqrt = std::ceil(std::sqrt(__P));",
			"        for (uint32_t i = 0; i < sqrt; i++) {",
			"            uint32_t r = Modular32<_HashP>::mod(__r);",
			"            hash_used[hash_used_cnt++] = hash_first + r;",
			"            hash_item[++hash_cnt] = node{__r, i, hash_first[r]};",
			"            hash_first[r] = hash_cnt;",
			"            __r = brt.multiply_64(__r, __a);",
			"        }",
			"        __a = brt.pow_64(__a, sqrt);",
			"        __r = __coef;",
			"        for (uint32_t i = 1; i <= sqrt; i++) {",
			"            __r = brt.multiply_64(__r, __a);",
			"            uint32_t x = hash_first[Modular32<_HashP>::mod(__r)];",
			"            while (x && hash_item[x].key != __r) x = hash_item[x].next;",
			"            if (x) return i * sqrt - hash_item[x].value;",
			"        }",
			"        return -1;",
			"    }",
			"    template <typename _ModType, uint32_t _HashP, uint32_t _HashN>",
			"    constexpr _ModType BSGS_ex(_ModType __a, _ModType __r, _ModType __P) {",
			"        if (__P == 1) return 0;",
			"        Barrett<_ModType> brt(__P);",
			"        __a = brt.mod(__a);",
			"        __r = brt.mod(__r);",
			"        if (__r == 1) return 0;",
			"        if (!__a) return __r ? -1 : 1;",
			"        _ModType a = 1, r = __r, P = __P;",
			"        uint32_t k = 0;",
			"        while (true) {",
			"            _ModType g = gcd<_ModType>(__a, P);",
			"            if (g == 1) break;",
			"            _ModType q = r / g;",
			"            if (r > q * g) return -1;",
			"            k++;",
			"            r = q;",
			"            P /= g;",
			"            if (a = brt.multiply(a, __a / g) % P; a == r) return k;",
			"        }",
			"        _ModType res = BSGS<_ModType, _HashP, _HashN>(__a % P, r, P, a);",
			"        return ~res ? res + k : res;",
			"    }",
			"    template <uint32_t _HashP, uint32_t _HashN>",
			"    constexpr auto BSGS32 = BSGS<uint32_t, _HashP, _HashN>;",
			"    template <uint32_t _HashP, uint32_t _HashN>",
			"    constexpr auto BSGS64 = BSGS<uint64_t, _HashP, _HashN>;",
			"    template <uint32_t _HashP, uint32_t _HashN>",
			"    constexpr auto BSGS_ex32 = BSGS_ex<uint32_t, _HashP, _HashN>;",
			"    template <uint32_t _HashP, uint32_t _HashN>",
			"    constexpr auto BSGS_ex64 = BSGS_ex<uint64_t, _HashP, _HashN>;",
			"}",
		],
		"description": "BSGS"
	},
	"Cantor sequence":{
		"prefix": "CANTOR",
		"body": [
			"namespace OY {",
			"    std::vector<uint32_t> CantorSequence(uint32_t n, uint64_t k) {",
			"        uint64_t permutation = 1;",
			"        std::vector<uint32_t> res(n);",
			"        for (uint32_t index = n - 1; ~index; index--) {",
			"            res[index] = k / permutation % (n - index);",
			"            permutation *= n - index;",
			"        }",
			"        if (k >= permutation) return {};",
			"        bool counter[n];",
			"        std::fill(counter, counter + n, true);",
			"        for (uint32_t &id : res)",
			"            for (uint32_t i = 0, j = 0; i < n; i++)",
			"                if (counter[i] && !id--) {",
			"                    counter[id = i] = false;",
			"                    break;",
			"                }",
			"        return res;",
			"    }",
			"    template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"    std::vector<_Tp> CantorSequence_ex(_Iterator first, _Iterator last, uint64_t k) {",
			"        const uint32_t n = last - first;",
			"        _Tp sorted[n];",
			"        std::copy(first, last, sorted);",
			"        std::sort(sorted, sorted + n);",
			"        const uint32_t unique_n = std::unique(sorted, sorted + n) - sorted;",
			"        uint32_t counter[unique_n];",
			"        std::fill(counter, counter + unique_n, 0);",
			"        for (auto it = first; it != last; ++it) counter[std::lower_bound(sorted, sorted + unique_n, *it) - sorted]++;",
			"        uint64_t permutation = 1, number = 0;",
			"        for (uint32_t c : counter)",
			"            for (uint32_t j = 1; j <= c; j++) permutation = permutation * ++number / j;",
			"        if (permutation <= k) return {};",
			"        std::vector<_Tp> res(n);",
			"        for (uint32_t i = 0; i < n; i++) {",
			"            uint64_t cur = 0, presum = 0;",
			"            while (true) {",
			"                uint64_t s = permutation * counter[cur] / (n - i);",
			"                if (presum + s > k) {",
			"                    permutation = s;",
			"                    break;",
			"                }",
			"                presum += s;",
			"                cur++;",
			"            }",
			"            k -= presum;",
			"            counter[cur]--;",
			"            res[i] = sorted[cur];",
			"        }",
			"        return res;",
			"    }",
			"}",
		],
		"description": "Cantor sequence"
	},
	"Cipolla":{
		"prefix": "CIPOLLA",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    constexpr bool isQuadraticResidue(_ModType a, _ModType P) {",
			"        // assert(isPrime(P));",
			"        return Barrett<_ModType>(P).pow(a, (P - 1) >> 1) == 1;",
			"    }",
			"    template <typename _ModType>",
			"    constexpr _ModType Cipolla(_ModType a, _ModType P) {",
			"        if (P == 2) return a & 1 ? 1 : 0;",
			"        if constexpr(std::is_same_v<_ModType,uint32_t>){",
			"            Barrett<_ModType> brt(P);",
			"            a = brt.mod(a);",
			"            if (brt.pow(a, (P - 1) / 2) != 1) return 0;",
			"            _ModType b = 1;",
			"            while (brt.pow(b * b + P - a, (P - 1) / 2) == 1) b++;",
			"            _ModType neg = b * b + P - a;",
			"            if (neg >= P) neg -= P;",
			"            struct node {",
			"                _ModType a, b;",
			"            };",
			"            auto mul = [&](node &x, const node &y) {",
			"                _ModType _a = brt.multiply(x.a, y.a) + brt.multiply(brt.multiply(x.b, y.b), neg);",
			"                if (_a >= P) _a -= P;",
			"                _ModType _b = brt.multiply(x.b, y.a) + brt.multiply(x.a, y.b);",
			"                if (_b >= P) _b -= P;",
			"                x.a = _a;",
			"                x.b = _b;",
			"            };",
			"            auto pow = [&](node x, uint32_t _n) {",
			"                node res{1, 0};",
			"                while (_n) {",
			"                    if (_n & 1) mul(res, x);",
			"                    mul(x, x);",
			"                    _n >>= 1;",
			"                }",
			"                return res;",
			"            };",
			"            _ModType ans = pow({b, 1}, (P + 1) >> 1).a;",
			"            return ans > P >> 1 ? P - ans : ans;",
			"        }",
			"        else{",
			"            Montgomery<_ModType> mg(P);",
			"            a = mg.init(a);",
			"            _ModType one = mg.raw_init(1);",
			"            if (mg.pow(a, (P - 1) / 2) != one) return 0;",
			"            _ModType b = one;",
			"            while (true) {",
			"                _ModType c = mg.multiply(b, b) + P - a;",
			"                if (c >= P) c -= P;",
			"                if (mg.pow(c, (P - 1) / 2) != one) break;",
			"                if(b += one;b>=P)b-=P;",
			"            }",
			"            _ModType neg = mg.multiply(b, b) + P - a;",
			"            if (neg >= P) neg -= P;",
			"            struct node {",
			"                _ModType a, b;",
			"            };",
			"            auto mul = [&](node &x, const node &y) {",
			"                _ModType _a = mg.multiply(x.a, y.a) + mg.multiply(mg.multiply(x.b, y.b), neg);",
			"                if (_a >= P) _a -= P;",
			"                _ModType _b = mg.multiply(x.b, y.a) + mg.multiply(x.a, y.b);",
			"                if (_b >= P) _b -= P;",
			"                x.a = _a;",
			"                x.b = _b;",
			"            };",
			"            auto pow = [&](node x, uint32_t _n) {",
			"                node res{one, 0};",
			"                while (_n) {",
			"                    if (_n & 1) mul(res, x);",
			"                    mul(x, x);",
			"                    _n >>= 1;",
			"                }",
			"                return res;",
			"            };",
			"            _ModType ans = mg.reduce(pow({b, one}, (P + 1) >> 1).a);",
			"            return ans > P >> 1 ? P - ans : ans;",
			"        }",
			"    }",
			"    constexpr auto Cipolla32 = Cipolla<uint32_t>;",
			"    constexpr auto Cipolla64 = Cipolla<uint64_t>;",
			"}",
		],
		"description": "Cipolla"
	},
	"dynamic Cantor rank":{
		"prefix": "CANTOR",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct DynamicCantorRank {",
			"        Barrett<_ModType> m_brt;",
			"        DynamicCantorRank(_ModType __P) : m_brt(__P) {}",
			"        template <typename _Iterator>",
			"        _ModType rawQuery(_Iterator __first, _Iterator __last) const {",
			"            const uint32_t n = __last - __first;",
			"            BIT<uint32_t> counter(*std::max_element(__first, __last) + 1);",
			"            _ModType permutation = 1, res = 0;",
			"            for (uint32_t index = n - 1; ~index; index--) {",
			"                if (__first[index])",
			"                    if (res += m_brt.multiply(permutation, counter.presum(__first[index] - 1)); res >= m_brt.mod()) res -= m_brt.mod();",
			"                permutation = m_brt.multiply(permutation, n - index);",
			"                counter.add(__first[index], 1);",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"        _ModType query(_Iterator __first, _Iterator __last) const {",
			"            const uint32_t n = __last - __first;",
			"            _Tp sorted[n];",
			"            uint32_t id[n];",
			"            std::copy(__first, __last, sorted);",
			"            std::sort(sorted, sorted + n);",
			"            for (uint32_t i = 0; i < n; i++) id[i] = std::lower_bound(sorted, sorted + n, __first[i]) - sorted;",
			"            return rawQuery(id, id + n);",
			"        }",
			"    };",
			"    template <typename _ModType>",
			"    struct DynamicCantorRank_ex {",
			"        DynamicModularInverseTable<_ModType> m_invTable;",
			"        Barrett<_ModType> m_brt;",
			"        DynamicCantorRank_ex(_ModType __P, uint32_t __maxNumber) : m_invTable(__P, __maxNumber), m_brt(__P) {}",
			"        template <typename _Iterator>",
			"        _ModType rawQuery(_Iterator __first, _Iterator __last) const {",
			"            const uint32_t n = __last - __first;",
			"            BIT<uint32_t> counter(*std::max_element(__first, __last) + 1);",
			"            _ModType permutation = 1, res = 0;",
			"            for (uint32_t index = n - 1; ~index; index--) {",
			"                uint32_t s1 = counter.presum(__first[index]), s2 = __first[index] ? counter.presum(__first[index] - 1) : 0;",
			"                permutation = m_brt.multiply(permutation, m_invTable.query(s1 - s2 + 1));",
			"                if (__first[index])",
			"                    if (res += m_brt.multiply(permutation, s2); res >= m_brt.mod()) res -= m_brt.mod();",
			"                permutation = m_brt.multiply(permutation, n - index);",
			"                counter.add(__first[index], 1);",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"        _ModType query(_Iterator __first, _Iterator __last) const {",
			"            const uint32_t n = __last - __first;",
			"            _Tp sorted[n];",
			"            uint32_t id[n];",
			"            std::copy(__first, __last, sorted);",
			"            std::sort(sorted, sorted + n);",
			"            const uint32_t unique_n = std::unique(sorted, sorted + n) - sorted;",
			"            for (uint32_t i = 0; i < n; i++) id[i] = std::lower_bound(sorted, sorted + unique_n, __first[i]) - sorted;",
			"            return rawQuery(id, id + n);",
			"        }",
			"    };",
			"    using DynamicCantorRank32 = DynamicCantorRank<uint32_t>;",
			"    using DynamicCantorRank64 = DynamicCantorRank<uint64_t>;",
			"    using DynamicCantorRank_ex32 = DynamicCantorRank_ex<uint32_t>;",
			"    using DynamicCantorRank_ex64 = DynamicCantorRank_ex<uint64_t>;",
			"}",
		],
		"description": "dynamic Cantor rank"
	},
	"dynamic Catalan table":{
		"prefix": "CATALAN",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct DynamicCatalanTable {",
			"        std::vector<_ModType> m_val;",
			"        DynamicModularInverseTable<_ModType> m_invTable;",
			"        Barrett<_ModType> m_brt;",
			"        DynamicCatalanTable(_ModType __P, uint32_t __n) : m_invTable(__P, __n + 1), m_brt(__P) {",
			"            m_val.reserve(__n + 1);",
			"            m_val.push_back(1);",
			"            for (uint32_t i = 1; i <= __n; i++) {",
			"                m_val.push_back(m_brt.multiply(m_brt.multiply(m_val.back(), i * 4 - 2), m_invTable.query(i + 1)));",
			"            }",
			"        }",
			"        _ModType query(uint32_t __i) const { return m_val[__i]; }",
			"    };",
			"    using DynamicCatalanTable32 = DynamicCatalanTable<uint32_t>;",
			"    using DynamicCatalanTable64 = DynamicCatalanTable<uint64_t>;",
			"}",
		],
		"description": "dynamic Catalan table"
	},
	"dynamic combination table":{
		"prefix": "COMB",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct DynamicCombinationTable {",
			"        Barrett<_ModType> m_brt;",
			"        std::vector<_ModType> m_factorial;",
			"        std::vector<_ModType> m_factorialInv;",
			"        DynamicCombinationTable(_ModType __P, uint32_t __n) : m_brt(__P) {",
			"            m_factorial.reserve(__n + 1);",
			"            m_factorialInv.reserve(__n + 1);",
			"            m_factorial.push_back(1);",
			"            m_factorialInv.push_back(1);",
			"            m_factorialInv.push_back(1);",
			"            for (uint32_t i = 1; i <= __n; i++) m_factorial.push_back(m_brt.multiply(m_factorial.back(), i));",
			"            for (uint32_t i = 2; i <= __n; i++) {",
			"                _ModType q = __P / i, r = __P - q * i;",
			"                m_factorialInv.push_back(m_brt.multiply(__P - q, m_factorialInv[r]));",
			"            }",
			"            for (uint32_t i = 1; i <= __n; i++) m_factorialInv[i] = m_brt.multiply(m_factorialInv[i - 1], m_factorialInv[i]);",
			"        }",
			"        _ModType comb(_ModType __n, _ModType __m) const {",
			"            if (__n < __m) return 0;",
			"            if (__n == __m) return 1;",
			"            return m_brt.multiply(m_factorial[__n], m_brt.multiply(m_factorialInv[__m], m_factorialInv[__n - __m]));",
			"        }",
			"        _ModType perm(_ModType __n) const { return m_factorial[__n]; }",
			"        _ModType perm(_ModType __n, _ModType __m) const {",
			"            if (__n < __m) return 0;",
			"            if (__n == __m) return m_factorial[__n];",
			"            return m_brt.multiply(m_factorial[__n], m_factorialInv[__n - __m]);",
			"        }",
			"        template <typename _Tp>",
			"        _ModType perm(const std::vector<_Tp> &__ns) const {",
			"            _ModType res = std::accumulate(__ns.begin(), __ns.end(), _ModType(0));",
			"            for (_Tp n : __ns) res = m_brt.multiply(res, n);",
			"            return res;",
			"        }",
			"        _ModType nonadjacentComb(_ModType __n, _ModType __m) const {",
			"            if (__n < __m) return 0;",
			"            return comb(__n - __m + 1, __m);",
			"        }",
			"        _ModType staggeredComb(_ModType __n) const {",
			"            static std::vector<_ModType> s_res{1, 0};",
			"            while (s_res.size() < __n + 1) s_res.push_back(m_brt.multiply(s_res[s_res.size() - 2] + s_res.back(), s_res.size() - 1));",
			"            return s_res[__n];",
			"        }",
			"        _ModType circularPerm(_ModType __n) const { return m_factorial[__n - 1]; }",
			"        _ModType circularPerm(_ModType __n, _ModType __m) const {",
			"            if (!__m) return 1;",
			"            return m_brt.multiply(comb(__n, __m), m_factorial[__m - 1]);",
			"        }",
			"    };",
			"    using DynamicCombinationTable32 = DynamicCombinationTable<uint32_t>;",
			"    using DynamicCombinationTable64 = DynamicCombinationTable<uint64_t>;",
			"}",
		],
		"description": "dynamic combination table"
	},
	"dynamic Euclidean":{
		"prefix": "EUC",
		"body": [
			"namespace OY {",
			"    struct DynamicEuclidean {",
			"        struct _DynamicEuclidean_ans {",
			"            uint32_t f, g, h;",
			"        };",
			"        DynamicModularInverse32 m_dmi;",
			"        Barrett32 &m_brt;",
			"        uint32_t m_inv2;",
			"        uint32_t m_inv6;",
			"        DynamicEuclidean(uint32_t __P) : m_dmi(__P), m_brt(m_dmi.m_mg.m_brt), m_inv2(m_dmi.query_exgcd(2)), m_inv6(m_dmi.query_exgcd(6)) {}",
			"        _DynamicEuclidean_ans calc(uint32_t __a, uint32_t __b, uint32_t __c, uint32_t __n) const {",
			"#define MUL(x, y) m_brt.multiply_64((x), (y))",
			"#define ADD(x, y) ({auto z=(x)+(y);if(z>=m_brt.mod())z-=m_brt.mod();z; })",
			"            uint32_t k1 = __a / __c, k2 = __b / __c;",
			"            __a -= k1 * __c;",
			"            __b -= k2 * __c;",
			"            const uint32_t m = (uint64_t(__a) * __n + __b) / __c, s1 = __n + 1, s2 = MUL(MUL(__n, __n + 1), m_inv2), s3 = MUL(MUL(MUL(__n, __n + 1), __n * 2 + 1), m_inv6);",
			"            uint32_t F = ADD(MUL(s2, k1), MUL(s1, k2));",
			"            uint32_t G = ADD(MUL(s3, k1), MUL(s2, k2));",
			"            uint32_t H = ADD(ADD(MUL(s3, MUL(k1, k1)), MUL(s1, MUL(k2, k2))), MUL(s2 * 2, MUL(k1, k2)));",
			"            if (__a && m) {",
			"                auto [f, g, h] = calc(__c, __c - __b - 1, __a, m - 1);",
			"                uint32_t df = ADD(MUL(__n, m), m_brt.mod() - f);",
			"                F = ADD(F, df);",
			"                uint32_t dg = ADD(MUL(m, s2), m_brt.mod() - MUL(f + h, m_inv2));",
			"                G = ADD(G, dg);",
			"                uint32_t dh = ADD(ADD(ADD(ADD(MUL(__n, MUL(m, m + 1)), ADD(m_brt.mod() - g, m_brt.mod() - g)), ADD(m_brt.mod() - f, m_brt.mod() - f)), m_brt.mod() - df), ADD(MUL(2 * k1, dg), MUL(2 * k2, df)));",
			"                H = ADD(H, dh);",
			"            }",
			"#undef MUL",
			"#undef ADD",
			"            return {F, G, H};",
			"        }",
			"    };",
			"}",
		],
		"description": "dynamic Euclidean"
	},
	"dynamic lucas table":{
		"prefix": "LUCAS",
		"body": [
			"namespace OY {",
			"    struct DynamicLucasTable {",
			"        Barrett32 m_brt;",
			"        std::vector<uint32_t> m_factorial;",
			"        std::vector<uint32_t> m_factorialInverse;",
			"        DynamicLucasTable(uint32_t __P) : m_brt(__P) {",
			"            // assert(isPrime(__P));",
			"            m_factorial.reserve(__P);",
			"            m_factorial.push_back(1);",
			"            for (uint32_t i = 1; i < __P; i++) m_factorial.push_back(m_brt.multiply_64(m_factorial.back(), i));",
			"            m_factorialInverse.resize(__P);",
			"            m_factorialInverse.back() = m_brt.pow_64(m_factorial.back(), __P - 2);",
			"            for (uint32_t i = __P - 1; i; i--) m_factorialInverse[i - 1] = m_brt.multiply_64(m_factorialInverse[i], i);",
			"        }",
			"        uint32_t rawQuery(uint32_t __n, uint32_t __m) const {",
			"            // assert(__n<m_brt.mod() &&__m<m_brt.mod());",
			"            if (!__m || __n == __m) return 1;",
			"            if (__n < __m) return 0;",
			"            return m_brt.multiply_64(m_factorial[__n], m_brt.multiply_64(m_factorialInverse[__m], m_factorialInverse[__n - __m]));",
			"        }",
			"        uint32_t query(uint64_t __n, uint64_t __m) const {",
			"            if (__n < __m) return 0;",
			"            uint32_t res = 1;",
			"            while (__m && __n != __m) {",
			"                uint64_t n = __n / m_brt.mod(), m = __m / m_brt.mod();",
			"                res = m_brt.multiply_64(res, rawQuery(__n - n * m_brt.mod(), __m - m * m_brt.mod()));",
			"                __n = n;",
			"                __m = m;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Lucas"
	},
	"dynamic modint":{
		"prefix": "MOD",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, int _Id>",
			"    struct DynamicModInt {",
			"        using mint = DynamicModInt<_ModType, _Id>;",
			"        _ModType m_val;",
			"        static inline Barrett<_ModType> s_brt;",
			"        static inline bool s_isPrime = true;",
			"        DynamicModInt() : m_val(0) {}",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>> * = nullptr>",
			"        DynamicModInt(_Tp __val) {",
			"            int64_t x = int64_t(__val) % int64_t(mod());",
			"            if (x < 0) x += mod();",
			"            m_val = x;",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>> * = nullptr>",
			"        DynamicModInt(_Tp __val) { m_val = s_brt.mod(__val); }",
			"        static mint raw(_ModType __val) {",
			"            mint res;",
			"            res.m_val = __val;",
			"            return res;",
			"        }",
			"        static void setMod(_ModType __P, bool __isPrime = false) {",
			"            assert(__P > 1 && __P < 1ull << 63);",
			"            s_brt = Barrett<_ModType>(__P);",
			"            s_isPrime = __isPrime;",
			"        }",
			"        static _ModType mod() { return s_brt.mod(); }",
			"        _ModType val() const { return m_val; }",
			"        mint pow(uint64_t __n) const { return s_brt.pow(m_val, __n); }",
			"        mint inv() const { return s_isPrime ? inv_Fermat() : inv_exgcd(); }",
			"        mint inv_exgcd() const {",
			"            _ModType x = mod(), y = m_val, m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= mod()) m0 += mod() / x;",
			"            return raw(m0);",
			"        }",
			"        mint inv_Fermat() const { return pow(mod() - 2); }",
			"        mint &operator++() {",
			"            if (++m_val == mod()) m_val = 0;",
			"            return *this;",
			"        }",
			"        mint &operator--() {",
			"            if (m_val-- == 0) m_val = mod() - 1;",
			"            return *this;",
			"        }",
			"        mint operator++(int) {",
			"            mint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        mint operator--(int) {",
			"            mint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        mint &operator+=(const mint &__other) {",
			"            m_val += __other.m_val;",
			"            if (m_val >= mod()) m_val -= mod();",
			"            return *this;",
			"        }",
			"        mint &operator-=(const mint &__other) {",
			"            m_val -= __other.m_val;",
			"            if (m_val >= mod()) m_val += mod();",
			"            return *this;",
			"        }",
			"        mint &operator*=(const mint &__other) {",
			"            m_val = s_brt.multiply(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        mint &operator/=(const mint &__other) { return *this *= __other.inv(); }",
			"        mint operator+() const { return *this; }",
			"        mint operator-() const { return raw(m_val ? mod() - m_val : 0); }",
			"        bool operator==(const mint &__other) const { return m_val == __other.m_val; }",
			"        bool operator!=(const mint &__other) const { return m_val != __other.m_val; }",
			"        bool operator<(const mint &__other) const { return m_val < __other.m_val; }",
			"        bool operator>(const mint &__other) const { return m_val > __other.m_val; }",
			"        bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        template <typename _Tp>",
			"        explicit operator _Tp() const { return _Tp(m_val); }",
			"        friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }",
			"        friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }",
			"        friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }",
			"        friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, mint &self) { return is >> self.m_val; }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.m_val; }",
			"    };",
			"    template <int _Id>",
			"    using DynamicModInt32 = DynamicModInt<uint32_t, _Id>;",
			"    template <int _Id>",
			"    using DynamicModInt64 = DynamicModInt<uint64_t, _Id>;",
			"}",
		],
		"description": "dynamic modint"
	},
	"dynamic modular inverse":{
		"prefix": "INV",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct DynamicModularInverse {",
			"        Montgomery<_ModType> m_mg;",
			"        bool m_isPrime;",
			"        constexpr DynamicModularInverse(_ModType __P, bool __isPrime = false) : m_mg(__P), m_isPrime(__isPrime) {}",
			"        constexpr _ModType query_Fermat(_ModType __a) const {",
			"            assert(m_isPrime);",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return m_mg.reduce(m_mg.pow(m_mg.init(__a), m_mg.mod() - 2));",
			"            else",
			"                return m_mg.m_brt.pow_64(__a, m_mg.mod() - 2);",
			"        }",
			"        constexpr _ModType query_exgcd(_ModType __a) const {",
			"            _ModType x = m_mg.mod(), y = __a, m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= m_mg.mod()) m0 += m_mg.mod() / x;",
			"            return m0;",
			"        }",
			"        constexpr _ModType query(_ModType __a) const {",
			"            if (m_isPrime)",
			"                return query_Fermat(__a);",
			"            else",
			"                return query_exgcd(__a);",
			"        }",
			"        template <typename _Iterator>",
			"        std::vector<_ModType> query(_Iterator __first, _Iterator __last) const {",
			"            int n = __last - __first;",
			"            std::vector<_ModType> res(n);",
			"            std::partial_sum(__first, __last, res.begin(), [&](_ModType a, _ModType b) { return m_mg.m_brt.multiply(a, b); });",
			"            _ModType inv = query(res.back());",
			"            for (int i = n - 1; i; i--) {",
			"                res[i] = m_mg.m_brt.multiply(inv, res[i - 1]);",
			"                inv = m_mg.m_brt.multiply(inv, __first[i]);",
			"            }",
			"            res[0] = inv;",
			"            return res;",
			"        }",
			"    };",
			"    using DynamicModularInverse32 = DynamicModularInverse<uint32_t>;",
			"    using DynamicModularInverse64 = DynamicModularInverse<uint64_t>;",
			"}",
		],
		"description": "dynamic modular inverse"
	},
	"dynamic modular inverse table":{
		"prefix": "INV",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    class DynamicModularInverseTable {",
			"        std::vector<_ModType> m_inv;",
			"        Barrett<_ModType> m_brt;",
			"",
			"    public:",
			"        DynamicModularInverseTable(_ModType __P, uint32_t __n) : m_brt(__P) {",
			"            // assert(OY::isPrime<_ModType>(__P));",
			"            if (__n >= __P) __n = __P - 1;",
			"            m_inv.reserve(__n + 1);",
			"            m_inv.push_back(0);",
			"            m_inv.push_back(1);",
			"            for (uint32_t i = 2; i <= __n; i++) {",
			"                _ModType q = __P / i, r = __P - q * i;",
			"                m_inv.push_back(m_brt.multiply(__P - q, m_inv[r]));",
			"            }",
			"        }",
			"        _ModType query(uint32_t __a) const {",
			"            // assert(__a<m_brt.mod());",
			"            return m_inv[__a];",
			"        }",
			"    };",
			"    using DynamicModularInverseTable32 = DynamicModularInverseTable<uint32_t>;",
			"    using DynamicModularInverseTable64 = DynamicModularInverseTable<uint64_t>;",
			"}",
		],
		"description": "dynamic modular inverse table"
	},
	"dynamic montgomery modint":{
		"prefix": "MG",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, int _Id>",
			"    struct DynamicMontgomeryModInt {",
			"        using mint = DynamicMontgomeryModInt<_ModType, _Id>;",
			"        using _FastType = typename Montgomery<_ModType>::_FastType;",
			"        static inline Montgomery<_ModType> s_mg;",
			"        static inline bool s_isPrime = true;",
			"        _FastType m_val;",
			"        DynamicMontgomeryModInt() : m_val(0) {}",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>> * = nullptr>",
			"        DynamicMontgomeryModInt(_Tp __val) {",
			"            int64_t x = int64_t(__val) % int64_t(mod());",
			"            if (x < 0) x += mod();",
			"            m_val = s_mg.init(x);",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>> * = nullptr>",
			"        DynamicMontgomeryModInt(_Tp __val) { m_val = s_mg.init(__val); }",
			"        static mint raw(_FastType __val) {",
			"            mint res;",
			"            res.m_val = __val;",
			"            return res;",
			"        }",
			"        static void setMod(_ModType __P, bool __isPrime = false) {",
			"            assert(__P % 2 == 1 && __P > 1 && __P < _MontgomeryTag<_ModType>::limit);",
			"            s_mg = Montgomery<_ModType>(__P);",
			"            s_isPrime = __isPrime;",
			"        }",
			"        static _ModType mod() { return s_mg.mod(); }",
			"        _ModType val() const { return s_mg.reduce(m_val); }",
			"        mint pow(uint64_t __n) const { return raw(s_mg.pow(m_val, __n)); }",
			"        mint inv() const { return s_isPrime ? inv_Fermat() : inv_exgcd(); }",
			"        mint inv_exgcd() const {",
			"            _ModType x = mod(), y = val(), m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= mod()) m0 += mod() / x;",
			"            return m0;",
			"        }",
			"        mint inv_Fermat() const { return pow(mod() - 2); }",
			"        mint &operator++() {",
			"            (*this) += raw(s_mg.raw_init(1));",
			"            return *this;",
			"        }",
			"        mint &operator--() {",
			"            (*this) += raw(s_mg.raw_init(mod() - 1));",
			"            return *this;",
			"        }",
			"        mint operator++(int) {",
			"            mint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        mint operator--(int) {",
			"            mint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        mint &operator+=(const mint &__other) {",
			"            m_val += __other.m_val;",
			"            if (m_val >= mod()) m_val -= mod();",
			"            return *this;",
			"        }",
			"        mint &operator-=(const mint &__other) {",
			"            m_val -= __other.m_val;",
			"            if (m_val >= mod()) m_val += mod();",
			"            return *this;",
			"        }",
			"        mint &operator*=(const mint &__other) {",
			"            m_val = s_mg.multiply(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        mint &operator/=(const mint &__other) { return *this *= __other.inv(); }",
			"        mint operator+() const { return *this; }",
			"        mint operator-() const { return raw(m_val ? mod() - m_val : 0); }",
			"        bool operator==(const mint &__other) const { return m_val == __other.m_val; }",
			"        bool operator!=(const mint &__other) const { return m_val != __other.m_val; }",
			"        bool operator<(const mint &__other) const { return m_val < __other.m_val; }",
			"        bool operator>(const mint &__other) const { return m_val > __other.m_val; }",
			"        bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        template <typename _Tp>",
			"        explicit operator _Tp() const { return _Tp(s_mg.reduce(m_val)); }",
			"        friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }",
			"        friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }",
			"        friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }",
			"        friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, mint &self) {",
			"            _ModType x;",
			"            is >> x;",
			"            self = mint(x);",
			"            return is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.val(); }",
			"    };",
			"    template <int _Id>",
			"    using DynamicMontgomeryModInt32 = DynamicMontgomeryModInt<uint32_t, _Id>;",
			"    template <int _Id>",
			"    using DynamicMontgomeryModInt64 = DynamicMontgomeryModInt<uint64_t, _Id>;",
			"}",
		],
		"description": "dynamic montgomery modint"
	},
	"Eratosthenes Sieve":{
		"prefix": "SIEVE",
		"body": [
			"namespace OY {",
			"    template <uint32_t _N, bool _B>",
			"    struct _EratosthenesSieveArray {",
			"        uint32_t data[_N + 1];",
			"        void set(int __i, uint32_t __val) { data[__i] = __val; }",
			"        uint32_t operator[](int __i) const { return data[__i]; }",
			"    };",
			"    template <uint32_t _N>",
			"    struct _EratosthenesSieveArray<_N, false> {",
			"        void set(int __i, uint32_t __val) {}",
			"        uint32_t operator[](int __i) const { return 1; }",
			"    };",
			"    template <uint32_t _N, bool _Prime = true, bool _Phi = false, bool _Small = false, bool _Big = false>",
			"    class EratosthenesSieve {",
			"        static constexpr uint32_t sqrt = [] {",
			"            uint32_t i = 1;",
			"            while (i * i + i * 2 + 1 <= _N) i++;",
			"            return i;",
			"        }();",
			"        _EratosthenesSieveArray<_N, _Small> m_smallestFactor;",
			"        _EratosthenesSieveArray<_N, _Big> m_biggestFactor;",
			"        _EratosthenesSieveArray<_N, _Phi> m_phi;",
			"        _EratosthenesSieveArray<_N >= 1000000 ? _N / 12 : 100000, _Prime> m_primeList;",
			"        std::bitset<_N + 1> m_isp;",
			"        uint32_t m_primeCnt;",
			"",
			"    public:",
			"        EratosthenesSieve() : m_primeCnt{0} {",
			"            m_isp.set();",
			"            m_isp.reset(1);",
			"            m_smallestFactor.set(1, 1);",
			"            m_biggestFactor.set(1, 1);",
			"            m_phi.set(1, 1);",
			"            m_smallestFactor.set(2, 2);",
			"            m_biggestFactor.set(2, 2);",
			"            m_phi.set(2, 1);",
			"            m_primeList.set(m_primeCnt++, 2);",
			"            for (int i = 3; i <= sqrt; i += 2)",
			"                if (m_isp[i]) {",
			"                    m_smallestFactor.set(i, i);",
			"                    m_phi.set(i, i - 1);",
			"                    m_primeList.set(m_primeCnt++, i);",
			"                    for (int j = i; j <= _N; j += i) m_biggestFactor.set(j, i);",
			"                    for (int j = i * i, k = i; j <= _N; j += i * 2, k += 2) {",
			"                        if (m_isp[j]) {",
			"                            m_isp.reset(j);",
			"                            m_smallestFactor.set(j, i);",
			"                            m_phi.set(j, i);",
			"                            m_phi.set(j + 1, k);",
			"                        }",
			"                    }",
			"                } else",
			"                    m_phi.set(i, m_phi[i + 1] % m_phi[i] ? (m_phi[i] - 1) * m_phi[m_phi[i + 1]] : m_phi[i] * m_phi[m_phi[i + 1]]);",
			"            for (int i = sqrt + sqrt % 2 + 1; i <= _N; i += 2)",
			"                if (m_isp[i]) {",
			"                    m_smallestFactor.set(i, i);",
			"                    m_phi.set(i, i - 1);",
			"                    m_primeList.set(m_primeCnt++, i);",
			"                    for (int j = i; j <= _N; j += i) m_biggestFactor.set(j, i);",
			"                } else",
			"                    m_phi.set(i, m_phi[i + 1] % m_phi[i] ? (m_phi[i] - 1) * m_phi[m_phi[i + 1]] : m_phi[i] * m_phi[m_phi[i + 1]]);",
			"        }",
			"        bool isPrime(uint32_t __i) const { return (__i & 1) || __i == 2 ? m_isp[__i] : false; }",
			"        uint32_t EulerPhi(uint32_t __i) const {",
			"            static_assert(_Phi);",
			"            return __i & 1 ? m_phi[__i] : m_phi[__i >> std::__countr_zero(__i)] << std::__countr_zero(__i) - 1;",
			"        }",
			"        uint32_t querySmallestFactor(uint32_t __i) const {",
			"            static_assert(_Small);",
			"            return __i & 1 ? m_smallestFactor[__i] : 2;",
			"        }",
			"        uint32_t queryBiggestFactor(uint32_t __i) const {",
			"            static_assert(_Big);",
			"            if (__i & 1) return m_biggestFactor[__i];",
			"            __i >>= std::__countr_zero(__i);",
			"            return __i == 1 ? 2 : m_biggestFactor[__i];",
			"        }",
			"        uint32_t queryKthPrime(int __k) const {",
			"            static_assert(_Prime);",
			"            return m_primeList[__k];",
			"        }",
			"        uint32_t count() const { return m_primeCnt; }",
			"        auto decomposite(uint32_t __n) const {",
			"            static_assert(_Small);",
			"            struct node {",
			"                uint32_t prime, count;",
			"            };",
			"            std::vector<node> res;",
			"            if (__n % 2 == 0) {",
			"                res.push_back({2, uint32_t(std::__countr_zero(__n))});",
			"                __n >>= std::__countr_zero(__n);",
			"            }",
			"            while (__n > 1) {",
			"                uint32_t cur = querySmallestFactor(__n);",
			"                uint32_t num = 0;",
			"                do {",
			"                    __n /= cur;",
			"                    num++;",
			"                } while (querySmallestFactor(__n) == cur);",
			"                res.push_back({cur, num});",
			"            }",
			"            return res;",
			"        }",
			"        std::vector<uint32_t> getFactors(uint32_t __n) const {",
			"            static_assert(_Small);",
			"            auto pf = decomposite(__n);",
			"            std::vector<uint32_t> res;",
			"            uint32_t count = 1;",
			"            for (auto [p, c] : pf) count *= c + 1;",
			"            res.reserve(count);",
			"            auto dfs = [&](auto self, int i, uint32_t prod) -> void {",
			"                if (i == pf.size())",
			"                    res.push_back(prod);",
			"                else {",
			"                    auto [p, c] = pf[i];",
			"                    self(self, i + 1, prod);",
			"                    while (c--) self(self, i + 1, prod *= p);",
			"                }",
			"            };",
			"            dfs(dfs, 0, 1);",
			"            std::sort(res.begin(), res.end());",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Eratosthenes Sieve"
	},
	"Euler Sieve":{
		"prefix": "SIEVE",
		"body": [
			"namespace OY {",
			"    template <uint32_t _N, bool _B>",
			"    struct _EulerSieveArray {",
			"        uint32_t data[_N + 1];",
			"        void set(int __i, uint32_t __val) { data[__i] = __val; }",
			"        uint32_t operator[](int __i) const { return data[__i]; }",
			"    };",
			"    template <uint32_t _N>",
			"    struct _EulerSieveArray<_N, false> {",
			"        void set(int __i, uint32_t __val) {}",
			"        uint32_t operator[](int __i) const { return 1; }",
			"    };",
			"    template <uint32_t _N, bool _Phi = false, bool _Small = false, bool _Big = false>",
			"    class EulerSieve {",
			"        _EulerSieveArray<_N + 1, _Phi> m_phi;",
			"        _EulerSieveArray<_N + 1, _Small> m_smallestFactor;",
			"        _EulerSieveArray<_N + 1, _Big> m_biggestFactor;",
			"        std::bitset<_N + 1> m_isp;",
			"        uint32_t m_primeList[_N >= 1000000 ? _N / 12 : 100000];",
			"        uint32_t m_primeCnt;",
			"",
			"    public:",
			"        EulerSieve() : m_primeCnt{0} {",
			"            m_isp.set();",
			"            m_isp.reset(1);",
			"            m_phi.set(1, 1);",
			"            m_smallestFactor.set(1, 1);",
			"            m_biggestFactor.set(1, 1);",
			"            for (int i = 2; i <= _N; i++) {",
			"                if (m_isp[i]) {",
			"                    m_phi.set(i, i - 1);",
			"                    m_smallestFactor.set(i, i);",
			"                    m_biggestFactor.set(i, i);",
			"                    m_primeList[m_primeCnt++] = i;",
			"                }",
			"                for (uint32_t *it = m_primeList, *end = m_primeList + m_primeCnt; it < end; ++it) {",
			"                    auto p = *it, q = i * p;",
			"                    if (q > _N) break;",
			"                    m_isp.reset(q);",
			"                    m_smallestFactor.set(q, p);",
			"                    m_biggestFactor.set(q, m_biggestFactor[i]);",
			"                    if (i % p)",
			"                        m_phi.set(q, m_phi[i] * (p - 1));",
			"                    else {",
			"                        m_phi.set(q, m_phi[i] * p);",
			"                        break;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        bool isPrime(uint32_t __i) const { return (__i & 1) || __i == 2 ? m_isp[__i] : false; }",
			"        uint32_t EulerPhi(uint32_t __i) const {",
			"            static_assert(_Phi);",
			"            return __i & 1 ? m_phi[__i] : m_phi[__i >> std::__countr_zero(__i)] << std::__countr_zero(__i) - 1;",
			"        }",
			"        uint32_t querySmallestFactor(uint32_t __i) const {",
			"            static_assert(_Small);",
			"            return __i & 1 ? m_smallestFactor[__i] : 2;",
			"        }",
			"        uint32_t queryBiggestFactor(uint32_t __i) const {",
			"            static_assert(_Big);",
			"            return m_biggestFactor[__i];",
			"        }",
			"        uint32_t queryKthPrime(int __k) const { return m_primeList[__k]; }",
			"        uint32_t count() const { return m_primeCnt; }",
			"        auto decomposite(uint32_t __n) {",
			"            struct node {",
			"                uint32_t prime, count;",
			"            };",
			"            std::vector<node> res;",
			"            if (__n % 2 == 0) {",
			"                res.push_back({2, uint32_t(std::__countr_zero(__n))});",
			"                __n >>= std::__countr_zero(__n);",
			"            }",
			"            while (__n > 1) {",
			"                uint32_t cur = querySmallestFactor(__n);",
			"                uint32_t num = 0;",
			"                do {",
			"                    __n /= cur;",
			"                    num++;",
			"                } while (querySmallestFactor(__n) == cur);",
			"                res.push_back({cur, num});",
			"            }",
			"            return res;",
			"        }",
			"        std::vector<uint32_t> getFactors(uint32_t __n) {",
			"            auto pf = decomposite(__n);",
			"            std::vector<uint32_t> res;",
			"            uint32_t count = 1;",
			"            for (auto [p, c] : pf) count *= c + 1;",
			"            res.reserve(count);",
			"            auto dfs = [&](auto self, int i, uint32_t prod) -> void {",
			"                if (i == pf.size())",
			"                    res.push_back(prod);",
			"                else {",
			"                    auto [p, c] = pf[i];",
			"                    self(self, i + 1, prod);",
			"                    while (c--) self(self, i + 1, prod *= p);",
			"                }",
			"            };",
			"            dfs(dfs, 0, 1);",
			"            std::sort(res.begin(), res.end());",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "Euler Sieve"
	},
	"exgcd":{
		"prefix": "EXGCD",
		"body": [
			"namespace OY {",
			"    constexpr auto exGCD(int64_t a, int64_t b) {",
			"        struct _exGCD_ans {",
			"            int64_t g, k1, k2;",
			"        };",
			"        if (!a && !b) return _exGCD_ans{0, 0, 0};",
			"        int64_t s = b, t = a, m0 = 0, m1 = 1, m2 = 1, m3 = 0;",
			"        while (t) {",
			"            int64_t u = s / t;",
			"            std::tie(s, m0, m2) = std::make_tuple(s - t * u, m0 - m1 * u, m2 - m3 * u);",
			"            std::swap(s, t);",
			"            std::swap(m0, m1);",
			"            std::swap(m2, m3);",
			"        }",
			"        if (s < 0) std::tie(s, m0, m2) = std::make_tuple(-s, -m0, -m2);",
			"        return _exGCD_ans{s, m0, m2};",
			"    }",
			"    constexpr auto exGCD(int64_t a, int64_t b, int64_t c) {",
			"        struct _exGCD_ans {",
			"            int64_t g, res, k1;",
			"        };",
			"        if (!a) return b && c % b == 0 ? _exGCD_ans{b, c, 0} : _exGCD_ans{b, 0, 0};",
			"        if (!b) return a && c % a == 0 ? _exGCD_ans{a, c, c / a} : _exGCD_ans{a, 0, 0};",
			"        int64_t s = b, t = a, m0 = 0, m1 = 1;",
			"        while (t) {",
			"            int64_t u = s / t;",
			"            std::tie(s, m0) = std::make_tuple(s - t * u, m0 - m1 * u);",
			"            std::swap(s, t);",
			"            std::swap(m0, m1);",
			"        }",
			"        if (c % s) return _exGCD_ans{std::abs(s), 0, 0};",
			"        std::tie(a, b) = std::make_tuple(a / s, b / s);",
			"        if (b < 0) std::tie(a, b) = std::make_tuple(-a, -b);",
			"        if (b <= UINT32_MAX) {",
			"            Barrett32 brt(b);",
			"            if (m0 >= 0)",
			"                m0 = brt.mod(m0);",
			"            else {",
			"                m0 = brt.mod(-m0);",
			"                if (m0) m0 = b - m0;",
			"            }",
			"            int64_t x = c / s;",
			"            if (x >= 0)",
			"                x = brt.mod(x);",
			"            else {",
			"                x = brt.mod(-x);",
			"                if (x) x = b - x;",
			"            }",
			"            m0 = brt.multiply_64(m0, x);",
			"        } else {",
			"            Barrett64 brt(b);",
			"            if (m0 >= 0)",
			"                m0 = brt.mod(m0);",
			"            else {",
			"                m0 = brt.mod(-m0);",
			"                if (m0) m0 = b - m0;",
			"            }",
			"            int64_t x = c / s;",
			"            if (x >= 0)",
			"                x = brt.mod(x);",
			"            else {",
			"                x = brt.mod(-x);",
			"                if (x) x = b - x;",
			"            }",
			"            m0 = brt.multiply_ld(m0, x);",
			"        }",
			"        return _exGCD_ans{std::abs(s), c, m0};",
			"    }",
			"}",
		],
		"description": "exgcd"
	},
	"gcd and lcm":{
		"prefix": "GCD",
		"body": [
			"namespace OY {",
			"    template <typename _Elem>",
			"    constexpr _Elem gcd(_Elem a, _Elem b) {",
			"        if (!a || !b) return a | b;",
			"        int i = std::__countr_zero(a), j = std::__countr_zero(b), k = std::min(i, j);",
			"        a >>= i;",
			"        b >>= j;",
			"        while (true) {",
			"            if (a < b) std::swap(a, b);",
			"            if (!(a -= b)) break;",
			"            a >>= std::__countr_zero(a);",
			"        }",
			"        return b << k;",
			"    }",
			"    template <typename _Elem>",
			"    constexpr _Elem lcm(_Elem a, _Elem b) { return a && b ? a / gcd<_Elem>(a, b) * b : 0; }",
			"    constexpr auto gcd32 = gcd<uint32_t>;",
			"    constexpr auto gcd64 = gcd<uint64_t>;",
			"    constexpr auto lcm32 = lcm<uint32_t>;",
			"    constexpr auto lcm64 = lcm<uint64_t>;",
			"}",
		],
		"description": "gcd and lcm"
	},
	"limited gcd":{
		"prefix": "GCD",
		"body": [
			"namespace OY {",
			"    template <uint32_t _N>",
			"    class LimitedGCD {",
			"        static constexpr uint32_t sqrt = [] {",
			"            uint32_t i = 1;",
			"            while (i * i + i * 2 + 1 <= _N) i++;",
			"            return i;",
			"        }();",
			"        uint32_t m_decomposition[_N + 1][3];",
			"        uint32_t m_smallestFactor[_N + 1]{0};",
			"        uint32_t m_gcd[sqrt][sqrt];",
			"        uint32_t m_primeList[_N >= 1000000 ? _N / 12 : 100000];",
			"        uint32_t m_primeCnt = 0;",
			"",
			"    public:",
			"        LimitedGCD() {",
			"            m_decomposition[0][0] = m_decomposition[0][1] = 1;",
			"            m_decomposition[0][2] = 0;",
			"            m_decomposition[1][0] = m_decomposition[1][1] = m_decomposition[1][2] = 1;",
			"            for (int i = 2; i <= _N; i++) {",
			"                if (!m_smallestFactor[i]) {",
			"                    m_smallestFactor[i] = i;",
			"                    m_primeList[m_primeCnt++] = i;",
			"                    m_decomposition[i][0] = m_decomposition[i][1] = 1;",
			"                    m_decomposition[i][2] = i;",
			"                } else {",
			"                    uint32_t a = i / m_smallestFactor[i];",
			"                    std::copy(m_decomposition[a], m_decomposition[a + 1], m_decomposition[i]);",
			"                    m_decomposition[i][0] *= m_smallestFactor[i];",
			"                    std::sort(m_decomposition[i], m_decomposition[i + 1]);",
			"                }",
			"                for (uint32_t *it = m_primeList, *end = m_primeList + m_primeCnt; it < end; ++it) {",
			"                    auto p = *it, q = p * i;",
			"                    if (q > _N) break;",
			"                    if (i % p)",
			"                        m_smallestFactor[q] = p;",
			"                    else {",
			"                        m_smallestFactor[q] = m_smallestFactor[p];",
			"                        break;",
			"                    }",
			"                }",
			"            }",
			"            for (int j = 0; j < sqrt; j++) m_gcd[0][j] = j;",
			"            for (int i = 1; i < sqrt; i++) {",
			"                m_gcd[i][0] = i;",
			"                for (int j = 1; j < i; j++) m_gcd[i][j] = m_gcd[i - j][j];",
			"                m_gcd[i][i] = i;",
			"                for (int j = i + 1; j < sqrt; j++) m_gcd[i][j] = m_gcd[i][j - i];",
			"            }",
			"        }",
			"        uint32_t gcd(uint32_t __a, uint32_t __b) const {",
			"            if (__a < sqrt)",
			"                return __b < sqrt ? m_gcd[__a][__b] : m_gcd[__a][__b % __a];",
			"            else if (__b < sqrt)",
			"                return m_gcd[__b][__a % __b];",
			"            if (m_decomposition[__a][1] == 1) return __b % __a ? 1 : __a;",
			"            if (m_decomposition[__b][1] == 1) return __a % __b ? 1 : __b;",
			"            uint32_t res = 1;",
			"            auto transfer = [&](uint32_t x) {",
			"                res *= x;",
			"                __b /= x;",
			"            };",
			"            if (uint32_t f1 = m_decomposition[__a][0]; f1 > 1) {",
			"                if (int x = __b % f1; !x) {",
			"                    res *= f1;",
			"                    __b /= f1;",
			"                } else if (m_decomposition[f1][1] > 1)",
			"                    transfer(m_gcd[f1][x]);",
			"            }",
			"            uint32_t f2 = m_decomposition[__a][1];",
			"            if (int x = __b % f2; !x) {",
			"                res *= f2;",
			"                __b /= f2;",
			"            } else if (m_decomposition[f2][1] > 1)",
			"                transfer(m_gcd[f2][x]);",
			"            uint32_t f3 = m_decomposition[__a][2];",
			"            if (int x = __b % f3; !x)",
			"                res *= f3;",
			"            else if (f3 < sqrt && m_decomposition[f3][1] > 1)",
			"                transfer(m_gcd[f3][x]);",
			"            return res;",
			"        }",
			"        uint64_t lcm(uint32_t __a, uint32_t __b) const { return __a && __b ? uint64_t(__a / gcd(__a, __b)) * __b : 0; }",
			"        auto getSolver(uint32_t __a) const {",
			"            class _solver {",
			"                Barrett32 brt, brt1, brt2, brt3;",
			"                uint32_t f1, f2, f3;",
			"                const uint32_t *gcd1, *gcd2, *gcd3;",
			"                bool isPrime1, isPrime2, isPrime3;",
			"                const LimitedGCD &helper;",
			"                void transfer(uint32_t &res, uint32_t &b, uint32_t t) const {",
			"                    res *= t;",
			"                    b /= t;",
			"                }",
			"",
			"            public:",
			"                _solver(uint32_t a, const LimitedGCD &_helper) : helper(_helper) {",
			"                    f1 = _helper.m_decomposition[a][0];",
			"                    f2 = _helper.m_decomposition[a][1];",
			"                    f3 = _helper.m_decomposition[a][2];",
			"                    brt.m_P = a;",
			"                    if (f3 <= 1) return;",
			"                    brt = Barrett32(a);",
			"                    brt3 = Barrett32(f3);",
			"                    gcd3 = _helper.m_gcd[f3];",
			"                    isPrime3 = f3 >= sqrt || helper.m_decomposition[f3][1] == 1;",
			"                    if (f3 > sqrt) {",
			"                        f2 *= f1;",
			"                        f1 = 1;",
			"                    }",
			"                    if (f2 == 1) return;",
			"                    brt2 = Barrett32(f2);",
			"                    gcd2 = _helper.m_gcd[f2];",
			"                    isPrime2 = helper.m_decomposition[f2][1] == 1;",
			"                    if (f1 == 1) return;",
			"                    brt1 = Barrett32(f1);",
			"                    gcd1 = _helper.m_gcd[f1];",
			"                    isPrime1 = helper.m_decomposition[f1][1] == 1;",
			"                }",
			"                uint32_t queryGCD(uint32_t b) const {",
			"                    if (!b) return brt.mod();",
			"                    if (f3 == 0) return b;",
			"                    if (f3 == 1) return 1;",
			"                    if (f2 == 1) return brt.mod(b) ? 1 : brt.mod();",
			"                    if (helper.m_decomposition[b][1] == 1) return brt.mod() % b ? 1 : b;",
			"                    uint32_t res = 1;",
			"                    if (f1 > 1) {",
			"                        if (auto [quo, rem] = brt1.divmod(b); !rem) {",
			"                            res *= f1;",
			"                            b = quo;",
			"                        } else if (!isPrime1)",
			"                            transfer(res, b, *(gcd1 + rem));",
			"                    }",
			"                    if (auto [quo, rem] = brt2.divmod(b); !rem) {",
			"                        res *= f2;",
			"                        b = quo;",
			"                    } else if (!isPrime2)",
			"                        transfer(res, b, *(gcd2 + rem));",
			"                    if (auto [quo, rem] = brt3.divmod(b); !rem)",
			"                        res *= f3;",
			"                    else if (!isPrime3)",
			"                        transfer(res, b, *(gcd3 + rem));",
			"                    return res;",
			"                }",
			"                uint64_t queryLCM(uint32_t b) const {",
			"                    if (!b || !f3) return 0;",
			"                    if (f3 == 1) return b;",
			"                    if (f2 == 1) return brt.mod(b) ? uint64_t(f3) * b : b;",
			"                    if (helper.m_decomposition[b][1] == 1) return brt.mod() % b ? uint64_t(brt.mod()) * b : brt.mod();",
			"                    if (f1 > 1) {",
			"                        if (auto [quo, rem] = brt1.divmod(b); !rem)",
			"                            b = quo;",
			"                        else if (!isPrime1)",
			"                            b /= *(gcd1 + rem);",
			"                    }",
			"                    if (auto [quo, rem] = brt2.divmod(b); !rem)",
			"                        b = quo;",
			"                    else if (!isPrime2)",
			"                        b /= *(gcd2 + rem);",
			"                    if (auto [quo, rem] = brt3.divmod(b); !rem)",
			"                        b = quo;",
			"                    else if (!isPrime3)",
			"                        b /= *(gcd3 + rem);",
			"                    return uint64_t(brt.mod()) * b;",
			"                    ;",
			"                }",
			"            };",
			"            return _solver(__a, *this);",
			"        }",
			"    };",
			"}",
		],
		"description": "limited gcd"
	},
	"lucas":{
		"prefix": "LUCAS",
		"body": [
			"namespace OY {",
			"    struct Lucas {",
			"        Barrett32 m_brt;",
			"        Lucas(uint32_t __P) : m_brt(__P) {",
			"            // assert(isPrime(__P));",
			"        }",
			"        uint32_t rawQuery(uint32_t __n, uint32_t __m) const {",
			"            // assert(__n<m_brt.mod() && __m<m_brt.mod());",
			"            if (!__m || __n == __m) return 1;",
			"            if (__n < __m) return 0;",
			"            if (__m > __n - __m) __m = __n - __m;",
			"            uint32_t a = 1, b = 1;",
			"            for (uint32_t i = 1, j = __n - __m + 1; i <= __m; i++, j++) {",
			"                a = m_brt.multiply_64(a, i);",
			"                b = m_brt.multiply_64(b, j);",
			"            }",
			"            return m_brt.multiply_64(m_brt.pow(a, m_brt.mod() - 2), b);",
			"        }",
			"        uint32_t query(uint64_t __n, uint64_t __m) const {",
			"            if (__n < __m) return 0;",
			"            uint32_t res = 1;",
			"            while (__m && __n != __m) {",
			"                uint64_t n = __n / m_brt.mod(), m = __m / m_brt.mod();",
			"                res = m_brt.multiply_64(res, rawQuery(__n - n * m_brt.mod(), __m - m * m_brt.mod()));",
			"                __n = n;",
			"                __m = m;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"}",
		],
		"description": "lucas"
	},
	"matrix":{
		"prefix": "MATRIX",
		"body": [
			"namespace OY {",
			"    template <typename _Tp, uint32_t _M, uint32_t _N>",
			"    struct Matrix {",
			"        _Tp m_val[_M][_N];",
			"        static constexpr uint32_t row = _M;",
			"        static constexpr uint32_t column = _N;",
			"        static Matrix<_Tp, _M, _N> raw(_Tp __a) {",
			"            Matrix<_Tp, _M, _N> res;",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) res[i][j] = __a;",
			"            return res;",
			"        }",
			"        static Matrix<_Tp, _M, _M> unit() {",
			"            static_assert(_M == _N);",
			"            Matrix<_Tp, _M, _M> res{};",
			"            for (uint32_t i = 0; i < _M; i++) res[i][i] = 1;",
			"            return res;",
			"        }",
			"        _Tp *operator[](uint32_t __i) { return m_val[__i]; }",
			"        const _Tp *operator[](uint32_t __i) const { return m_val[__i]; }",
			"        Matrix<_Tp, _M, _N> &operator+=(_Tp __a) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    m_val[i][j] += __a;",
			"            return *this;",
			"        }",
			"        Matrix<_Tp, _M, _N> &operator-=(_Tp __a) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    m_val[i][j] -= __a;",
			"            return *this;",
			"        }",
			"        Matrix<_Tp, _M, _N> &operator*=(_Tp __a) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    m_val[i][j] *= __a;",
			"            return *this;",
			"        }",
			"        Matrix<_Tp, _M, _N> &operator+=(const Matrix<_Tp, _M, _N> &__other) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    m_val[i][j] += __other[i][j];",
			"            return *this;",
			"        }",
			"        Matrix<_Tp, _M, _N> &operator-=(const Matrix<_Tp, _M, _N> &__other) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    m_val[i][j] -= __other[i][j];",
			"            return *this;",
			"        }",
			"        Matrix<_Tp, _M, _M> pow(uint64_t __n) const {",
			"            static_assert(_M == _N);",
			"            Matrix<_Tp, _M, _M> res = unit(), a = *this;",
			"            while (__n) {",
			"                if (__n & 1) res = res * a;",
			"                a = a * a;",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Fp>",
			"        friend Matrix<_Tp, _M, _N> operator+(const Matrix<_Tp, _M, _N> &__a, const _Fp &__b) { return Matrix<_Tp, _M, _N>(__a) += __b; }",
			"        template <typename _Fp>",
			"        friend Matrix<_Tp, _M, _N> operator-(const Matrix<_Tp, _M, _N> &__a, const _Fp &__b) { return Matrix<_Tp, _M, _N>(__a) -= __b; }",
			"        friend Matrix<_Tp, _M, _N> operator*(const Matrix<_Tp, _M, _N> &__a, const _Tp &__b) { return Matrix<_Tp, _M, _N>(__a) *= __b; }",
			"        template <uint32_t _L>",
			"        friend Matrix<_Tp, _M, _L> operator*(const Matrix<_Tp, _M, _N> &__a, const Matrix<_Tp, _N, _L> &__b) {",
			"            Matrix<_Tp, _M, _L> res{};",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++) {",
			"                    _Tp a = __a[i][j];",
			"                    for (uint32_t k = 0; k < _L; k++)",
			"                        res[i][k] += a * __b[j][k];",
			"                }",
			"            return res;",
			"        }",
			"        friend bool operator==(const Matrix<_Tp, _M, _N> &__a, const Matrix<_Tp, _M, _N> &__b) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    if (__a[i][j] != __b[i][j]) return false;",
			"            return true;",
			"        }",
			"        friend bool operator!=(const Matrix<_Tp, _M, _N> &__a, const Matrix<_Tp, _M, _N> &__b) {",
			"            for (uint32_t i = 0; i < _M; i++)",
			"                for (uint32_t j = 0; j < _N; j++)",
			"                    if (__a[i][j] != __b[i][j]) return true;",
			"            return false;",
			"        }",
			"    };",
			"};",
		],
		"description": "matrix"
	},
	"modular":{
		"prefix": "MOD",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P>",
			"    struct Modular {",
			"        static constexpr _ModType mod() { return _P; }",
			"        static constexpr _ModType mod(uint64_t __a) { return __a % _P; }",
			"        static constexpr _ModType multiply(uint64_t __a, uint64_t __b) {",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return multiply_ld(__a, __b);",
			"            else",
			"                return multiply_64(__a, __b);",
			"        }",
			"        static constexpr _ModType multiply_64(uint64_t __a, uint64_t __b) {",
			"            // assert(__a * __b < 1ull << 64);",
			"            return mod(__a * __b);",
			"        }",
			"        static constexpr _ModType multiply_128(uint64_t __a, uint64_t __b) { return __uint128_t(__a) * __b % _P; }",
			"        static constexpr _ModType multiply_ld(uint64_t __a, uint64_t __b) {",
			"            // assert(m_P < 1ull << 63 && __a < m_P && __b < m_P);",
			"            if (std::__countl_zero(__a) + std::__countl_zero(__b) >= 64) return multiply_64(__a, __b);",
			"            int64_t res = __a * __b - uint64_t(1.L / _P * __a * __b) * _P;",
			"            if (res < 0)",
			"                res += _P;",
			"            else if (res >= _P)",
			"                res -= _P;",
			"            return res;",
			"        }",
			"        static constexpr _ModType pow(uint64_t __a, uint64_t __n) {",
			"            if constexpr (std::is_same_v<_ModType, uint64_t>)",
			"                return pow_ld(__a, __n);",
			"            else",
			"                return pow_64(__a, __n);",
			"        }",
			"        static constexpr _ModType pow_64(uint64_t __a, uint64_t __n) {",
			"            // assert(m_P < 1ull << 32);",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_64(res, b);",
			"                b = multiply_64(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        static constexpr _ModType pow_128(uint64_t __a, uint64_t __n) {",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_128(res, b);",
			"                b = multiply_128(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        static constexpr _ModType pow_ld(uint64_t __a, uint64_t __n) {",
			"            _ModType res = 1, b = mod(__a);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply_ld(res, b);",
			"                b = multiply_ld(b, b);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Tp>",
			"        static constexpr _Tp divide(_Tp __a) { return __a / _P; }",
			"        template <typename _Tp>",
			"        static constexpr std::pair<_Tp, _Tp> divmod(_Tp __a) {",
			"            _Tp quo = __a / _P, rem = __a - quo * _P;",
			"            return {quo, rem};",
			"        }",
			"    };",
			"    template <uint32_t _P>",
			"    using Modular32 = Modular<uint32_t, _P>;",
			"    template <uint64_t _P>",
			"    using Modular64 = Modular<uint64_t, _P>;",
			"}",
		],
		"description": "modular"
	},
	"montgomery":{
		"prefix": "MG",
		"body": [
			"namespace OY {",
			"    template <typename _ModType>",
			"    struct _MontgomeryTag;",
			"    template <>",
			"    struct _MontgomeryTag<uint32_t> {",
			"        using long_type = uint64_t;",
			"        static constexpr uint32_t limit = (1u << 30) - 1;",
			"        static constexpr uint32_t inv_loop = 4;",
			"        static constexpr uint32_t length = 32;",
			"    };",
			"    template <>",
			"    struct _MontgomeryTag<uint64_t> {",
			"        using long_type = __uint128_t;",
			"        static constexpr uint64_t limit = (1ull << 63) - 1;",
			"        static constexpr uint32_t inv_loop = 5;",
			"        static constexpr uint32_t length = 64;",
			"    };",
			"    template <typename _ModType>",
			"    struct Montgomery {",
			"        using _FastType = _ModType;",
			"        using _LongType = typename _MontgomeryTag<_ModType>::long_type;",
			"        _ModType m_P;",
			"        _ModType m_Pinv;",
			"        _ModType m_Ninv;",
			"        Barrett<_ModType> m_brt;",
			"        constexpr Montgomery() = default;",
			"        constexpr explicit Montgomery(_ModType __P) : m_P(__P), m_Pinv(__P), m_Ninv(-_LongType(__P) % __P), m_brt(__P) {",
			"            for (int i = 0; i < _MontgomeryTag<_ModType>::inv_loop; i++) m_Pinv *= _ModType(2) - __P * m_Pinv;",
			"        }",
			"        constexpr _ModType mod() const { return m_brt.mod(); }",
			"        constexpr _ModType mod(uint64_t __a) const { return m_brt.mod(__a); }",
			"        constexpr _FastType init(uint64_t __a) const { return reduce(_LongType(mod(__a)) * m_Ninv); }",
			"        constexpr _FastType raw_init(uint64_t __a) const { return reduce(_LongType(__a) * m_Ninv); }",
			"        constexpr _FastType reduce(_LongType __a) const {",
			"            _FastType res = (__a >> _MontgomeryTag<_ModType>::length) - _ModType(_LongType(_ModType(__a) * m_Pinv) * m_P >> _MontgomeryTag<_ModType>::length);",
			"            if (res >= mod()) res += mod();",
			"            return res;",
			"        }",
			"        constexpr _ModType reduce(_FastType __a) const {",
			"            _ModType res = -_ModType(_LongType(__a * m_Pinv) * m_P >> _MontgomeryTag<_ModType>::length);",
			"            if (res >= mod()) res += mod();",
			"            return res;",
			"        }",
			"        constexpr _FastType multiply(_FastType __a, _FastType __b) const { return reduce(_LongType(__a) * __b); }",
			"        constexpr _FastType pow(_FastType __a, uint64_t __n) const {",
			"            _FastType res = reduce(_LongType(1) * m_Ninv);",
			"            while (__n) {",
			"                if (__n & 1) res = multiply(res, __a);",
			"                __a = multiply(__a, __a);",
			"                __n >>= 1;",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Tp>",
			"        constexpr _Tp divide(_Tp __a) const { return m_brt.divide(__a); }",
			"        template <typename _Tp>",
			"        constexpr std::pair<_Tp, _Tp> divmod(_Tp __a) const { return m_brt.divmod(__a); }",
			"    };",
			"    using Montgomery32 = Montgomery<uint32_t>;",
			"    using Montgomery64 = Montgomery<uint64_t>;",
			"}",
		],
		"description": "montgomery"
	},
	"pollard pho":{
		"prefix": "PP",
		"body": [
			"namespace OY {",
			"    struct Pollard_Rho {",
			"        static constexpr uint64_t batch = 128;",
			"        static inline std::mt19937_64 s_rander;",
			"        template <typename _Elem>",
			"        static _Elem pick(_Elem __n) {",
			"            // assert(!isPrime<_Elem>(__n));",
			"            if (__n % 2 == 0) return 2;",
			"            static Montgomery<_Elem> mg;",
			"            if (mg.mod() != __n) mg = Montgomery<_Elem>(__n);",
			"            std::uniform_int_distribution<_Elem> distribute(2, __n - 1);",
			"            _Elem v0, v1 = mg.init(distribute(s_rander)), prod = mg.init(1), c = mg.init(distribute(s_rander));",
			"            for (int i = 1; i < batch; i <<= 1) {",
			"                v0 = v1;",
			"                for (int j = 0; j < i; j++) v1 = mg.multiply(v1, v1) + c;",
			"                for (int j = 0; j < i; j++) {",
			"                    v1 = mg.multiply(v1, v1) + c;",
			"                    prod = mg.multiply(prod, v0 > v1 ? v0 - v1 : v1 - v0);",
			"                    if (!prod) return pick(__n);",
			"                }",
			"                if (_Elem g = gcd<_Elem>(prod, __n); g > 1) return g;",
			"            }",
			"            for (int i = batch;; i <<= 1) {",
			"                v0 = v1;",
			"                for (int j = 0; j < i; j++) v1 = mg.multiply(v1, v1) + c;",
			"                for (int j = 0; j < i; j += batch) {",
			"                    for (int k = 0; k < batch; k++) {",
			"                        v1 = mg.multiply(v1, v1) + c;",
			"                        prod = mg.multiply(prod, v0 > v1 ? v0 - v1 : v1 - v0);",
			"                        if (!prod) return pick(__n);",
			"                    }",
			"                    if (_Elem g = gcd<_Elem>(prod, __n); g > 1) return g;",
			"                }",
			"            }",
			"            return __n;",
			"        }",
			"        template <typename _Elem>",
			"        static auto decomposite(_Elem __n) {",
			"            struct node {",
			"                _Elem prime;",
			"                uint32_t count;",
			"            };",
			"            std::vector<node> res;",
			"            auto dfs = [&](auto self, _Elem cur) -> void {",
			"                if (!OY::isPrime<_Elem>(cur)) {",
			"                    _Elem a = pick<_Elem>(cur);",
			"                    self(self, a);",
			"                    self(self, cur / a);",
			"                } else {",
			"                    auto find = std::find_if(res.begin(), res.end(), [cur](auto x) { return x.prime == cur; });",
			"                    if (find == res.end())",
			"                        res.push_back({cur, 1u});",
			"                    else",
			"                        find->count++;",
			"                }",
			"            };",
			"            if (__n % 2 == 0) {",
			"                res.push_back({2, uint32_t(std::__countr_zero(__n))});",
			"                __n >>= std::__countr_zero(__n);",
			"            }",
			"            if (__n > 1) dfs(dfs, __n);",
			"            std::sort(res.begin(), res.end(), [](auto &x, auto &y) { return x.prime < y.prime; });",
			"            return res;",
			"        }",
			"        template <typename _Elem>",
			"        static std::vector<_Elem> getFactors(_Elem __n) {",
			"            auto pf = decomposite(__n);",
			"            std::vector<_Elem> res;",
			"            _Elem count = 1;",
			"            for (auto [p, c] : pf) count *= c + 1;",
			"            res.reserve(count);",
			"            auto dfs = [&](auto self, int i, _Elem prod) -> void {",
			"                if (i == pf.size())",
			"                    res.push_back(prod);",
			"                else {",
			"                    auto [p, c] = pf[i];",
			"                    self(self, i + 1, prod);",
			"                    while (c--) self(self, i + 1, prod *= p);",
			"                }",
			"            };",
			"            dfs(dfs, 0, 1);",
			"            std::sort(res.begin(), res.end());",
			"            return res;",
			"        }",
			"        template <typename _Elem>",
			"        static _Elem EulerPhi(_Elem __n) {",
			"            for (auto [p, c] : decomposite(__n)) __n = __n / p * (p - 1);",
			"            return __n;",
			"        }",
			"    };",
			"}",
		],
		"description": "pollard pho"
	},
	"prime check":{
		"prefix": "PRIME",
		"body": [
			"namespace OY {",
			"    template <typename _Elem>",
			"    constexpr bool isPrime(_Elem n) {",
			"        if (std::is_same_v<_Elem, uint32_t> || n <= UINT32_MAX) {",
			"            if (n <= 1) return false;",
			"            if (n == 2 || n == 7 || n == 61) return true;",
			"            if (n % 2 == 0) return false;",
			"            Barrett32 brt(n);",
			"            uint32_t d = (n - 1) >> std::__countr_zero(n - 1);",
			"            for (auto &&a : {2, 7, 61}) {",
			"                uint32_t s = d, y = brt.pow_64(a, s);",
			"                while (s != n - 1 && y != 1 && y != n - 1) {",
			"                    y = brt.multiply_64(y, y);",
			"                    s <<= 1;",
			"                }",
			"                if (y != n - 1 && s % 2 == 0) return false;",
			"            }",
			"            return true;",
			"        } else {",
			"            // assert(n < 1ull < 63);",
			"            if (n % 2 == 0) return false;",
			"            Montgomery64 mg(n);",
			"            uint64_t d = (n - 1) >> std::__countr_zero(n - 1), one = mg.init(1);",
			"            for (auto &&a : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
			"                uint64_t s = d, y = mg.pow(mg.init(a), s), t = mg.init(n - 1);",
			"                while (s != n - 1 && y != one && y != t) {",
			"                    y = mg.multiply(y, y);",
			"                    s <<= 1;",
			"                }",
			"                if (y != t && s % 2 == 0) return false;",
			"            }",
			"            return true;",
			"        }",
			"    }",
			"    constexpr auto isPrime32 = isPrime<uint32_t>;",
			"    constexpr auto isPrime64 = isPrime<uint64_t>;",
			"}",
		],
		"description": "prime check"
	},
	"prime sieve":{
		"prefix": "PRIME",
		"body": [
			"namespace OY {",
			"#pragma pack(4)",
			"    struct SievePair {",
			"        uint32_t P;",
			"        __uint128_t Pinv;",
			"        constexpr SievePair() : P{}, Pinv{} {}",
			"        constexpr SievePair(uint32_t _P) : P{_P}, Pinv{uint64_t(-1) / _P + 1} {}",
			"    };",
			"#pragma pack()",
			"    struct SievePairs {",
			"        static constexpr uint32_t smallBound = 10000;",
			"        static constexpr uint32_t smallPrimeCount = 1228;",
			"        static constexpr uint32_t smallPrimes[smallPrimeCount]{3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919, 7927, 7933, 7937, 7949, 7951, 7963, 7993, 8009, 8011, 8017, 8039, 8053, 8059, 8069, 8081, 8087, 8089, 8093, 8101, 8111, 8117, 8123, 8147, 8161, 8167, 8171, 8179, 8191, 8209, 8219, 8221, 8231, 8233, 8237, 8243, 8263, 8269, 8273, 8287, 8291, 8293, 8297, 8311, 8317, 8329, 8353, 8363, 8369, 8377, 8387, 8389, 8419, 8423, 8429, 8431, 8443, 8447, 8461, 8467, 8501, 8513, 8521, 8527, 8537, 8539, 8543, 8563, 8573, 8581, 8597, 8599, 8609, 8623, 8627, 8629, 8641, 8647, 8663, 8669, 8677, 8681, 8689, 8693, 8699, 8707, 8713, 8719, 8731, 8737, 8741, 8747, 8753, 8761, 8779, 8783, 8803, 8807, 8819, 8821, 8831, 8837, 8839, 8849, 8861, 8863, 8867, 8887, 8893, 8923, 8929, 8933, 8941, 8951, 8963, 8969, 8971, 8999, 9001, 9007, 9011, 9013, 9029, 9041, 9043, 9049, 9059, 9067, 9091, 9103, 9109, 9127, 9133, 9137, 9151, 9157, 9161, 9173, 9181, 9187, 9199, 9203, 9209, 9221, 9227, 9239, 9241, 9257, 9277, 9281, 9283, 9293, 9311, 9319, 9323, 9337, 9341, 9343, 9349, 9371, 9377, 9391, 9397, 9403, 9413, 9419, 9421, 9431, 9433, 9437, 9439, 9461, 9463, 9467, 9473, 9479, 9491, 9497, 9511, 9521, 9533, 9539, 9547, 9551, 9587, 9601, 9613, 9619, 9623, 9629, 9631, 9643, 9649, 9661, 9677, 9679, 9689, 9697, 9719, 9721, 9733, 9739, 9743, 9749, 9767, 9769, 9781, 9787, 9791, 9803, 9811, 9817, 9829, 9833, 9839, 9851, 9857, 9859, 9871, 9883, 9887, 9901, 9907, 9923, 9929, 9931, 9941, 9949, 9967, 9973};",
			"        SievePair sp[smallPrimeCount];",
			"        constexpr SievePairs() {",
			"            for (int i = 0; i < smallPrimeCount; i++) sp[i] = SievePair(smallPrimes[i]);",
			"        }",
			"    };",
			"    template <uint32_t _N>",
			"    class PrimeSieve {",
			"        uint32_t m_primeList[_N >= 1000000 ? _N / 12 : 100000];",
			"        uint32_t m_primeCnt;",
			"        static constexpr SievePairs s_pairs{};",
			"",
			"    public:",
			"        PrimeSieve() : m_primeList{}, m_primeCnt{0} {",
			"            constexpr uint32_t blockSize = 32768;",
			"            bool notP[blockSize]{0};",
			"            m_primeList[m_primeCnt++] = 2;",
			"            for (auto &&p : s_pairs.smallPrimes) m_primeList[m_primeCnt++] = p;",
			"            for (int start = s_pairs.smallBound, end = s_pairs.smallBound + (blockSize << 1); start <= _N; start = end, end += blockSize << 1) {",
			"                for (auto &&[p, pInv] : s_pairs.sp) {",
			"                    uint32_t j = ((start + p - 1) * pInv) >> 64;",
			"                    if (j * p > start + p - 1) j--;",
			"                    for (bool *it = notP + (((j | 1) * p - start) >> 1), *itend = notP + blockSize; it < itend; it += p) *it = true;",
			"                }",
			"                for (auto &b : notP) {",
			"                    if (b)",
			"                        b = false;",
			"                    else if (int i = start + ((&b - notP) << 1 | 1); i <= _N)",
			"                        m_primeList[m_primeCnt++] = i;",
			"                    else",
			"                        break;",
			"                }",
			"            }",
			"        }",
			"        std::bitset<_N + 1> to_bitset() const {",
			"            std::bitset<_N + 1> res;",
			"            for (int i = 0; i < m_primeCnt && i <= _N; i++) res.set(m_primeList[i]);",
			"            return res;",
			"        }",
			"        uint32_t queryKthPrime(int __k) const { return m_primeList[__k]; }",
			"        uint32_t count() const { return m_primeCnt; }",
			"    };",
			"}",
		],
		"description": "prime sieve"
	},
	"primitive root":{
		"prefix": "PROOT",
		"body": [
			"namespace OY {",
			"    template <uint32_t _N>",
			"    struct PrimitiveRootSieveSolver {",
			"        static inline EratosthenesSieve<_N, false, false, true, false> es;",
			"        static uint32_t pick(uint32_t P) { return es.querySmallestFactor(P); }",
			"        static std::vector<uint32_t> getSub(uint32_t phi) {",
			"            std::vector<uint32_t> res;",
			"            for (uint32_t cur = phi; cur > 1;) {",
			"                uint32_t prime = es.querySmallestFactor(cur);",
			"                res.push_back(phi / prime);",
			"                while (cur % prime == 0) cur /= prime;",
			"            }",
			"            return res;",
			"        }",
			"    };",
			"    struct PrimitiveRootPollardPhoSolver {",
			"        template <typename _ModType>",
			"        static _ModType pick(_ModType P) {",
			"            while (!OY::isPrime<_ModType>(P)) P = Pollard_Rho::pick<_ModType>(P);",
			"            return P;",
			"        }",
			"        template <typename _ModType>",
			"        static std::vector<_ModType> getSub(_ModType phi) {",
			"            std::vector<_ModType> res;",
			"            auto comps = Pollard_Rho::decomposite<_ModType>(phi);",
			"            res.reserve(comps.size());",
			"            for (auto [p, c] : comps) res.push_back(phi / p);",
			"            return res;",
			"        }",
			"    };",
			"    template <typename _ModType, typename _Solver>",
			"    struct PrimitiveRoot {",
			"        static bool isPrimitiveRoot(_ModType a, _ModType phi, std::vector<_ModType> &sub, Barrett<_ModType> &brt) {",
			"            if (brt.pow(a, phi) != 1) return false;",
			"            for (auto v : sub)",
			"                if (brt.pow(a, v) == 1) return false;",
			"            return true;",
			"        }",
			"        static _ModType queryMin(_ModType P) {",
			"            if (P <= 4) return P - 1;",
			"            _ModType oddP = P & 1 ? P : P >> 1;",
			"            if (!(oddP & 1)) return 0;",
			"            _ModType prime = _Solver::pick(oddP);",
			"            while (oddP % prime == 0) oddP /= prime;",
			"            if (oddP > 1) return 0;",
			"            _ModType phi = (P & 1 ? P : P >> 1) / prime * (prime - 1);",
			"            std::vector<_ModType> sub = _Solver::getSub(phi);",
			"            Barrett<_ModType> brt(P);",
			"            uint32_t cur = 2;",
			"            while (!isPrimitiveRoot(cur, phi, sub, brt)) cur++;",
			"            return cur;",
			"        }",
			"    };",
			"    template <uint32_t _N>",
			"    using PrimitiveRoot32_Sieve = PrimitiveRoot<uint32_t, PrimitiveRootSieveSolver<_N>>;",
			"    using PrimitiveRoot32_PollardPho = PrimitiveRoot<uint32_t, PrimitiveRootPollardPhoSolver>;",
			"    using PrimitiveRoot64_PollardPho = PrimitiveRoot<uint64_t, PrimitiveRootPollardPhoSolver>;",
			"}",
		],
		"description": "primitive root"
	},
	"static Cantor rank":{
		"prefix": "CANTOR",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P>",
			"    struct StaticCantorRank {",
			"        template <typename _Iterator>",
			"        static _ModType rawQuery(_Iterator __first, _Iterator __last) {",
			"            const uint32_t n = __last - __first;",
			"            BIT<uint32_t> counter(*std::max_element(__first, __last) + 1);",
			"            _ModType permutation = 1, res = 0;",
			"            for (uint32_t index = n - 1; ~index; index--) {",
			"                if (__first[index])",
			"                    if (res += Modular<_ModType, _P>::multiply(permutation, counter.presum(__first[index] - 1)); res >= _P) res -= _P;",
			"                permutation = Modular<_ModType, _P>::multiply(permutation, n - index);",
			"                counter.add(__first[index], 1);",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"        static _ModType query(_Iterator __first, _Iterator __last) {",
			"            const uint32_t n = __last - __first;",
			"            _Tp sorted[n];",
			"            uint32_t id[n];",
			"            std::copy(__first, __last, sorted);",
			"            std::sort(sorted, sorted + n);",
			"            for (uint32_t i = 0; i < n; i++) id[i] = std::lower_bound(sorted, sorted + n, __first[i]) - sorted;",
			"            return rawQuery(id, id + n);",
			"        }",
			"    };",
			"    template <typename _ModType, _ModType _P>",
			"    struct StaticCantorRank_ex {",
			"        StaticModularInverseTable<_ModType, _P> m_invTable;",
			"        StaticCantorRank_ex(uint32_t __maxNumber) : m_invTable(__maxNumber) {}",
			"        template <typename _Iterator>",
			"        _ModType rawQuery(_Iterator __first, _Iterator __last) const {",
			"            const uint32_t n = __last - __first;",
			"            BIT<uint32_t> counter(*std::max_element(__first, __last) + 1);",
			"            _ModType permutation = 1, res = 0;",
			"            for (uint32_t index = n - 1; ~index; index--) {",
			"                uint32_t s1 = counter.presum(__first[index]), s2 = __first[index] ? counter.presum(__first[index] - 1) : 0;",
			"                permutation = Modular<_ModType, _P>::multiply(permutation, m_invTable.query(s1 - s2 + 1));",
			"                if (__first[index])",
			"                    if (res += Modular<_ModType, _P>::multiply(permutation, s2); res >= _P) res -= _P;",
			"                permutation = Modular<_ModType, _P>::multiply(permutation, n - index);",
			"                counter.add(__first[index], 1);",
			"            }",
			"            return res;",
			"        }",
			"        template <typename _Iterator, typename _Tp = typename std::iterator_traits<_Iterator>::value_type>",
			"        _ModType query(_Iterator __first, _Iterator __last) const {",
			"            const uint32_t n = __last - __first;",
			"            _Tp sorted[n];",
			"            uint32_t id[n];",
			"            std::copy(__first, __last, sorted);",
			"            std::sort(sorted, sorted + n);",
			"            const uint32_t unique_n = std::unique(sorted, sorted + n) - sorted;",
			"            for (uint32_t i = 0; i < n; i++) id[i] = std::lower_bound(sorted, sorted + unique_n, __first[i]) - sorted;",
			"            return rawQuery(id, id + n);",
			"        }",
			"    };",
			"    template <uint32_t _P>",
			"    using StaticCantorRank32 = StaticCantorRank<uint32_t, _P>;",
			"    template <uint64_t _P>",
			"    using StaticCantorRank64 = StaticCantorRank<uint64_t, _P>;",
			"    template <uint32_t _P>",
			"    using StaticCantorRank_ex32 = StaticCantorRank_ex<uint32_t, _P>;",
			"    template <uint64_t _P>",
			"    using StaticCantorRank_ex64 = StaticCantorRank_ex<uint64_t, _P>;",
			"}",
		],
		"description": "static Cantor rank"
	},
	"static Catalan table":{
		"prefix": "CATALAN",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P>",
			"    struct StaticCatalanTable {",
			"        std::vector<_ModType> m_val;",
			"        StaticModularInverseTable<_ModType, _P> m_invTable;",
			"        StaticCatalanTable(uint32_t __n) : m_invTable(__n + 1) {",
			"            m_val.reserve(__n + 1);",
			"            m_val.push_back(1);",
			"            for (uint32_t i = 1; i <= __n; i++) {",
			"                m_val.push_back(Modular<_ModType, _P>::multiply(Modular<_ModType, _P>::multiply(m_val.back(), i * 4 - 2), m_invTable.query(i + 1)));",
			"            }",
			"        }",
			"        _ModType query(uint32_t __i) const { return m_val[__i]; }",
			"    };",
			"    template <uint32_t _P>",
			"    using StaticCatalanTable32 = StaticCatalanTable<uint32_t, _P>;",
			"    template <uint64_t _P>",
			"    using StaticCatalanTable64 = StaticCatalanTable<uint64_t, _P>;",
			"}",
		],
		"description": "static Catalan table"
	},
	"static combination table":{
		"prefix": "COMB",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P>",
			"    struct StaticCombinationTable {",
			"        std::vector<_ModType> m_factorial;",
			"        std::vector<_ModType> m_factorialInv;",
			"        StaticCombinationTable(uint32_t __n) {",
			"            m_factorial.reserve(__n + 1);",
			"            m_factorialInv.reserve(__n + 1);",
			"            m_factorial.push_back(1);",
			"            m_factorialInv.push_back(1);",
			"            m_factorialInv.push_back(1);",
			"            for (uint32_t i = 1; i <= __n; i++) m_factorial.push_back(Modular<_ModType, _P>::multiply(m_factorial.back(), i));",
			"            for (uint32_t i = 2; i <= __n; i++) {",
			"                _ModType q = _P / i, r = _P - q * i;",
			"                m_factorialInv.push_back(Modular<_ModType, _P>::multiply(_P - q, m_factorialInv[r]));",
			"            }",
			"            for (uint32_t i = 1; i <= __n; i++) m_factorialInv[i] = Modular<_ModType, _P>::multiply(m_factorialInv[i - 1], m_factorialInv[i]);",
			"        }",
			"        _ModType comb(_ModType __n, _ModType __m) const {",
			"            if (__n < __m) return 0;",
			"            if (__n == __m) return 1;",
			"            return Modular<_ModType, _P>::multiply(m_factorial[__n], Modular<_ModType, _P>::multiply(m_factorialInv[__m], m_factorialInv[__n - __m]));",
			"        }",
			"        _ModType perm(_ModType __n) const { return m_factorial[__n]; }",
			"        _ModType perm(_ModType __n, _ModType __m) const {",
			"            if (__n < __m) return 0;",
			"            if (__n == __m) return m_factorial[__n];",
			"            return Modular<_ModType, _P>::multiply(m_factorial[__n], m_factorialInv[__n - __m]);",
			"        }",
			"        template <typename _Tp>",
			"        _ModType perm(const std::vector<_Tp> &__ns) const {",
			"            _ModType res = std::accumulate(__ns.begin(), __ns.end(), _ModType(0));",
			"            for (_Tp n : __ns) res = Modular<_ModType, _P>::multiply(res, n);",
			"            return res;",
			"        }",
			"        _ModType nonadjacentComb(_ModType __n, _ModType __m) const {",
			"            if (__n < __m) return 0;",
			"            return comb(__n - __m + 1, __m);",
			"        }",
			"        _ModType staggeredComb(_ModType __n) const {",
			"            static std::vector<_ModType> s_res{1, 0};",
			"            while (s_res.size() < __n + 1) s_res.push_back(Modular<_ModType, _P>::multiply(s_res[s_res.size() - 2] + s_res.back(), s_res.size() - 1));",
			"            return s_res[__n];",
			"        }",
			"        _ModType circularPerm(_ModType __n) const { return m_factorial[__n - 1]; }",
			"        _ModType circularPerm(_ModType __n, _ModType __m) const {",
			"            if (!__m) return 1;",
			"            return Modular<_ModType, _P>::multiply(comb(__n, __m), m_factorial[__m - 1]);",
			"        }",
			"    };",
			"    template <uint32_t _P>",
			"    using StaticCombinationTable32 = StaticCombinationTable<uint32_t, _P>;",
			"    template <uint64_t _P>",
			"    using StaticCombinationTable64 = StaticCombinationTable<uint64_t, _P>;",
			"}",
		],
		"description": "static combination table"
	},
	"static Euclidean":{
		"prefix": "EUC",
		"body": [
			"namespace OY {",
			"    template <uint32_t _P>",
			"    struct StaticEuclidean {",
			"        static constexpr uint32_t inv_2 = OY::StaticModularInverse32<_P>::query_exgcd(2), inv_6 = OY::StaticModularInverse32<_P>::query_exgcd(6);",
			"        struct _StaticEuclidean_ans {",
			"            uint32_t f, g, h;",
			"        };",
			"        static _StaticEuclidean_ans calc(uint32_t __a, uint32_t __b, uint32_t __c, uint32_t __n) {",
			"#define MUL(x, y) OY::Modular32<_P>::multiply_64((x), (y))",
			"#define ADD(x, y) ({auto z=(x)+(y);if(z>=_P)z-=_P;z; })",
			"            uint32_t k1 = __a / __c, k2 = __b / __c;",
			"            __a -= k1 * __c;",
			"            __b -= k2 * __c;",
			"            const uint32_t m = (uint64_t(__a) * __n + __b) / __c, s1 = __n + 1, s2 = MUL(MUL(__n, __n + 1), inv_2), s3 = MUL(MUL(MUL(__n, __n + 1), __n * 2 + 1), inv_6);",
			"            uint32_t F = ADD(MUL(s2, k1), MUL(s1, k2));",
			"            uint32_t G = ADD(MUL(s3, k1), MUL(s2, k2));",
			"            uint32_t H = ADD(ADD(MUL(s3, MUL(k1, k1)), MUL(s1, MUL(k2, k2))), MUL(s2 * 2, MUL(k1, k2)));",
			"            if (__a && m) {",
			"                auto [f, g, h] = calc(__c, __c - __b - 1, __a, m - 1);",
			"                uint32_t df = ADD(MUL(__n, m), _P - f);",
			"                F = ADD(F, df);",
			"                uint32_t dg = ADD(MUL(m, s2), _P - MUL(f + h, inv_2));",
			"                G = ADD(G, dg);",
			"                uint32_t dh = ADD(ADD(ADD(ADD(MUL(__n, MUL(m, m + 1)), ADD(_P - g, _P - g)), ADD(_P - f, _P - f)), _P - df), ADD(MUL(2 * k1, dg), MUL(2 * k2, df)));",
			"                H = ADD(H, dh);",
			"            }",
			"#undef MUL",
			"#undef ADD",
			"            return {F, G, H};",
			"        }",
			"    };",
			"}",
		],
		"description": "static Euclidean"
	},
	"static modint":{
		"prefix": "MOD",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P, bool _IsPrime = false>",
			"    struct StaticModInt {",
			"        using mint = StaticModInt<_ModType, _P, _IsPrime>;",
			"        _ModType m_val;",
			"        static_assert(_P > 1 && _P < 1ull << 63);",
			"        StaticModInt() : m_val(0) {}",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>> * = nullptr>",
			"        StaticModInt(_Tp __val) {",
			"            int64_t x = int64_t(__val) % int64_t(mod());",
			"            if (x < 0) x += mod();",
			"            m_val = x;",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>> * = nullptr>",
			"        StaticModInt(_Tp __val) { m_val = __val % mod(); }",
			"        static mint raw(_ModType __val) {",
			"            mint res;",
			"            res.m_val = __val;",
			"            return res;",
			"        }",
			"        static constexpr _ModType mod() { return _P; }",
			"        _ModType val() const { return m_val; }",
			"        mint pow(uint64_t __n) const { return Modular<_ModType, _P>::pow(m_val, __n); }",
			"        mint inv() const {",
			"            if constexpr (_IsPrime)",
			"                return inv_Fermat();",
			"            else",
			"                return inv_exgcd();",
			"        }",
			"        mint inv_exgcd() const {",
			"            _ModType x = mod(), y = m_val, m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= mod()) m0 += mod() / x;",
			"            return raw(m0);",
			"        }",
			"        mint inv_Fermat() const { return pow(mod() - 2); }",
			"        mint &operator++() {",
			"            if (++m_val == mod()) m_val = 0;",
			"            return *this;",
			"        }",
			"        mint &operator--() {",
			"            if (m_val == 0) m_val = mod();",
			"            m_val--;",
			"            return *this;",
			"        }",
			"        mint operator++(int) {",
			"            mint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        mint operator--(int) {",
			"            mint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        mint &operator+=(const mint &__other) {",
			"            m_val += __other.m_val;",
			"            if (m_val >= mod()) m_val -= mod();",
			"            return *this;",
			"        }",
			"        mint &operator-=(const mint &__other) {",
			"            m_val += mod() - __other.m_val;",
			"            if (m_val >= mod()) m_val -= mod();",
			"            return *this;",
			"        }",
			"        mint &operator*=(const mint &__other) {",
			"            m_val = Modular<_ModType, _P>::multiply(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        mint &operator/=(const mint &__other) { return *this *= __other.inv(); }",
			"        mint operator+() const { return *this; }",
			"        mint operator-() const { return raw(m_val ? mod() - m_val : 0); }",
			"        bool operator==(const mint &__other) const { return m_val == __other.m_val; }",
			"        bool operator!=(const mint &__other) const { return m_val != __other.m_val; }",
			"        bool operator<(const mint &__other) const { return m_val < __other.m_val; }",
			"        bool operator>(const mint &__other) const { return m_val > __other.m_val; }",
			"        bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        template <typename _Tp>",
			"        explicit operator _Tp() const { return _Tp(m_val); }",
			"        friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }",
			"        friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }",
			"        friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }",
			"        friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, mint &self) { return is >> self.m_val; }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.m_val; }",
			"    };",
			"    template <uint32_t _P, bool _IsPrime>",
			"    using StaticModInt32 = StaticModInt<uint32_t, _P, _IsPrime>;",
			"    template <uint64_t _P, bool _IsPrime>",
			"    using StaticModInt64 = StaticModInt<uint64_t, _P, _IsPrime>;",
			"}",
		],
		"description": "static modint"
	},
	"static modular inverse":{
		"prefix": "INV",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P, bool _IsPrime = false>",
			"    struct StaticModularInverse {",
			"        static constexpr _ModType query_Fermat(_ModType __a) {",
			"            static_assert(_IsPrime);",
			"            return Modular<_ModType, _P>::pow(__a, _P - 2);",
			"        }",
			"        static constexpr _ModType query_exgcd(_ModType __a) {",
			"            _ModType x = _P, y = __a, m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                z = x, x = y, y = z;",
			"                z = m0, m0 = m1, m1 = z;",
			"            }",
			"            if (m0 >= _P) m0 += _P / x;",
			"            return m0;",
			"        }",
			"        static constexpr _ModType query(_ModType __a) {",
			"            if constexpr (_IsPrime)",
			"                return query_Fermat(__a);",
			"            else",
			"                return query_exgcd(__a);",
			"        }",
			"        template <typename _Iterator>",
			"        static std::vector<_ModType> query(_Iterator __first, _Iterator __last) {",
			"            int n = __last - __first;",
			"            std::vector<_ModType> res(n);",
			"            std::partial_sum(__first, __last, res.begin(), [&](_ModType a, _ModType b) { return Modular<_ModType, _P>::multiply(a, b); });",
			"            _ModType inv = query(res.back());",
			"            for (int i = n - 1; i; i--) {",
			"                res[i] = Modular<_ModType, _P>::multiply(inv, res[i - 1]);",
			"                inv = Modular<_ModType, _P>::multiply(inv, __first[i]);",
			"            }",
			"            res[0] = inv;",
			"            return res;",
			"        }",
			"    };",
			"    template <uint32_t _P, bool _IsPrime = false>",
			"    using StaticModularInverse32 = StaticModularInverse<uint32_t, _P, _IsPrime>;",
			"    template <uint64_t _P, bool _IsPrime = false>",
			"    using StaticModularInverse64 = StaticModularInverse<uint64_t, _P, _IsPrime>;",
			"}",
		],
		"description": "static modular inverse"
	},
	"static modular inverse table":{
		"prefix": "INV",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P>",
			"    class StaticModularInverseTable {",
			"        std::vector<_ModType> m_inv;",
			"",
			"    public:",
			"        StaticModularInverseTable(uint32_t __n) {",
			"            // assert(OY::isPrime<_ModType>(__P));",
			"            if (__n >= _P) __n = _P - 1;",
			"            m_inv.reserve(__n + 1);",
			"            m_inv.push_back(0);",
			"            m_inv.push_back(1);",
			"            for (uint32_t i = 2; i <= __n; i++) {",
			"                _ModType q = _P / i, r = _P - q * i;",
			"                m_inv.push_back(Modular<_ModType, _P>::multiply(_P - q, m_inv[r]));",
			"            }",
			"        }",
			"        _ModType query(uint32_t __a) const {",
			"            // assert(__a<m_brt.mod());",
			"            return m_inv[__a];",
			"        }",
			"    };",
			"    template <uint32_t _P>",
			"    using StaticModularInverseTable32 = StaticModularInverseTable<uint32_t, _P>;",
			"    template <uint64_t _P>",
			"    using StaticModularInverseTable64 = StaticModularInverseTable<uint64_t, _P>;",
			"}",
		],
		"description": "static modular inverse table"
	},
	"static montgomery modint":{
		"prefix": "MG",
		"body": [
			"namespace OY {",
			"    template <typename _ModType, _ModType _P, bool _IsPrime = false>",
			"    struct StaticMontgomeryModInt {",
			"        using mint = StaticMontgomeryModInt<_ModType, _P, _IsPrime>;",
			"        using _FastType = typename Montgomery<_ModType>::_FastType;",
			"        using _LongType = typename Montgomery<_ModType>::_LongType;",
			"        static constexpr Montgomery<_ModType> mg = Montgomery<_ModType>(_P);",
			"        _FastType m_val;",
			"        static_assert(_P % 2 == 1 && _P > 1 && _P < _MontgomeryTag<_ModType>::limit);",
			"        StaticMontgomeryModInt() : m_val(0) {}",
			"        template <typename _Tp, std::enable_if_t<std::is_signed_v<_Tp>> * = nullptr>",
			"        StaticMontgomeryModInt(_Tp __val) {",
			"            int64_t x = int64_t(__val) % int64_t(mod());",
			"            if (x < 0) x += mod();",
			"            m_val = mg.raw_init(x);",
			"        }",
			"        template <typename _Tp, std::enable_if_t<std::is_unsigned_v<_Tp>> * = nullptr>",
			"        StaticMontgomeryModInt(_Tp __val) { m_val = mg.raw_init(__val % mod()); }",
			"        static mint raw(_FastType __val) {",
			"            mint res;",
			"            res.m_val = __val;",
			"            return res;",
			"        }",
			"        static constexpr _ModType mod() { return _P; }",
			"        _ModType val() const { return mg.reduce(m_val); }",
			"        mint pow(uint64_t __n) const { return raw(mg.pow(m_val, __n)); }",
			"        mint inv() const {",
			"            if constexpr (_IsPrime)",
			"                return inv_Fermat();",
			"            else",
			"                return inv_exgcd();",
			"        }",
			"        mint inv_exgcd() const {",
			"            _ModType x = mod(), y = val(), m0 = 0, m1 = 1;",
			"            while (y) {",
			"                _ModType z = x / y;",
			"                x -= y * z;",
			"                m0 -= m1 * z;",
			"                std::swap(x, y);",
			"                std::swap(m0, m1);",
			"            }",
			"            if (m0 >= mod()) m0 += mod() / x;",
			"            return m0;",
			"        }",
			"        mint inv_Fermat() const { return pow(mod() - 2); }",
			"        mint &operator++() {",
			"            (*this) += raw(mg.raw_init(1));",
			"            return *this;",
			"        }",
			"        mint &operator--() {",
			"            (*this) -= raw(mg.raw_init(1));",
			"            return *this;",
			"        }",
			"        mint operator++(int) {",
			"            mint old(*this);",
			"            ++*this;",
			"            return old;",
			"        }",
			"        mint operator--(int) {",
			"            mint old(*this);",
			"            --*this;",
			"            return old;",
			"        }",
			"        mint &operator+=(const mint &__other) {",
			"            m_val += __other.m_val;",
			"            if (m_val >= mod()) m_val -= mod();",
			"            return *this;",
			"        }",
			"        mint &operator-=(const mint &__other) { return (*this)+=-__other; }",
			"        mint &operator*=(const mint &__other) {",
			"            m_val = mg.multiply(m_val, __other.m_val);",
			"            return *this;",
			"        }",
			"        mint &operator/=(const mint &__other) { return *this *= __other.inv(); }",
			"        mint operator+() const { return *this; }",
			"        mint operator-() const { return raw(m_val ? mod() - m_val : 0); }",
			"        bool operator==(const mint &__other) const { return m_val == __other.m_val; }",
			"        bool operator!=(const mint &__other) const { return m_val != __other.m_val; }",
			"        bool operator<(const mint &__other) const { return m_val < __other.m_val; }",
			"        bool operator>(const mint &__other) const { return m_val > __other.m_val; }",
			"        bool operator<=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        bool operator>=(const mint &__other) const { return m_val <= __other.m_val; }",
			"        template <typename _Tp>",
			"        explicit operator _Tp() const { return _Tp(mg.reduce(m_val)); }",
			"        friend mint operator+(const mint &a, const mint &b) { return mint(a) += b; }",
			"        friend mint operator-(const mint &a, const mint &b) { return mint(a) -= b; }",
			"        friend mint operator*(const mint &a, const mint &b) { return mint(a) *= b; }",
			"        friend mint operator/(const mint &a, const mint &b) { return mint(a) /= b; }",
			"        template <typename _Istream>",
			"        friend _Istream &operator>>(_Istream &is, mint &self) {",
			"            _ModType x;",
			"            is >> x;",
			"            self = mint(x);",
			"            return is;",
			"        }",
			"        template <typename _Ostream>",
			"        friend _Ostream &operator<<(_Ostream &os, const mint &self) { return os << self.val(); }",
			"    };",
			"    template <uint32_t _P, bool _IsPrime>",
			"    using StaticMontgomeryModInt32 = StaticMontgomeryModInt<uint32_t, _P, _IsPrime>;",
			"    template <uint64_t _P, bool _IsPrime>",
			"    using StaticMontgomeryModInt64 = StaticMontgomeryModInt<uint64_t, _P, _IsPrime>;",
			"}",
		],
		"description": "static montgomery modint"
	},


    "operations":{
        "prefix": "OPT",
        "body": [
            "namespace OY{",
			"    struct OpSum{",
			"        template<class T>T operator()(T x,T y){return x+y;}",
			"    };",
			"    struct OpAdd{",
			"        template<class T>T operator()(T x,T y){return x+y;}",
			"    };",
			"    struct OpSet{",
			"        template<class T>T operator()(T x,T y){return y;}",
			"    };",
			"    struct OpMax{",
			"        template<class T>T operator()(T x,T y){return x>y?x:y;}",
			"    };",
			"    struct OpMin{",
			"        template<class T>T operator()(T x,T y){return x<y?x:y;}",
			"    };",
			"    struct MapSum{",
			"        template<class T>T operator()(T x,T y,int n){return x+y*n;}",
			"    };",
			"    struct MapAdd{",
			"        template<class T>T operator()(T x,T y,int n){return x+y;}",
			"    };",
			"    struct MapSet{",
			"        template<class T>T operator()(T x,T y,int n){return y;}",
			"    };",
			"    struct MapMax{",
			"        template<class T>T operator()(T x,T y,int n){return x>y?x:y;}",
			"    };",
			"    struct MapMin{",
			"        template<class T>T operator()(T x,T y,int n){return x<y?x:y;}",
			"    };",
			"    struct OpAddby{",
			"        template<class T>void operator()(T&x,T y){x+=y;}",
			"    };",
			"    struct OpMaxby{",
			"        template<class T>void operator()(T&x,T y){if(x<y)x=y;}",
			"    };",
			"    struct OpMinby{",
			"        template<class T>void operator()(T&x,T y){if(x<y)x=y;}",
			"    };",
			"};",
        ],
        "description": "operations"
    },
	"pat":{
		"prefix": "PAT",
		"body": [
			"#include<bits/stdc++.h>",
			"using namespace std;",
			"//本语句表示启动快速读入，以及在本地时开启文件输入输出",
			"int _IO=[](){ios::sync_with_stdio(0);cin.tie(0); cout.tie(0);",
			"    #ifndef ONLINE_JUDGE",
			"        freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);",
			"    #endif",
			"    return 0;",
			"}();",
			"",
			"//本函数负责处理输入",
			"void input(){",
			"}",
			"",
			"int main(){",
			"    input();",
			"}",
			"",
		],
		"description": "pat"
	},
	"graph":{
		"prefix": "GRAPH",
		"body": [
			"namespace OY{",
			"    #ifdef OY_LOCAL",
			"        #define VNUM 10",
			"        #define ENUM 100",
			"    #else",
			"        #define VNUM 200000",
			"        #define ENUM 500000",
			"    #endif",
			"    struct edge_node_idx{int idx;edge_node_idx()=default;explicit edge_node_idx(int _idx):idx(_idx){}};",
			"    struct edge_node_idx_to{int idx,to;};",
			"    template<typename T>struct edge_node_idx_to_cost{int idx,to;T cost;};",
			"    template<typename T>struct edge_node{int from,to;T cost;};",
			"    template<typename T>struct LinkGraphCore{",
			"        int n,first[VNUM],next[ENUM],from[ENUM],to[ENUM],cnt;T cost[ENUM];",
			"        static LinkGraphCore<T>*LinkGraphCore_ptr;",
			"        struct edge_series_idx{",
			"            int from;",
			"            edge_series_idx(int _from):from(_from){}",
			"            struct edge_iterator_idx{",
			"                int idx;",
			"                edge_iterator_idx()=default;",
			"                edge_iterator_idx(int _idx):idx(_idx){}",
			"                edge_node_idx operator*(){return edge_node_idx(idx);}",
			"                void operator++(){idx=LinkGraphCore_ptr->next[idx];}",
			"                bool operator!=(const edge_iterator_idx&other)const{return idx!=other.idx;}",
			"            };",
			"            edge_iterator_idx begin(){return edge_iterator_idx(LinkGraphCore_ptr->first[from]);}",
			"            edge_iterator_idx end(){return edge_iterator_idx(-1);}",
			"        };",
			"        struct edge_series_idx_to{",
			"            int from;",
			"            edge_series_idx_to(int _from):from(_from){}",
			"            struct edge_iterator_idx_to{",
			"                int idx;",
			"                edge_iterator_idx_to()=default;",
			"                edge_iterator_idx_to(int _idx):idx(_idx){}",
			"                edge_node_idx_to operator*(){return {idx,LinkGraphCore_ptr->to[idx]};}",
			"                void operator++(){idx=LinkGraphCore_ptr->next[idx];}",
			"                bool operator!=(const edge_iterator_idx_to&other)const{return idx!=other.idx;}",
			"            };",
			"            edge_iterator_idx_to begin(){return edge_iterator_idx_to(LinkGraphCore_ptr->first[from]);}",
			"            edge_iterator_idx_to end(){return edge_iterator_idx_to(-1);}",
			"        };",
			"        struct edge_series_idx_to_cost{",
			"            int from;",
			"            edge_series_idx_to_cost(int _from):from(_from){}",
			"            struct edge_iterator_idx_to_cost{",
			"                int idx;",
			"                edge_iterator_idx_to_cost()=default;",
			"                edge_iterator_idx_to_cost(int _idx):idx(_idx){}",
			"                edge_node_idx_to_cost<T>operator*(){return {idx,LinkGraphCore_ptr->to[idx],LinkGraphCore_ptr->cost[idx]};}",
			"                void operator++(){idx=LinkGraphCore_ptr->next[idx];}",
			"                bool operator!=(const edge_iterator_idx_to_cost&other)const{return idx!=other.idx;}",
			"            };",
			"            edge_iterator_idx_to_cost begin(){return edge_iterator_idx_to_cost(LinkGraphCore_ptr->first[from]);}",
			"            edge_iterator_idx_to_cost end(){return edge_iterator_idx_to_cost(-1);}",
			"        };",
			"        void reset(int _n){",
			"            n=_n;cnt=0;",
			"            memset(first,0xff,n*sizeof(int));",
			"        }",
			"        void add(int a,int b){",
			"            next[cnt]=first[a];first[a]=cnt;from[cnt]=a;to[cnt]=b;cnt++;",
			"        }",
			"        void add(int a,int b,T _cost){",
			"            next[cnt]=first[a];first[a]=cnt;from[cnt]=a;to[cnt]=b;cost[cnt]=_cost;cnt++;",
			"        }",
			"        edge_series_idx edges_idx(int _from){LinkGraphCore_ptr=this;return edge_series_idx(_from);}",
			"        edge_series_idx_to edges_idx_to(int _from){LinkGraphCore_ptr=this;return edge_series_idx_to(_from);}",
			"        edge_series_idx_to_cost edges_idx_to_cost(int _from){LinkGraphCore_ptr=this;return edge_series_idx_to_cost(_from);}",
			"        edge_node<T>edge(int idx){return {from[idx],to[idx],cost[idx]};}",
			"        int&edge_from(int idx){return from[idx];}",
			"        int&edge_to(int idx){return to[idx];}",
			"        T&edge_cost(int idx){return cost[idx];}",
			"    };",
			"    template<typename T> LinkGraphCore<T>*LinkGraphCore<T>::LinkGraphCore_ptr=nullptr;",
			"    template<typename T,template<typename U>typename Container=LinkGraphCore,bool directed=0>struct Graph{",
			"        Container<T>graph_core;",
			"        T inf=numeric_limits<T>::max()/3;",
			"        int n,m;static constexpr int stride=directed?1:2;",
			"        virtual void reset(int _n){",
			"            n=_n;m=0;",
			"            graph_core.reset(_n);",
			"        }",
			"        virtual void addEdge(int a,int b){",
			"            m++;",
			"            graph_core.add(a,b);",
			"            if constexpr(directed==0){",
			"                m++;",
			"                graph_core.add(b,a);",
			"            }",
			"        }",
			"        virtual void addEdge(int a,int b,T _cost){",
			"            m++;",
			"            graph_core.add(a,b,_cost);",
			"            if constexpr(directed==0){",
			"                m++;",
			"                graph_core.add(b,a,_cost);",
			"            }",
			"        }",
			"        typename Container<T>::edge_series_idx edges_idx(int _from){return graph_core.edges_idx(_from);}",
			"        typename Container<T>::edge_series_idx_to edges_idx_to(int _from){return graph_core.edges_idx_to(_from);}",
			"        typename Container<T>::edge_series_idx_to_cost edges_idx_to_cost(int _from){return graph_core.edges_idx_to_cost(_from);}",
			"        edge_node<T>edge(int idx){return graph_core.edge(idx);}",
			"        int&edge_from(int idx){return graph_core.edge_from(idx);}",
			"        int&edge_to(int idx){return graph_core.edge_to(idx);}",
			"        T&edge_cost(int idx){return graph_core.edge_cost(idx);}",
			"    };",
			"    template<typename T,template<typename U>typename Container=LinkGraphCore>using UndirectedGraph=Graph<T,Container,false>;",
			"    template<typename T,template<typename U>typename Container=LinkGraphCore>using DirectedGraph=Graph<T,Container,true>;",
			"    template<typename T>bool ckmin(T&a,const T&b){if(a>b){a=b;return true;}else return false;}",
			"    template<typename T>bool ckmax(T&a,const T&b){if(a<b){a=b;return true;}else return false;}",
			"};",
		],
		"description": "graph store"
	},
	"dense graph":{
		"prefix": "DENSEGRAPH",
		"body": [
			"namespace OY{",
			"    struct edge_node_to{int to;};",
			"    template<typename T>struct edge_node_to_cost{int to;T cost;};",
			"    template<typename T>struct MatrixGraphCore{",
			"        int n;",
			"        static MatrixGraphCore<T>*MatrixGraphCore_ptr;",
			"        T cost[VNUM][VNUM],inf=numeric_limits<T>::max()/3;",
			"        struct edge_series_to{",
			"            int n;",
			"            edge_series_to():n(MatrixGraphCore_ptr->n){}",
			"            struct edge_iterator_to{",
			"                int cur;",
			"                edge_iterator_to()=default;",
			"                edge_iterator_to(int _cur):cur(_cur){}",
			"                edge_node_to operator*(){return {cur};}",
			"                void operator++(){cur++;}",
			"                bool operator!=(const edge_iterator_to&other)const{return cur!=other.cur;}",
			"            };",
			"            edge_iterator_to begin(){return edge_iterator_to(0);}",
			"            edge_iterator_to end(){return edge_iterator_to(n);}",
			"        };",
			"        struct edge_series_to_cost{",
			"            T*_begin,*_end;",
			"            edge_series_to_cost(int _from):_begin(MatrixGraphCore_ptr->cost[_from]),_end(MatrixGraphCore_ptr->cost[_from]+MatrixGraphCore_ptr->n){}",
			"            struct edge_iterator_to_cost{",
			"                int to;T*cur;",
			"                edge_iterator_to_cost()=default;",
			"                edge_iterator_to_cost(int _to,T*_cur):to(_to),cur(_cur){}",
			"                edge_node_to_cost<T>operator*(){return {to,*cur};}",
			"                void operator++(){cur++;to++;}",
			"                bool operator!=(const edge_iterator_to_cost&other)const{return cur!=other.cur;}",
			"            };",
			"            edge_iterator_to_cost begin(){return edge_iterator_to_cost(0,_begin);}",
			"            edge_iterator_to_cost end(){return edge_iterator_to_cost(_end-_begin,_end);}",
			"        };",
			"        void reset(int _n,T _val){",
			"            n=_n;",
			"            for(int i=0;i<n;i++)for(int j=0;j<n;j++)cost[i][j]=_val;",
			"        }",
			"        void add(int a,int b){",
			"            cost[a][b]+=1;",
			"        }",
			"        void set(int a,int b){",
			"            cost[a][b]=1;",
			"        }",
			"        void add(int a,int b,T _cost){",
			"            cost[a][b]+=_cost;",
			"        }",
			"        void set(int a,int b,T _cost){",
			"            cost[a][b]=_cost;",
			"        }",
			"        edge_series_to edges_to(int _from){MatrixGraphCore_ptr=this;return edge_series_to();}",
			"        edge_series_to_cost edges_to_cost(int _from){MatrixGraphCore_ptr=this;return edge_series_to_cost(_from);}",
			"        T&edge_cost(int a,int b){return cost[a][b];}",
			"    };",
			"    template<typename T> MatrixGraphCore<T>*MatrixGraphCore<T>::MatrixGraphCore_ptr=nullptr;",
			"    template<typename T,template<typename U>typename Container=MatrixGraphCore,bool directed=0>struct DenseGraph{",
			"        Container<T>graph_core;",
			"        T&inf=graph_core.inf;",
			"        int n;",
			"        virtual void reset(int _n,T _val=numeric_limits<T>::max()/3){",
			"            n=_n;",
			"            graph_core.reset(_n,_val);",
			"        }",
			"        virtual void addEdge(int a,int b){",
			"            graph_core.add(a,b);",
			"            if constexpr(directed==0)graph_core.add(b,a);",
			"        }",
			"        virtual void setEdge(int a,int b){",
			"            graph_core.set(a,b);",
			"            if constexpr(directed==0)graph_core.set(b,a);",
			"        }",
			"        virtual void addEdge(int a,int b,T _cost){",
			"            graph_core.add(a,b,_cost);",
			"            if constexpr(directed==0)graph_core.add(b,a,_cost);",
			"        }",
			"        virtual void setEdge(int a,int b,T _cost){",
			"            graph_core.set(a,b,_cost);",
			"            if constexpr(directed==0)graph_core.set(b,a,_cost);",
			"        }",
			"        typename Container<T>::edge_series_to edges_to(int _from){return graph_core.edges_to(_from);}",
			"        typename Container<T>::edge_series_to_cost edges_to_cost(int _from){return graph_core.edges_to_cost(_from);}",
			"        T&edge_cost(int a,int b){return graph_core.edge_cost(a,b);}",
			"    };",
			"    template<typename T,template<typename U>typename Container=MatrixGraphCore>using UndirectedDenseGraph=DenseGraph<T,Container,false>;",
			"    template<typename T,template<typename U>typename Container=MatrixGraphCore>using DirectedDenseGraph=DenseGraph<T,Container,true>;",
			"    template<typename T,template<typename U>typename Container=MatrixGraphCore>struct FlowDenseNetwork:DirectedDenseGraph<T,Container>{",
			"        using BASE=DirectedDenseGraph<T,Container>;using BASE::graph_core,BASE::n;",
			"        virtual void reset(int _n){",
			"            n=_n;",
			"            graph_core.reset(_n,0);",
			"        }",
			"        virtual void addEdge(int a,int b,T _cost){",
			"            graph_core.add(a,b,_cost),graph_core.add(b,a,0);",
			"        }",
			"    };    ",
			"};",
		],
		"description": "dense graph store"
	},
	"flow network":{
		"prefix": "FLOW",
		"body": [
			"namespace OY{",
			"    template<typename T,typename F>struct cost_flow{T cost;F flow;cost_flow operator/(int d)const{return {cost,flow};}};",
			"    template<typename T,template<typename U>typename Container=LinkGraphCore>struct FlowNetwork:DirectedGraph<T,Container>{",
			"        using BASE=DirectedGraph<T,Container>;using BASE::graph_core,BASE::m;",
			"        virtual void addEdge(int a,int b,T _cost){",
			"            graph_core.add(a,b,_cost),graph_core.add(b,a,0);m+=2;",
			"        }",
			"    };",
			"    template<typename T,typename F,template<typename U>typename Container=LinkGraphCore>struct CostFlowNetwork:DirectedGraph<cost_flow<T,F>,Container>{",
			"        using BASE=DirectedGraph<cost_flow<T,F>,Container>;using BASE::graph_core,BASE::m;",
			"        T T_inf=numeric_limits<T>::max()/3;F F_inf=numeric_limits<F>::max()/3;",
			"        virtual void addEdge(int a,int b,T _cost,F _flow){",
			"            graph_core.add(a,b,{_cost,_flow}),graph_core.add(b,a,{-_cost,0}),m+=2;",
			"        }",
			"        typename Container<cost_flow<T,F>>::edge_series_idx_to_cost edges_idx_to_cost_flow(int _from){return graph_core.edges_idx_to_cost(_from);}",
			"        cost_flow<T,F>&edge_cost_flow(int idx){return graph_core.edge_cost(idx);}",
			"    };",
			"    template<typename T,template<typename U>typename Container=LinkGraphCore>struct BoundFlowNetwork:FlowNetwork<T,Container>{",
			"        using BASE=FlowNetwork<T,Container>;using BASE::addEdge,BASE::m;",
			"        T sum[VNUM],low[ENUM];",
			"        virtual void reset(int n){BASE::reset(n+2);fill(sum,sum+n,0);}",
			"        virtual void addBound(int a,int b,T _low,T _high){",
			"            sum[a]-=_low,sum[b]+=_low;low[m]=_low;addEdge(a,b,_high-_low);",
			"        }",
			"    };",
			"};",
		],
		"description": "flow network"
	},
	"dijkstra":{
		"prefix": "DIJK",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container,bool directed>vector<T>dijkstra_heap(Graph<T,Container,directed>&G,int source){",
			"        vector<T>dist(G.n,G.inf);",
			"        struct node{",
			"            T d;int i;",
			"            node(T _d,int _i):d(_d),i(_i){}",
			"            bool operator<(const node&other)const{return d>other.d;}",
			"        };static priority_queue<node>Q;",
			"        for(Q.emplace(dist[source]=0,source);Q.size();){",
			"            auto [curd,cur]=Q.top();Q.pop();",
			"            if(curd==dist[cur])for(auto [_,to,cost]:G.edges_idx_to_cost(cur))if(ckmin(dist[to],curd+cost))Q.emplace(dist[to],to);",
			"        }",
			"        return dist;",
			"    }",
			"};",
		],
		"description": "dijkstra"
	},
	"spfa":{
		"prefix": "SPFA",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container,bool directed>vector<T>spfa(Graph<T,Container,directed>&G,int source){",
			"        vector<T>dist(G.n,G.inf);",
			"        queue<int>q;",
			"        vector<bool>inq(G.n,false);",
			"        dist[source]=0,q.push(source),inq[source]=true;",
			"        for(int i=0;i<G.n&&q.size();i++)for(int l=q.size();l--;){",
			"            int p=q.front();q.pop();inq[p]=false;",
			"            for(auto [_,to,cost]:G.edges_idx_to_cost(p))if(ckmin(dist[to],dist[p]+cost)&&!inq[to])q.push(to),inq[to]=true;",
			"        }",
			"        return q.size()?vector<T>():dist;",
			"    }",
			"};",
		],
		"description": "bellman_ford and spfa"
	},
	"floyd":{
		"prefix": "FLOYD",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container,bool directed>vector<vector<T>>floyd(Graph<T,Container,directed>&G){",
			"        vector<vector<T>>dist(G.n,vector<T>(G.n,G.inf));",
			"        for(int i=0;i<G.n;i++)for(auto [_,to,cost]:G.edges_idx_to_cost(i))ckmin(dist[i][to],cost);",
			"        for(int k=0;k<G.n;k++)for(int i=0;i<G.n;i++)for(int j=0;j<G.n;j++)ckmin(dist[i][j],dist[i][k]+dist[k][j]);",
			"        return dist;",
			"    }",
			"};",
		],
		"description": "floyd"
	},
	"bfs":{
		"prefix": "BFS",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container,bool directed>vector<T>BFS(Graph<T,Container,directed>&G,int source){",
			"        static int Q[VNUM];",
			"        vector<T>dist(G.n,G.inf);dist[Q[0]=source]=0;",
			"        for(int h=0,t=1;h<t;){",
			"            int cur=Q[h++];T curd=dist[cur];",
			"            for(auto [_,to]:G.edges_idx_to(cur))if(ckmin(dist[to],curd+1))Q[t++]=to;",
			"        }",
			"        return dist;",
			"    }",
			"};",
		],
		"description": "bfs"
	},
	"topological sort":{
		"prefix": "TOPO",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container>vector<int>topoSort(DirectedGraph<T,Container>&G){",
			"        static int indeg[VNUM],Q[VNUM];",
			"        memset(indeg,0,G.n*sizeof(int));",
			"        for(int i=0;i<G.n;i++)for(auto [_,to]:G.edges_idx_to(i))indeg[to]++;",
			"        int h=0,t=0;",
			"        for(int i=0;i<G.n;i++)if(!indeg[i])Q[t++]=i;",
			"        while(h<t)for(auto [_,to]:G.edges_idx_to(Q[h++]))if(!--indeg[to])Q[t++]=to;",
			"        return vector<int>(Q,Q+t);",
			"    }",
			"};",
		],
		"description": "topological sort"
	},
	"minimum spanning tree":{
		"prefix": "MST",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container,bool directed>vector<int>kruskal(Graph<T,Container,directed>&G){",
			"        struct edge{",
			"            int idx,from,to;T cost;",
			"        };static edge e[ENUM];int m=0;",
			"        for(int idx=0;idx<G.m;idx+=G.stride){",
			"            auto [from,to,cost]=G.edge(idx);",
			"            e[m++]={idx,from,to,cost};",
			"        }",
			"        sort(e,e+m,[&](auto&x,auto&y){return x.cost<y.cost;});",
			"        static int find[VNUM];iota(find,find+G.n,0);",
			"        function<int(int)>Find=[&](int i){return find[i]==i?i:(find[i]=Find(find[i]));};",
			"        vector<int>ans;ans.reserve(G.n-1);",
			"        for(int i=0;i<m;i++){",
			"            int a=Find(e[i].from),b=Find(e[i].to);",
			"            if(a!=b)find[a]=b,ans.push_back(e[i].idx);",
			"        }",
			"        return ans;",
			"    }",
			"    template<typename T,template<typename U>typename Container>vector<T>prim(UndirectedDenseGraph<T,Container>&G){",
			"        vector<bool>visit(G.n,false);",
			"        static T dist[VNUM];fill(dist,dist+G.n,G.inf);",
			"        visit[0]=true,dist[0]=G.inf;for(auto [to,cost]:G.edges_to_cost(0))if(!visit[to])ckmin(dist[to],cost);",
			"        vector<T>ans;ans.reserve(G.n-1);",
			"        while(true){",
			"            int cur=min_element(dist,dist+G.n)-dist;",
			"            if(dist[cur]==G.inf)break;T curd=dist[cur];",
			"            ans.push_back(curd);",
			"            visit[cur]=true,dist[cur]=G.inf;",
			"            for(auto [to,cost]:G.edges_to_cost(cur))if(!visit[to])ckmin(dist[to],cost);",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
		"description": "minimum spanning tree"
	},
	"steiner tree":{
		"prefix": "STEINER",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container>T steiner_cost(UndirectedGraph<T,Container>&G,vector<int>&keys){",
			"        int k=keys.size();",
			"        T dp[1<<k][G.n];fill(dp[0],dp[1],0),fill(dp[1],dp[1<<k],G.inf);",
			"        for(int i=0;i<k;i++)dp[1<<i][keys[i]]=0;",
			"        for(int state=1;state<1<<k;state++){",
			"            for(int sub=state;sub>=state-sub;sub=(sub-1)&state)for(int i=0;i<G.n;i++)ckmin(dp[state][i],dp[sub][i]+dp[state-sub][i]);",
			"            static queue<int>q;vector<bool>inq(G.n,false);",
			"            for(int i=0;i<G.n;i++)q.push(i),inq[i]=true;",
			"            while(q.size()){",
			"                int p=q.front();q.pop();inq[p]=false;",
			"                for(auto [_,to,cost]:G.edges_idx_to_cost(p))if(ckmin(dp[state][to],dp[state][p]+cost)&&!inq[to])q.push(to),inq[to]=true;",
			"            }",
			"        }",
			"        return *min_element(dp[(1<<k)-1],dp[1<<k]);",
			"    }",
			"};",
		],
		"description": "steiner tree"
	},
	"johnson":{
		"prefix": "JOHNSON",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container>vector<vector<T>>johnson(DirectedGraph<T,Container>&G){",
			"        vector<T>H(G.n,0);",
			"        static queue<int>q;vector<bool>inq(G.n,true);for(int i=0;i<G.n;i++)q.push(i),inq[i]=true;",
			"        for(int i=0;i<G.n&&q.size();i++)for(int l=q.size();l--;){",
			"            int p=q.front();q.pop();inq[p]=false;",
			"            for(auto [_,to,cost]:G.edges_idx_to_cost(p))if(ckmin(H[to],H[p]+cost)&&!inq[to])q.push(to),inq[to]=true;",
			"        }",
			"        if(q.size())return {};",
			"        vector<vector<T>>ans(G.n,vector<T>(G.n,G.inf));",
			"        for(int i=0;i<G.n;i++){",
			"            vector<T>&dist=ans[i];",
			"            struct node{",
			"                int i;T cost;",
			"                node(int _i,T _cost):i(_i),cost(_cost){}",
			"                bool operator<(const node&other)const{return cost>other.cost;}",
			"            };static priority_queue<node>Q;",
			"            for(Q.emplace(i,dist[i]=0);Q.size();){",
			"                auto [cur,curd]=Q.top();Q.pop();",
			"                if(curd==dist[cur])for(auto [_,to,cost]:G.edges_idx_to_cost(cur))if(ckmin(dist[to],curd+cost+H[cur]-H[to]))Q.emplace(to,dist[to]);",
			"            }",
			"            for(int j=0;j<G.n;j++)if(dist[j]!=G.inf)dist[j]+=H[j]-H[i];",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
		"description": "johnson"
	},
	"Edmonds":{
		"prefix": "EDMONDS",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container>T edmonds_cost(DirectedGraph<T,Container>&G,int root){",
			"        int m=G.m,n=G.n;static edge_node<T>e[ENUM];",
			"        for(int i=0;i<m;i++)e[i]=G.edge(i);",
			"        T in[n],ans=0;int from[n],id[n],visit[n];",
			"        while(true){",
			"            fill(in,in+n,G.inf);memset(id,0xff,n*sizeof(int)),memset(visit,0xff,n*sizeof(int));",
			"            for(int i=0;i<m;i++)if(ckmin(in[e[i].to],e[i].cost))from[e[i].to]=e[i].from;",
			"            int loop=0;visit[root]=root;",
			"            for(int i=0;i<n;i++)if(i!=root){",
			"                if(in[i]==G.inf)return {};",
			"                ans+=in[i];int cur=i;",
			"                while(~cur&&!~visit[cur])visit[cur]=i,cur=from[cur];",
			"                if(~cur&&visit[cur]==i){for(int x=cur;!~id[x];x=from[x])id[x]=loop;loop++;}",
			"            }",
			"            if(!loop)break;",
			"            for(int i=0;i<n;i++)if(!~id[i])id[i]=loop++;",
			"            int mm=0;",
			"            for(int i=0;i<m;i++){",
			"                auto [from,to,cost]=e[i];if(id[from]==id[to])continue;",
			"                e[mm++]={id[from],id[to],cost-in[to]};",
			"            }",
			"            m=mm,n=loop,root=id[root];",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
		"description": "edmonds"
	},
	"tarjan scc":{
		"prefix": "SCC",
		"body": [
			"namespace OY{",
			"    struct SCCBase{",
			"        int id[VNUM],n,group_num;",
			"        vector<vector<int>>groups(){",
			"            static int cnt[VNUM];",
			"            memset(cnt,0,group_num*sizeof(int));",
			"            for(int i=0;i<n;i++)cnt[id[i]]++;",
			"            vector<vector<int>>ans(group_num);",
			"            for(int i=0;i<group_num;i++)ans[i].reserve(cnt[i]);",
			"            for(int i=0;i<n;i++)ans[id[i]].push_back(i);",
			"            return ans;",
			"        }",
			"    };",
			"    struct Tarjan:SCCBase{",
			"        using SCCBase::n,SCCBase::id,SCCBase::group_num;",
			"        template<typename T,template<typename U>typename Container>void solve(DirectedGraph<T,Container>&G){",
			"            static int dfn[VNUM],low[VNUM],s[VNUM],dfncnt,cnt,l;",
			"            function<int(int)>dfs=[&](int cur){",
			"                low[cur]=dfn[cur]=dfncnt++,s[l++]=cur;",
			"                for(auto [_,to]:G.edges_idx_to(cur)){",
			"                    if(!~dfn[to])low[cur]=min(low[cur],dfs(to));",
			"                    else if(!~id[to])low[cur]=min(low[cur],dfn[to]);",
			"                }",
			"                if(dfn[cur]==low[cur]){while(s[--l]!=cur)id[s[l]]=cnt;id[cur]=cnt++;}",
			"                return low[cur];",
			"            };",
			"            n=G.n;memset(id,0xff,n*sizeof(int)),memset(dfn,0xff,n*sizeof(int)),memset(low,0xff,n*sizeof(int)),dfncnt=cnt=l=0;",
			"            for(int i=0;i<n;i++)if(!~dfn[i])dfs(i);",
			"            for(int i=0;i<n;i++)id[i]=cnt-1-id[i];",
			"            group_num=cnt;",
			"        }",
			"    };",
			"};",
		],
		"description": "tarjan scc"
	},
	"shrink point":{
		"prefix": "SHRINK",
		"body": [
			"namespace OY{",
			"    template<typename Base=Tarjan>struct ShrinkPoint:Base{",
			"        using Base::solve,Base::n,Base::id;",
			"        template<typename T,template<typename U>typename Container>DirectedGraph<T,Container>shrink(DirectedGraph<T,Container>&G){",
			"            solve(G);DirectedGraph<T,Container>ans;ans.reset(n);",
			"            for(int i=0;i<G.m;i++){",
			"                auto [from,to,_]=G.edge(i);",
			"                ans.addEdge(id[from],id[to]);",
			"            }",
			"            return ans;",
			"        };",
			"    };",
			"};"
		],
		"description": "shrink point"
	},
	"tarjan cut and bridge":{
		"prefix": "TARJAN",
		"body": [
			"namespace OY{",
			"    struct TarjanHelper{",
			"        int dfn[VNUM],low[VNUM],dfncnt;",
			"        vector<bool>_iscut;",
			"        function<bool(int)>iscut,isbridge;",
			"        function<bool(int,int)>is_bridge;",
			"        function<vector<int>()>cuts,bridges;",
			"        template<typename T,template<typename U>typename Container>void reset(UndirectedGraph<T,Container>&G){",
			"            int n=G.n;dfncnt=0;",
			"            memset(dfn,0xff,n*sizeof(int)),memset(low,0xff,n*sizeof(int));",
			"            _iscut.assign(n,false);",
			"            function<void(int,int)>dfs=[&](int cur,int from){",
			"                low[cur]=dfn[cur]=dfncnt++;",
			"                for(auto [idx,to]:G.edges_idx_to(cur))if(idx!=(from^1)){",
			"                    if(!~dfn[to]){",
			"                        dfs(to,idx);",
			"                        if(low[to]<dfn[cur])low[cur]=min(low[cur],low[to]);",
			"                        else if(~from)_iscut[cur]=true;else from--;",
			"                    }",
			"                    else if(dfn[to]<dfn[cur])low[cur]=min(low[cur],dfn[to]);",
			"                }",
			"            };",
			"            for(int i=0;i<n;i++)if(!~dfn[i])dfs(i,-1);",
			"            iscut=[&](int i){return _iscut[i];};",
			"            isbridge=[&](int idx){",
			"                auto [from,to,_]=G.edge(idx);",
			"                return low[from]>dfn[to]||low[from]>dfn[to];",
			"            };",
			"            is_bridge=[&](int from,int to){",
			"                return low[from]>dfn[to]||low[from]>dfn[to];",
			"            };",
			"            cuts=[&](){",
			"                vector<int>ans;ans.reserve(count(_iscut.begin(),_iscut.end(),true));",
			"                for(int i=0;i<G.n;i++)if(_iscut[i])ans.push_back(i);",
			"                return ans;",
			"            };",
			"            bridges=[&](){",
			"                vector<int>ans;",
			"                for(int i=0;i<G.m;i+=2)if(isbridge(i))ans.push_back(i);",
			"                return ans;",
			"            };",
			"        }",
			"    };",
			"};",
		],
		"description": "tarjan cut and bridge"
	},
	"two sat":{
		"prefix": "TWOSAT",
		"body": [
			"namespace OY{",
			"    struct twosat{",
			"        DirectedGraph<int,LinkGraphCore>G;",
			"        vector<bool>choose;",
			"        void reset(int n){",
			"            G.reset(n*2);",
			"        }",
			"        void add_clause(int a,bool a_val,int b,bool b_val){",
			"            G.addEdge(a*2+(a_val?0:1),b*2+(b_val?1:0));",
			"            G.addEdge(b*2+(b_val?0:1),a*2+(a_val?1:0));",
			"        }",
			"        bool check(){",
			"            static SccHelper<Tarjan>sh;sh.reset(G);",
			"            auto id=sh.id;",
			"            choose.reserve(G.n/2);",
			"            for(int i=0;i<G.n;i+=2){",
			"                if(id[i]==id[i+1])return false;",
			"                choose.push_back(id[i]<id[i+1]);",
			"            }",
			"            return true;",
			"        }",
			"    };",
			"};"
		],
		"description": "two sat based on tarjan"
	},
	"euler path":{
		"prefix": "EULER",
		"body": [
			"namespace OY{",
			"    struct EulerPath{",
			"        int deg[VNUM];",
			"        function<bool()>isEuler,isHalfEuler;",
			"        function<vector<int>(int)>vertices,edges;",
			"        template<typename T,template<typename U>typename Container,bool directed>void reset(Graph<T,Container,directed>&G){",
			"            memset(deg,0,G.n*sizeof(int));",
			"            for(int i=0;i<G.m;i+=G.stride){",
			"                auto [from,to,_]=G.edge(i);",
			"                if constexpr(directed){deg[from]--;deg[to]++;}",
			"                else{deg[from]^=1;deg[to]^=1;}",
			"            }",
			"            isEuler=[&](){",
			"                if(count(deg,deg+G.n,0)!=G.n)return false;",
			"                static int q[VNUM];int h=0,t=0;q[t++]=0;",
			"                vector<bool>visit(G.n,false);visit[0]=true;",
			"                while(h<t)for(auto [idx,to]:G.edges_idx_to(q[h++]))if(!visit[to])q[t++]=to,visit[to]=true;",
			"                return t==G.n;",
			"            };",
			"            isHalfEuler=[&](){",
			"                if(count(deg,deg+G.n,0)<G.n-2)return false;",
			"                int only_source=min_element(deg,deg+G.n)-deg;",
			"                if(deg[only_source]<-1)return false;",
			"                static int q[VNUM];int h=0,t=0;q[t++]=only_source;",
			"                vector<bool>visit(G.n,false);visit[only_source]=true;",
			"                while(h<t)for(auto [idx,to]:G.edges_idx_to(q[h++]))if(!visit[to])q[t++]=to,visit[to]=true;",
			"                return t==G.n;",
			"            };",
			"            function<vector<int>(int,bool)>solve=[&](int source,bool get_edge){",
			"                vector<int>ans;ans.reserve(get_edge?G.m/G.stride:G.m/G.stride+1);",
			"                using iiterator=typename Container<T>::edge_series_idx_to::edge_iterator_idx_to;",
			"                vector<iiterator>its,ends;its.reserve(G.n);ends.reserve(G.n);",
			"                for(int i=0;i<G.n;i++)its.push_back(G.edges_idx_to(i).begin()),ends.push_back(G.edges_idx_to(i).end());",
			"                vector<bool>used;if constexpr(directed==0)used.assign(G.m/G.stride,false);",
			"                function<void(int,int)>dfs=[&](int cur,int from){",
			"                    while(its[cur]!=ends[cur]){",
			"                        auto [idx,to]=*its[cur];",
			"                        ++its[cur];",
			"                        if constexpr(directed)dfs(to,idx);",
			"                        else if(!used[idx/G.stride]){",
			"                            used[idx/G.stride]=true;",
			"                            dfs(to,idx);",
			"                        }",
			"                    }",
			"                    if(!get_edge)ans.push_back(cur);",
			"                    else if(~from)ans.push_back(from);",
			"                };",
			"                dfs(source,-1);",
			"                reverse(ans.begin(),ans.end());",
			"                return ans;",
			"            };",
			"            vertices=bind(solve,placeholders::_1,false);edges=bind(solve,placeholders::_1,true);",
			"        }",
			"    };",
			"};",
		],
		"description": "euler path",
	},
	"bipartite":{
		"prefix": "BIPARTITE",
		"body": [
			"namespace OY{",
			"    struct Hungary{",
			"        int left_match[VNUM],right_match[VNUM];",
			"        template<typename T,template<typename U>typename Container>int max_match(DirectedDenseGraph<T,Container>&G){",
			"            static int tag[VNUM],from[VNUM],q[VNUM];int ans=0;",
			"            memset(left_match,0xff,G.n*sizeof(int)),memset(right_match,0xff,G.n*sizeof(int)),memset(tag,0xff,G.n*sizeof(int));",
			"            for(int i=0;i<G.n;i++)if(!~left_match[i]){",
			"                int h=0,t=0;",
			"                auto push=[&](int x,int _from){q[t++]=x,from[x]=_from;};push(i,-1);",
			"                for(bool flag=false;h<t&&!flag;){",
			"                    int p=q[h++];",
			"                    for(auto [to,cost]:G.edges_to_cost(p))if(cost&&tag[to]!=i){",
			"                        tag[to]=i;",
			"                        if(~right_match[to])push(right_match[to],p);",
			"                        else{",
			"                            while(~to){int old=left_match[p];left_match[p]=to,right_match[to]=p;to=old,p=from[p];}",
			"                            flag=true;ans++;break;",
			"                        }",
			"                    }",
			"                }",
			"            }",
			"            return ans;",
			"        }",
			"        template<typename T,template<typename U>typename Container>T max_weight_match(DirectedDenseGraph<T,Container>&G){",
			"            static T left_l[VNUM],right_l[VNUM],slack[VNUM];T ans=0;",
			"            static int from[VNUM];",
			"            static bitset<VNUM>left_visit,right_visit;",
			"            auto aug=[&](int v){while(~v){int u=from[v],vv=left_match[u];right_match[v]=u,left_match[u]=v;v=vv;}};",
			"            auto bfs=[&](int i){",
			"                left_visit.reset();right_visit.reset();",
			"                fill(slack,slack+G.n,G.inf);",
			"                static int q[VNUM];int h=0,t=0;",
			"                auto push=[&](int x){q[t++]=x,left_visit.set(x);};push(i);",
			"                while(true){",
			"                    while(h<t){",
			"                        int p=q[h++];",
			"                        for(int i=0;i<G.n;i++)if(!right_visit[i]&&ckmin(slack[i],left_l[p]+right_l[i]-G.edge_cost(p,i))){",
			"                            from[i]=p;",
			"                            if(!slack[i])if(~right_match[i])right_visit.set(i),push(right_match[i]);",
			"                            else{aug(i);return;}",
			"                        }",
			"                    }",
			"                    T d=G.inf;",
			"                    for(int i=0;i<G.n;i++)if(!right_visit[i])ckmin(d,slack[i]);",
			"                    for(int i=0;i<G.n;++i)if(left_visit[i])left_l[i]-=d;",
			"                    for(int i=0;i<G.n;++i)if(right_visit[i])right_l[i]+=d;else slack[i]-=d;",
			"                    for(int i=0;i<G.n;++i)if(!right_visit[i]&&!slack[i])",
			"                        if(~right_match[i])right_visit.set(i),push(right_match[i]);",
			"                        else{aug(i);return;}",
			"                }",
			"            };",
			"            fill(left_l,left_l+G.n,0),fill(right_l,right_l+G.n,0);",
			"            memset(left_match,0xff,G.n*sizeof(int)),memset(right_match,0xff,G.n*sizeof(int));",
			"            for(int i=0;i<G.n;i++)for(int j=0;j<G.n;j++)ckmax(left_l[i],G.edge_cost(i,j));",
			"            for(int i=0;i<G.n;i++)bfs(i);",
			"            for(int i=0;i<G.n;i++)ans+=G.edge_cost(i,left_match[i]);",
			"            return ans;",
			"        }",
			"    };",
			"};",
		],
		"description": "bipartite"
	},
	"min cycle":{
		"prefix": "MINCYCLE",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container,bool directed>T floyd_min_circle_cost(DenseGraph<T,Container,directed>&G){",
			"        static T dist[VNUM][VNUM];T ans=G.inf;",
			"        for(int i=0;i<G.n;i++)for(int j=0;j<G.n;j++)dist[i][j]=G.edge_cost(i,j);",
			"        for(int k=0;k<G.n;k++){",
			"            for(int i=0;i<k;i++)for(int j=0;j<i;j++)ckmin(ans,dist[i][j]+min(G.inf,G.edge_cost(j,k)+G.edge_cost(k,i)));",
			"            for(int i=0;i<G.n;i++)for(int j=0;j<G.n;j++)ckmin(dist[i][j],dist[i][k]+dist[k][j]);",
			"        }",
			"        return ans;",
			"    }",
			"};"
		],
		"description": "min cycle"
	},
	"max flow":{
		"prefix": "MAXFLOW",
		"body": [
			"namespace OY{",
			"    template<typename T>struct HLPP_mf{",
			"        static constexpr int relabel_work=4;",
			"        T w[ENUM],ex[VNUM];",
			"        int gapNxt[VNUM],gapPrv[VNUM],gapFi[VNUM],height[VNUM],exFi[VNUM],exNxt[VNUM],q[VNUM],highest,highestGap,work;",
			"        template<template<typename U>typename Container>T maxflow(FlowNetwork<T,Container>&G,int source,int target,bool copy=true){",
			"            int thresh=relabel_work*G.n;",
			"            if(copy)for(int i=0;i<G.m;i++)w[i]=G.edge_cost(i);",
			"            using iiterator=typename Container<T>::edge_series_idx_to::edge_iterator_idx_to;",
			"            static iiterator its[VNUM],ends[VNUM];",
			"            for(int i=0;i<G.n;i++)its[i]=G.edges_idx_to(i).begin(),ends[i]=G.edges_idx_to(i).end();",
			"            auto updHeight=[&](int i,int nh){",
			"                if(height[i]<G.n)if(gapFi[height[i]]==i)gapFi[height[i]]=gapNxt[i];",
			"                else{if(~gapNxt[i])gapPrv[gapNxt[i]]=gapPrv[i];gapNxt[gapPrv[i]]=gapNxt[i];}",
			"                if((height[i]=nh)==G.n)return;",
			"                ckmax(highestGap,nh);",
			"                if(ex[i])ckmax(highest,nh),exNxt[i]=exFi[nh],exFi[nh]=i;",
			"                if(~gapFi[nh])gapPrv[gapFi[nh]]=i;gapNxt[i]=gapFi[nh],gapFi[nh]=i;",
			"            };",
			"            auto globalRelabel=[&](){",
			"                work=0;",
			"                iota(gapNxt,gapNxt+G.n,0);iota(gapPrv,gapPrv+G.n,0);",
			"                memset(gapFi,0xff,G.n*sizeof(int));memset(exFi,0xff,G.n*sizeof(int));",
			"                fill(height,height+G.n,G.n);",
			"                int h=0,t=0;height[target]=0,q[t++]=target;",
			"                while(h<t){",
			"                    int p=q[h++];",
			"                    for(auto [idx,to]:G.edges_idx_to(p))if(height[to]==G.n&&w[idx^1])updHeight(to,height[p]+1),q[t++]=to;",
			"                }",
			"                highest=highestGap=height[q[t-1]];",
			"            };",
			"            auto push=[&](int i,int idx,int to){",
			"                if(T f=min(ex[i],w[idx])){",
			"                    if(!ex[to])exNxt[to]=exFi[height[to]],exFi[height[to]]=to;",
			"                    w[idx]-=f,w[idx^1]+=f,ex[i]-=f,ex[to]+=f;",
			"                }",
			"            };",
			"            auto discharge=[&](int v){",
			"                int nh=G.n;",
			"                for(auto it=its[v];it!=ends[v];++it) {",
			"                    auto [idx,to]=*it;",
			"                    if(w[idx])if(height[v]==height[to]+1){push(v,idx,to);if(!ex[v]){its[v]=it;return;}}",
			"                    else ckmin(nh,height[to]+1);",
			"                }",
			"                for(auto it=G.edges_idx_to(v).begin();it!=its[v];++it){",
			"                    auto [idx,to]=*it;",
			"                    if(w[idx])if(height[v]==height[to]+1){push(v,idx,to);if(!ex[v]){its[v]=it;return;}}",
			"                    else ckmin(nh,height[to]+1);",
			"                }",
			"                work++;",
			"                if(~gapNxt[gapFi[height[v]]])updHeight(v,nh);",
			"                else for(int&h=highestGap;h>=height[v];h--)for(int&i=gapFi[h];~i;i=gapNxt[i])height[i]=G.n;",
			"            };",
			"            fill(ex,ex+G.n,0);ex[source]=G.inf,ex[target]=-G.inf;",
			"            globalRelabel();",
			"            for(auto [idx,to]:G.edges_idx_to(source))push(source,idx,to);",
			"            for(;~highest;highest--)for(;~exFi[highest];){",
			"                int v=exFi[highest];exFi[highest]=exNxt[v];",
			"                discharge(v);",
			"                if(work>thresh)globalRelabel();",
			"            }",
			"            return ex[target]+G.inf;",
			"        }",
			"    };",
			"};",
		],
		"description": "maxflow"
	},
	"min cost max flow":{
		"prefix": "MINCOSTMAXFLOW",
		"body": [
			"namespace OY{",
			"    template<typename T,typename F>struct HLPP_mcmf{",
			"        cost_flow<T,F>W[ENUM];",
			"        T phi[VNUM];",
			"        F ex[VNUM];",
			"        int sta[VNUM],stalen=0;",
			"        static constexpr int SCALE=8;",
			"        template<template<typename U>typename Container>pair<T,F>getMaxFlowMinCost(CostFlowNetwork<T,F,Container>&G,int source,int target){",
			"            T cost=0,neg=0,bnd=0,mul=32-std::__countl_zero(G.n);",
			"            F flow;",
			"            for(int i=0;i<G.m;i++){",
			"                auto [from,to,cf]=G.edge(i);",
			"                if(from!=to)W[i]=cf;",
			"                else if(cf.cost<0)neg+=cf.cost*cf.flow,W[i]={0,0};",
			"            }",
			"            auto getMaxFlow=[&](){",
			"                static int height[VNUM],highest,exFi[VNUM*2],exNxt[VNUM],cnt[VNUM*2];",
			"                using iiterator=typename Container<cost_flow<T,F>>::edge_series_idx_to::edge_iterator_idx_to;",
			"                static iiterator its[VNUM],ends[VNUM];",
			"                for(int i=0;i<G.n;i++)its[i]=G.edges_idx_to(i).begin(),ends[i]=G.edges_idx_to(i).end();",
			"                auto push=[&](int v,int idx,int to){",
			"                    if(F f=min(ex[v],W[idx].flow)){",
			"                        if(!ex[to])exNxt[to]=exFi[height[to]],exFi[height[to]]=to;",
			"                        W[idx].flow-=f,W[idx^1].flow+=f,ex[v]-=f,ex[to]+=f;",
			"                    }",
			"                };",
			"                auto discharge=[&](int v){",
			"                    while(true){",
			"                        for(auto&it=its[v];it!=ends[v];++it){",
			"                            auto [idx,to]=*its[v];",
			"                            if(W[idx].flow&&height[v]==height[to]+1){push(v,idx,to);if(!ex[v])break;}",
			"                        }",
			"                        if(!ex[v])break;",
			"                        height[v]=0x3f3f3f3f;",
			"                        for(auto it=G.edges_idx_to(v).begin();it!=ends[v];++it){",
			"                            auto [idx,to]=*it;",
			"                            if(W[idx].flow&&ckmin(height[v],height[to]+1))its[v]=it;",
			"                        }",
			"                        ++cnt[height[v]];",
			"                        if(!--cnt[highest]&&highest<G.n)",
			"                            for(int i=0;i<G.n;i++)if(height[i]>highest&&height[i]<G.n){",
			"                                cnt[height[i]]--,height[i]=G.n+1,cnt[height[i]]++;",
			"                            }",
			"                        highest=height[v];",
			"                    }",
			"                };",
			"                fill(height,height+G.n,0);height[source]=G.n;",
			"                cnt[0]=G.n-1,cnt[G.n]=1;",
			"                fill(ex,ex+G.n,0);ex[source]=G.T_inf,ex[target]=-G.T_inf;",
			"                memset(exFi,0xff,G.n*2*sizeof(int)),memset(exNxt,0xff,G.n*sizeof(int));",
			"                for(auto [idx,to]:G.edges_idx_to(source))push(source,idx,to);",
			"                for(highest=~exFi[0]?0:-1;~highest;highest--)while(~exFi[highest]){",
			"                    int v=exFi[highest];exFi[highest]=exNxt[v];discharge(v);",
			"                }",
			"                return ex[target]+G.T_inf;",
			"            };",
			"            auto push=[&](int v,int idx,int to,F f,bool pushToStack){",
			"                if(!f)return;",
			"                W[idx].flow-=f,W[idx^1].flow+=f,ex[v]-=f,ex[to]+=f;",
			"                if(pushToStack&&ex[to]>0&&ex[to]<=f)sta[stalen++]=to;",
			"            };",
			"            auto lookAhead=[&](int v){",
			"                if(ex[v])return false;",
			"                T delta=G.T_inf;",
			"                for(auto [idx,to]:G.edges_idx_to(v))if(W[idx].flow){",
			"                    T c=W[idx].cost+phi[v]-phi[to];",
			"                    if(c<0)return false;",
			"                    else ckmin(delta,c);",
			"                }",
			"                phi[v]-=delta+bnd;return true;",
			"            };",
			"            auto discharge=[&](int v){",
			"                T delta=G.T_inf;",
			"                for(auto [idx,to]:G.edges_idx_to(v))if(W[idx].flow){",
			"                    while(true)if(W[idx].cost+phi[v]-phi[to]>=0){ckmin(delta,W[idx].cost+phi[v]-phi[to]);break;}",
			"                    else if(!lookAhead(to)){push(v,idx,to,min(ex[v],W[idx].flow),true);break;}",
			"                    if (!ex[v])return;",
			"                }",
			"                phi[v]-=delta+bnd;sta[stalen++]=v;",
			"            };",
			"            for(int idx=0;idx<G.m;idx++)cost+=W[idx].cost*W[idx].flow,ckmax(bnd,W[idx].cost<<=mul);",
			"            flow=getMaxFlow();",
			"            fill(phi,phi+G.n,0),fill(ex,ex+G.n,0);",
			"            while(bnd>1){",
			"                bnd=max(bnd/SCALE,T(1));",
			"                for(int idx=0;idx<G.m;idx++){",
			"                    auto [v,to,_]=G.edge(idx);",
			"                    if(W[idx].flow&&W[idx].cost+phi[v]-phi[to]<0)push(v,idx,to,W[idx].flow,false);",
			"                }",
			"                for(int v=0;v<G.n;v++)if(ex[v]>0)sta[stalen++]=v;",
			"                while(stalen)discharge(sta[--stalen]);",
			"            }",
			"            for(int idx=0;idx<G.m;idx++)cost-=(W[idx].cost>>mul)*W[idx].flow;",
			"            return {cost/2+neg,flow};",
			"        }",
			"    };",
			"};",
		],
		"description": "mincost maxflow"
	},
	"bound flow":{
		"prefix": "BOUNDFLOW",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Base=HLPP_mf>struct BoundFlowHelper:Base<T>{",
			"        T sum;",
			"        template<template<typename U>typename Container>bool canFlow(BoundFlowNetwork<T,Container>&G){",
			"            sum=0;",
			"            for(int i=0;i<G.n-2;i++){",
			"                if(G.sum[i]>0)G.addEdge(G.n-2,i,G.sum[i]),sum+=G.sum[i];",
			"                else if(G.sum[i]<0)G.addEdge(i,G.n-1,-G.sum[i]);",
			"            }",
			"            return Base<T>::maxflow(G,G.n-2,G.n-1)==sum;",
			"        }",
			"        template<template<typename U>typename Container>T maxboundflow(BoundFlowNetwork<T,Container>&G,int source,int target){",
			"            G.addEdge(target,source,G.inf);",
			"            if(!canFlow(G))return -1;",
			"            return Base<T>::maxflow(G,source,target,false);",
			"        }",
			"        template<template<typename U>typename Container>T minboundflow(BoundFlowNetwork<T,Container>&G,int source,int target){",
			"            G.addEdge(target,source,G.inf);",
			"            if(!canFlow(G))return -1;",
			"            return G.inf-Base<T>::maxflow(G,target,source,false);",
			"        }",
			"    };",
			"};",
		],
		"description": "bound flow"
	},
	"stoer wagner":{
		"prefix": "STOER",
		"body": [
			"namespace OY{",
			"    template<typename T,template<typename U>typename Container>T StoerWagner(UndirectedDenseGraph<T,Container>&G){",
			"        T ans=G.inf;",
			"        bitset<VNUM>canChoose;",
			"        for(int i=0;i<G.n;i++)canChoose.set(i);",
			"        while(canChoose.count()>1){",
			"            bitset<VNUM>canVis(canChoose);",
			"            int source=-1,target=canVis._Find_first();",
			"            static T w[VNUM],Max;fill(w,w+G.n,0);",
			"            while(canVis.reset(target),canVis.count()){",
			"                Max=0,source=target;",
			"                for(int i=canVis._Find_first();i<G.n;i=canVis._Find_next(i))if(ckmax(Max,w[i]+=G.edge_cost(source,i)))target=i;",
			"            }",
			"            if(ckmin(ans,w[target])&&ans<=1)break;",
			"            canChoose.reset(target);",
			"            for(int i=canChoose._Find_first();i<G.n;i=canChoose._Find_next(i))if(T cost=G.edge_cost(target,i))G.addEdge(source,i,cost);",
			"        }",
			"        return ans;",
			"    }",
			"};",
		],
		"description": "stoer wagner"
	},
	"blossom":{
		"prefix": "BLOSSOM",
		"body": [
			"namespace OY{",
			"    struct Blossom{",
			"        int match[VNUM];",
			"        template<typename T,template<typename U>typename Container>int max_match(UndirectedGraph<T,Container>&G){",
			"            static int find[VNUM],from[VNUM],tag[VNUM],Time=0;",
			"            static bitset<VNUM>vis,inq;",
			"            static queue<int>q;",
			"            function<int(int)>Find=[&](int i){return find[i]==i?i:find[i]=Find(find[i]);};",
			"            auto lca=[&](int a,int b){",
			"                for(Time++;tag[a]!=Time;){if(~a)tag[a]=Time,a=~match[a]?Find(from[match[a]]):-1;if(~b)swap(a,b);}",
			"                return a;",
			"            };",
			"            auto blossom=[&](int a,int b,int l){",
			"                for(;Find(a)!=l;b=match[a],a=from[b]){",
			"                    from[a]=b;",
			"                    if(vis[match[a]]&&!inq[match[a]])inq.set(match[a]),q.push(match[a]);",
			"                    if(find[a]==a)find[a]=l;",
			"                    if(find[match[a]]==match[a])find[match[a]]=l;",
			"                }",
			"            };",
			"            auto aug=[&](int v){while(~v){int u=from[v],vv=match[u];match[v]=u,match[u]=v;v=vv;}};",
			"            auto bfs=[&](int x){",
			"                iota(find,find+G.n,0);",
			"                vis.reset(),inq.reset();",
			"                while(q.size())q.pop();",
			"                vis.set(x),inq.set(x),q.push(x);",
			"                while(q.size()){",
			"                    int p=q.front();q.pop();",
			"                    for(auto [idx,to]:G.edges_idx_to(p)){",
			"                        if(!vis[to]){",
			"                            from[to]=p,vis.set(to);",
			"                            if(!~match[to]){aug(to);return 1;}",
			"                            vis.set(match[to]),inq.set(match[to]),q.push(match[to]);",
			"                        }",
			"                        else if(inq[to]&&Find(to)!=Find(p)){",
			"                            int l=lca(Find(to),Find(p));",
			"                            blossom(to,p,l),blossom(p,to,l);",
			"                        }",
			"                    }",
			"                }",
			"                return 0;",
			"            };",
			"            int ans=0;",
			"            memset(match,0xff,G.n*sizeof(int));",
			"            for(int i=G.n-1;i>=0;i--)if(!~match[i])ans+=bfs(i);",
			"            return ans;",
			"        }",
			"    };",
			"};",
		],
		"description": "blossom"
	}
}