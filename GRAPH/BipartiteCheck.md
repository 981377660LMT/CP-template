### 一、模板类别

​	数据结构：二分图检验。

### 二、模板功能

#### 1.构造图

1. 数据类型

   构造参数 `uint32_t __vertexNum`​ ，表示图中的点数。

   构造参数 `uint32_t __edgeNum` ，表示图中预备要存的边数。

2. 时间复杂度

   $O(n+m)$ 。

3. 备注

   本数据结构用于检验一个有向图是否为二分图。

   本数据结构可以接受重边和自环。当然，一旦出现自环，一定不是二分图。
   
   **注意：**
   
   本数据结构一开始指定的 `__vertexNum` 参数必须是确切值。
   
   一开始指定的 `__edgeNum` 参数可以是模糊值，是用来为加边预留空间的，即使一开始没有留够空间，也可以自动扩容。如果边数不确定，可以预估一个上限填进去。

#### 2.加边

1. 数据类型

   输入参数 `uint32_t __a`​ ，表示有向边的起点编号。

   输入参数 `uint32_t __b` ，表示有向边的终点编号。

2. 时间复杂度

   $O(1)$ 。


#### 3.预备

1. 数据类型

2. 时间复杂度

   $O(n+m)$ 。

3. 备注

   本方法用于在加完所有边后，进行一些预处理。

#### 4.检验二分图

1. 数据类型

   返回类型 `bool` ，表示是否可以视为二分图。

2. 时间复杂度

   $O(n+m)$ 。

3. 备注

   在调用本方法之前请先预备。

   如果原图可以视为二分图，返回 `true` 。
   
   如果原图不可以视为二分图，返回 `false` 。
   
   本方法所采用的检验方法为染色法，如果可以视为二分图，那么可以根据 `m_colorCount` 来确定图中有几个连通分量。如果 `m_colorCount == 6` ，说明图中有三个连通分量，染色时颜色 `0` 和颜色 `1` 为一对，颜色 `2` 和颜色 `3` 为一对，颜色 `4` 和颜色 `5` 为一对。

### 三、模板示例

```c++
#include "GRAPH/BipartiteCheck.h"
#include "IO/FastIO.h"

int main() {
    OY::BipartiteCheck G(4, 3);
    //加三条边
    G.addEdge(0, 1);
    G.addEdge(1, 2);
    G.addEdge(2, 0);
    //预备
    G.prepare();
    //检查二分图
    if (!G.calc()) {
        cout << "It is not bipartite\n";
    } else {
        cout << "It is bipartite\n";
    }
}
```

```
#输出如下
It is not bipartite

```

