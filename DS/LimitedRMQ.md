### 一、模板类别

​	数据结构：约束 `RMQ` 。

### 二、模板功能

#### 1.建立约束 RMQ

1. 数据类型

   模板参数 `typename _Pick` ，表示在两个下标里选出最值下标的函数的类。

   构造参数 `_Pick __pick` ，表示具体的选取最值下标的函数。默认值为 `_Pick` 类的默认实例。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   约束 `RMQ` 处理的问题为区间最值下标查询，可以是区间最大值下标、区间最小值下标。

   既然名为约束 `RMQ` ，本模板对区间有一定的限制：区间上的相邻元素，差值只能为 `1` 或者 `-1` 。同样的，也有回报：初始化时间复杂度为 $O(n)$ ，查询时间复杂度为 $O(1)$  。显然，在满足条件的区间上，进行最值查询，约束 `RMQ` 的综合时间复杂度最优；初始化比 `ST` 表快，查询比线段树快。

   本模板不支持单点修改或者区间修改的功能，必要时只能重置整个区间。

#### 2.建立约束 RMQ

1. 数据类型

   构造参数 `_Iterator __first`​ ，表示区间最值查询的区间头。

   构造参数 `_Iterator __last` ，表示区间最值查询的区间尾。（开区间）

   其余同上。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   使用迭代器进行初始化，可以将区间初状态直接赋到 `ST` 表里。

#### 3.重置

1. 数据类型

   输入参数 `_Iterator __first` ，表示区间查询的区间头。

   输入参数 `_Iterator __last` ，表示区间查询的区间尾。（开区间）

2. 时间复杂度

   $O(n)$。

3. 备注

   使用迭代器进行重置，可以将区间初状态直接赋到 `ST` 表里。

#### 4.区间查询

1. 数据类型

   输入参数 `int __left` ，表示要查询的区间的左边界下标。

   输入参数 `int __right` ，表示要查询的区间的右边界下标。（闭区间）

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 5.查询全部

1. 数据类型

2. 时间复杂度

   $O(1)$。

### 三、模板示例

```c++
#include "DS/LimitedRMQ.h"
#include "IO/FastIO.h"

int main() {
    //先给出一个长度为 10 的数组
    int A[10] = {100, 99, 100, 101, 102, 103, 102, 103, 102, 103};
    for (int i = 0; i < 10; i++)
        cout << A[i] << (i == 9 ? '\n' : ' ');

    //建立一个区间最大值约束 RMQ
    auto pick_max = [&](int x, int y) {
        return A[x] > A[y] ? x : y;
    };
    //一般可以忽略模板参数
    OY::LimitedRMQ rmq(A, A + 10, pick_max);
    cout << "max(A[3~6]).index = " << rmq.query(3, 6) << endl;
}
```

```
#输出如下
100 99 100 101 102 103 102 103 102 103
max(A[3~6]).index     =5

```

