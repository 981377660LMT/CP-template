### 一、模板类别

​	数据结构：多维状态映射

### 二、模板功能

#### 1.构造映射

1. 数据类型

   构造参数 `_Iterator __first`​ 和 `_Iterator __last`​ ，表示每个维度的容量。

2. 时间复杂度

   $O(\prod^n_{i=1} (cap_i+1) )$ 。

3. 备注

   本数据结构是为了更高效地进行状态压缩而设计。最典型的应用，就是在时分秒表示制和一天中的第几秒之间进行换算。
   
   不失一般性，我们讨论一个问题，假设一年 `12` 月，每月固定 `30` 天，每天 `24` 小时，每小时 `60` 分钟，每分钟 `60` 秒钟。那么 `3` 月 `12` 日 `13` 时 `5` 分 `30` 秒，如何映射到一个整数？
   
   **第一种想法，就是在 `60` 进制下考虑问题。**那么总的状态空间就是 $60^5=777600000$ 。映射到的整数为 $2\times 60^4 +11\times 60^3 +13\times 60^2 +5\times 60+30=28343130$ 。
   
   **第二种想法，就是给每一个层级分配一定的二进制位。**月进年，分配 `4` 位；日进月，分配 `5` 位；
   
   时进日，分配 `5` 位；分进时，分配 `6` 位；秒进分，分配 `6` 位。那么总的状态空间就是 $2^{26}=67108864$ 。映射到的整数为 $(2<<22)+(11<<17)+(13<<12)+(5<<6)+30=9883998$ 。
   
   **第三种想法，就是让每一个层级设置单独的进位。**月满 `12` 进年，日满 `30` 进月，时满 `24` 进日，分满 `60` 进时，秒满 `60` 进分。那么总的状态空间就是 $12\times30\times24\times60\times60=31104000$ 。
   
   我们可以依次算出每个单位对应的秒数：
   
   一月对应 $60*60*24*30=2592000$ 秒；
   
   一日对应 $60*60*24=86400$ 秒；
   
   一时对应 $60*60=3600$ 秒；
   
   一分对应 $60$ 秒。
   
   那么原时间映射到的整数为 $2\times2592000+11\times86400+13\times3600+5\times60+30=6181530$ 。
   
   每一种想法的优劣是什么？
   
   想法一，每一位的单位都是 `60` 的幂，实现最为简单。缺点就是大量的状态空间点都是空白无用的，第一天的结尾 $23\times 60^2+59\times 60+59=86399$ ，和下一天的第一秒 $1\times60^3=216000$  是不连续的，而中间的 `86400~215999` 状态点都浪费了。
   
   想法二，每一位的进制都是不同的，所以空白无用的状态空间点大为减少。而且每一位的单位都是 `2` 的幂，非常便于位运算。缺点是，状态点仍然是不连续的。
   
   想法三，每一位的进制都是单独定制，没有空白无用的状态点。而且状态点之间无缝衔接，没有沟壑。缺点是，需要预处理计算出每一位对应的“秒数”。
   
   本模板就是想法三的实现。
   
   **注意：**如以上述例子调用本数据结构，构造参数里的维度容量，填写的是 `[11, 29, 23, 59, 59]` 。


#### 2.查询总状态数

1. 数据类型

2. 时间复杂度

   $O(1)$ 。
   

#### 3.查询对应的状态点

1. 数据类型

   输入参数 `_Iterator __sizes` ，表示一个迭代器，这个迭代器及之后的 `m_length` 个位置分别表示每一位的大小。

   返回类型 `uint32_t` ，表示状态点。

2. 时间复杂度

   $O(n)$  ，此处 `n` 表示维度数量。
   
3. 备注

   本函数不进行参数检查，所以使用者须自行保证每一位的大小不超过该位的容量。

#### 4.查询状态点对应的每位大小

1. 数据类型

   输入参数 `uint32_t __mask` 表示状态点。

   返回类型 `std::vector<uint32_t>` ，表示 `m_length` 个位上每位的大小。

2. 时间复杂度

   $O(n)$  ，此处 `n` 表示维度数量。

3. 备注

   本函数不进行参数检查，所以使用者须自行保证状态点在总状态范围内。

#### 5.查询状态点的子集

1. 数据类型

   输入参数 `uint32_t __mask` 表示状态点。

   返回类型 `std::vector<uint32_t>` ，表示所有的子集。

2. 时间复杂度

   $O(1)\sim O(\prod^n_{i=1}size_i)$  ，此处 `n` 表示维度数量，`size_i` 表示 `__mask` 第 `i` 位的大小。

   如果对所有状态点枚举子集，总时间复杂度为 $\prod^n_{i=1}\frac {(cap_i+1)\cdot(cap_i+2)}2$ 。

   特别的，如果每一位的容量都是 `1` ，转化为二进制枚举，总时间复杂度为 $O(3^n)$ 。

3. 备注

   子集的枚举顺序为从小到大。

   本函数不进行参数检查，所以使用者须自行保证状态点在总状态范围内。

#### 6.查询包含状态点的集合

1. 数据类型

   输入参数 `uint32_t __mask` 表示状态点。

   返回类型 `std::vector<uint32_t>` ，表示所有包含 `__mask` 的集合。

2. 时间复杂度

   $O(1)\sim O(\prod^n_{i=1}(cap_i-size_i+1))$  ，此处 `n` 表示维度数量， `cap_i` 表示每一位的容量，`size_i` 表示 `__mask` 第 `i` 位的大小。

   如果对所有状态点枚举包含他的集合，总时间复杂度为 $\prod^n_{i=1}\frac {(cap_i+1)\cdot(cap_i+2)}2$ 。

   特别的，如果每一位的容量都是 `1` ，转化为二进制枚举，总时间复杂度为 $O(3^n)$ 。

3. 备注

   子集的枚举顺序为从小到大。

   本函数不进行参数检查，所以使用者须自行保证状态点在总状态范围内。

#### 7.查询某一维度的容量

1. 数据类型

   输入参数 `uint32_t __i` ，表示某一维度。

   返回类型 `uint32_t` ，表示该维度容量。

2. 时间复杂度

   $O(1)$  。

#### 8.查询某状态点某一维度的大小

1. 数据类型

   输入参数 `uint32_t __mask` ，表示某一状态点。

   输入参数 `uint32_t __i` ，表示某一维度。

   返回类型 `uint32_t` ，表示该状态点在该维度的大小。

2. 时间复杂度

   $O(1)$  。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/MultiDimensionMap.h"

int main() {
    int caps[] = {59, 59, 23, 29, 11};
    //针对 月/日/时/分/秒 建立多维映射表
    OY::MultiDimensionMap mdm(caps, caps + 5);
    //总状态数
    cout << "number of different states: " << mdm.queryTotal() << endl;
    //查询 3 月 12 日 13 时 5 分 30 秒对应的状态点。注意转换成 0-index
    cout << "3.12, 13:05:30 is state: " << mdm.queryMask({30, 5, 13, 11, 2}) << endl;
    //查询状态点 31103999 对应的每一位大小
    std::vector<uint32_t> sizes = mdm.querySizes(31103999);
    cout << "31103999 is: " << sizes[4] + 1 << "." << sizes[3] + 1 << ", " << sizes[2] << ":" << sizes[1] << ":" << sizes[0] << endl;
    //查询状态点 3 月 1 日 0 时 2 分 1 秒 的状态点的子集
    uint32_t mask = mdm.queryMask({1, 2, 0, 0, 2});
    for (auto sub : mdm.querySubs(mask)) {
        auto sizes = mdm.querySizes(sub);
        cout << "sub of 3.1 00:02:01 : " << sizes[4] + 1 << "." << sizes[3] + 1 << ", " << sizes[2] << ":" << sizes[1] << ":" << sizes[0] << endl;
    }
    //查询状态点 10 月 29 日 22 时 59 分 58 秒 的状态点的 "包含它的集合"
    uint32_t mask2 = mdm.queryMask({58, 59, 22, 28, 9});
    for (auto includes : mdm.queryIncludes(mask2)) {
        auto sizes = mdm.querySizes(includes);
        cout << "includes of 10.29 22:59:58 : " << sizes[4] + 1 << "." << sizes[3] + 1 << ", " << sizes[2] << ":" << sizes[1] << ":" << sizes[0] << endl;
    }
    //查询 秒 维度容量
    cout << "capacity of second: " << mdm.queryDimesionCapacity(0) << endl;
    //查询 mask2 秒 维度大小
    cout << "mask2's size of second: " << mdm.queryDimesionSize(mask2, 0) << endl;
}
```

```
#输出如下
number of different states: 31104000
3.12, 13:05:30 is state: 6181530
31103999 is: 12.30, 23:59:59
sub of 3.1 00:02:01 : 1.1, 0:0:0
sub of 3.1 00:02:01 : 1.1, 0:0:1
sub of 3.1 00:02:01 : 1.1, 0:1:0
sub of 3.1 00:02:01 : 1.1, 0:1:1
sub of 3.1 00:02:01 : 1.1, 0:2:0
sub of 3.1 00:02:01 : 1.1, 0:2:1
sub of 3.1 00:02:01 : 2.1, 0:0:0
sub of 3.1 00:02:01 : 2.1, 0:0:1
sub of 3.1 00:02:01 : 2.1, 0:1:0
sub of 3.1 00:02:01 : 2.1, 0:1:1
sub of 3.1 00:02:01 : 2.1, 0:2:0
sub of 3.1 00:02:01 : 2.1, 0:2:1
sub of 3.1 00:02:01 : 3.1, 0:0:0
sub of 3.1 00:02:01 : 3.1, 0:0:1
sub of 3.1 00:02:01 : 3.1, 0:1:0
sub of 3.1 00:02:01 : 3.1, 0:1:1
sub of 3.1 00:02:01 : 3.1, 0:2:0
sub of 3.1 00:02:01 : 3.1, 0:2:1
includes of 10.29 22:59:58 : 10.29, 22:59:58
includes of 10.29 22:59:58 : 10.29, 22:59:59
includes of 10.29 22:59:58 : 10.29, 23:59:58
includes of 10.29 22:59:58 : 10.29, 23:59:59
includes of 10.29 22:59:58 : 10.30, 22:59:58
includes of 10.29 22:59:58 : 10.30, 22:59:59
includes of 10.29 22:59:58 : 10.30, 23:59:58
includes of 10.29 22:59:58 : 10.30, 23:59:59
includes of 10.29 22:59:58 : 11.29, 22:59:58
includes of 10.29 22:59:58 : 11.29, 22:59:59
includes of 10.29 22:59:58 : 11.29, 23:59:58
includes of 10.29 22:59:58 : 11.29, 23:59:59
includes of 10.29 22:59:58 : 11.30, 22:59:58
includes of 10.29 22:59:58 : 11.30, 22:59:59
includes of 10.29 22:59:58 : 11.30, 23:59:58
includes of 10.29 22:59:58 : 11.30, 23:59:59
includes of 10.29 22:59:58 : 12.29, 22:59:58
includes of 10.29 22:59:58 : 12.29, 22:59:59
includes of 10.29 22:59:58 : 12.29, 23:59:58
includes of 10.29 22:59:58 : 12.29, 23:59:59
includes of 10.29 22:59:58 : 12.30, 22:59:58
includes of 10.29 22:59:58 : 12.30, 22:59:59
includes of 10.29 22:59:58 : 12.30, 23:59:58
includes of 10.29 22:59:58 : 12.30, 23:59:59
capacity of second: 59
mask2's size of second: 58

```

